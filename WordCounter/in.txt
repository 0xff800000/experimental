M.C.S.E 3
1
PRESENTATION GENERALE
DE LA METHODOLOGIE
Cette première partie rappelle les éléments caractéristiques et la démarche de la
méthodologie MCSE (Méthodologie pour la Conception des Systèmes Electroniques) décrits
dans l’ouvrage "Spécification et conception des systèmes, une Méthodologie MCSE" de
l’auteur [CALVEZ-90]. Ce schéma d’organisation des développements est illustré par toutes
les études de cas qui suivent.
La méthodologie MCSE couvre les phases de Spécification, de Conception Fonctionnelle
aussi appelée par ailleurs Conception Préliminaire, de définition de la Réalisation ou
Conception Détaillée.
Développée spécialement pour les applications temps-réel en contrôle/commande, elle a été
appliquée sur de multiples problèmes industriels. L'adéquation du modèle à la problématique
traitée a ainsi été validée ainsi que l'intérêt de toutes les étapes.
Si cette méthodologie concerne plus particulièrement le domaine des systèmes
électroniques temps-réel, il se trouve que la démarche suivie pour les premières phases du
développement - spécification, conception architecturale - se trouve indépendante de la
réalisation, puisqu'il s'agit d'une approche SYSTEME. Des expériences intéressantes ont été
entreprises quant à son utilisation pour des applications variées : systèmes de contrôle/
commande, réseaux et protocoles, systèmes répartis, outils interactifs, conception de
composants intégrés.
ETUDES DE CAS
4 M.C.S.E
Une large expérimentation de la méthodologie a montré l'importance du modèle, puis
l'importance des règles et conseils qui engendrent chez les concepteurs des solutions de qualité.
Nous avons aussi constaté que les solutions de qualité peuvent s'exprimer sous la forme de
modèles génériques. Ainsi, la connaissance de tels modèles génériques de solutions pour
diverses classes de problèmes facilite la tâche du concepteur et favorise la production de
solutions de qualité au sens : lisibilité, maintenabilité, efficacité ... et donc coût.
En aval de la conception, la phase de définition de la réalisation propose une démarche
systématique qui conduit, à partir d'une solution fonctionnelle, à choisir la technique de
réalisation la plus appropriée pour le problème (type de technologie, répartition matériel/
logiciel, respect des contraintes de temps...).
1.1. DESCRIPTION D’UN SYSTEME
Une méthodologie est un guide pour le développement d’applications. MCSE préconise
une démarche globalement descendante qui conduit à rechercher par approches successives,
une réalisation appropriée.
La décomposition en étapes est basée sur la possibilité de décrire un système selon plusieurs
niveaux d’abstraction. Ainsi une méthodologie se comprend bien lorsque le modèle de
description des systèmes à concevoir est explicité.
Pour résumer la démarche préconisée, la structuration d’un système pour MCSE est décrite
selon un ensemble de niveaux comme l’indique la figure ci-après.
Si on part du niveau le plus abstrait pour descendre jusqu’au niveau de la réalisation, on
trouve:
- le niveau Cahier des charges, qui correspond à l’expression du besoin. Pour ce niveau,
le système n’est pas encore défini. Les informations concernent l’application dans son
ensemble avec les objectifs souhaités.
- le niveau Spécification. Il correspond à la description du système à concevoir selon une
vue purement externe. Les spécifications incluent toutes les contraintes auxquelles doit
satisfaire le système.
- le niveau Description Fonctionnelle, exprimant la structure du système sur le plan
fonctionnel. Cette description interne a la particularité d’être indépendante de toutes les
contraintes technologiques.
- le niveau Description exécutive, qui explicite les spécifications complètes de la
réalisation en décrivant la partie matérielle par une structure d’exécution et la partie
logicielle par des schémas d’implantation logicielle. Entre ce niveau et le précédent 2
sous-niveaux sont intéressants comme intermédiaires:
. le niveau fonctionnel avec les interfaces qui découle du sous-niveau précédent avec
ajout de toutes les interfaces physiques nécessaires pour le couplage avec
l’environnement réel du système.
. le niveau fonctionnel avec répartition qui résulte de la description fonctionnelle en
y ajoutant la contrainte de répartition géographique, ce qui se traduit par l’utilisation
de mécanismes pour le transport des informations entre les sous-ensembles répartis.
- le niveau Réalisation qui décrit la solution finale comme un ensemble de cartes et de
logiciels.
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 5
-Figure 1.1- Niveaux de description d’un système.
Cette décomposition en niveaux permet d’induire assez simplement la démarche à suivre.
En partant du problème posé, chaque étape a pour objectif d’enrichir la description par ajout
d’informations à partir des contraintes à satisfaire.
processeur 2
+ logiciel
processeur 1
+ logiciel
carte 1 carte 2
logiciel 1 logiciel 2
Application
Système
Ve Vi Vs
F1 F2
MVI
E R
Etape 1
Spécification
Etape 2
Conception
fonctionnelle
Etape 3
Partitionnement
Adaptation
Implantation
Etape 4
Réalisation
Description
externe
Description
fonctionnelle
détaillée
exécutive
Description de
la réalisation
Description
Description
fonctionnelle
Niveau spécification
Niveau fonctionnel
Niveau répartition
Niveau interfaces
Niveau exécutif
Niveau réalisation
Cahier des charges
4
3
2"
2’
2
1
0
Modèle de description d’un système Démarche
Allocation
implantation
Description
fonctionnelle
avec répartition
sous-ensemble 1 sous-ensemble 2
Définition de la
réalisation
Allocation
ETUDES DE CAS
6 M.C.S.E
1.2. LA DEMARCHE
La démarche de conception basée sur l'emploi du modèle précédent exprime le processus
de réflexion que doit suivre le concepteur pour aboutir à une description conforme au modèle,
tout en répondant à des critères de qualité : robustesse, modularité, lisibilité, maintenabilité.
Chaque niveau de description sert d'intermédiaire entre 2 étapes consécutives. Le
développement s'effectue selon 4 étapes:
- L'élaboration des spécifications, de manière à exprimer à partir du besoin une vue
purement externe du système (WHAT).
- La conception fonctionnelle, qui a pour objectif de trouver la description fonctionnelle,
composée d’une structure fonctionnelle pour l’organisation interne de la solution et du
comportement de toutes les fonctions nécessaires (HOW).
- La définition de la réalisation (aussi appelée conception détaillée), le but étant de
trouver une structure d'exécution comme support matériel, ainsi qu'une implantation
logicielle sur la structure matérielle retenue, en considérant toutes les contraintes
technologiques: contraintes de répartition, contraintes de temps, contraintes électriques.
- La réalisation conduisant à un système opérationnel.
La figure suivante décrit l'enchaînement des 4 étapes.
-Figure 1.2- Enchaînement des étapes pour MCSE.
Niveau 1
Niveau 2
Niveau 3
Niveau 4
Abstrait
Concret
PRODUIT
Temps
DEFINITION
de la
REALISATION
REALISATION
Spécifications
Description fonctionnelle
Description exécutive
Modèles
Spécification
Modèle
fonctionnel
Modèle
d’exécution
Spécifications
Spécifications
fonctionnelles
et opératoires
CHARGES
CAHIER
DES
technologiques
CONCEPTION
FONCTIONNELLE
Spécifications technologiques de réalisation
SPECIFICATION
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 7
Pour chaque étape, le concepteur dispose en entrée : de la description d'un niveau
intermédiaire comme résultat de l'étape précédente, de renseignements complémentaires que
sont les contraintes imposées dans les spécifications. L'étape produit une description du niveau
suivant conforme au modèle pour l’étape. Une vérification de conformité est possible à l'issue
de chaque étape.
Dans les paragraphes suivants et sans entrer dans les détails, nous passons en revue les
différentes étapes de la méthodologie en précisant les principes.
1.2.1. Elaboration des spécifications
Pour pouvoir concevoir, il faut tout d'abord disposer des spécifications. Par spécifications,
il faut entendre une description complète mais purement externe du système à concevoir. Plus
ces spécifications sont détaillées et conformes à des modèles formels, plus il est facile de
déduire une solution. Mais cette spécification doit aussi être vérifiable, en particulier par le
demandeur.
Le point de départ est le cahier des charges décrivant le besoin du demandeur. Pour décrire
ce que doit faire un système, celui-ci est considéré comme observant et agissant sur les objets
de son environnement. Il faut donc tout d'abord connaître cet environnement. Le connaître,
c'est dans un premier temps modéliser les objets, et dans un second temps, expliciter les
relations entre eux sous la forme d'une description fonctionnelle.
Ensuite, expliciter le rôle du système et donc exprimer ses spécifications consiste à énoncer
et à caractériser les fonctions demandées. Ceci se fait en détaillant le comportement souhaité
des objets de l'environnement sous le contrôle du système, ainsi que toutes les contraintes
imposées.
Par cette approche, la méthodologie fait apparaître une similitude de raisonnement entre la
démarche pour obtenir les spécifications et celle pour concevoir. L'analyse de l'environnement
conduit à une synthèse de la réalité sous la forme d’un modèle, et l'introduction des objectifs à
atteindre conduit à un enrichissement de la modélisation précédente en considérant en
supplément l'apport du système.
Cette étape permet d'obtenir 3 types de spécifications:
- les spécifications fonctionnelles: elles comprennent la liste des fonctions du système
pour l'application (fonctions externes) et la description du comportement du système et
de l'environnement pour ces fonctions.
- les spécifications opératoires, qui concernent le comportement, les performances,
précisions, les méthodes à utiliser ...
- les spécifications technologiques, qui incluent : les contraintes de temps et de
répartition, les caractéristiques des interfaces physiques, les contraintes de réalisation.
Les spécifications fonctionnelles et opératoires sont utilisées durant l'étape de conception
fonctionnelle, tandis que les spécifications technologiques ne servent que pour les étapes de
définition de la réalisation et de réalisation.
ETUDES DE CAS
8 M.C.S.E
Les phases pour cette étape sont décrites par la figure ci-après.
-Figure 1.3- Déroulement pour l'étape de spécification.
1.2.2. Conception fonctionnelle
La solution pour cette étape se déduit d'une analyse des spécifications fonctionnelles. Elle
doit être conforme au modèle fonctionnel.
La recherche de la structure fonctionnelle se fait tout d'abord à partir de la délimitation du
système avec ses entrées et ses sorties. Il s'agit ensuite de trouver une première décomposition
fonctionnelle. Cette première approche est importante car elle induit la qualité ou la non-qualité
pour le reste du développement.
La démarche consiste ensuite à rechercher par raffinements successifs et pour chaque
fonction à concevoir, les variables et événements internes caractéristiques nécessaires et si
possible suffisants. Se déduisent alors les fonctions qui exploitent et assurent la mise à jour de
ces variables ainsi que le comportement de chaque fonction. Le raffinement est poursuivi
jusqu'à l'obtention de fonctions élémentaires qui peuvent s'exprimer par une description
purement séquentielle.
L'expérience nous a montré que cette approche basée sur les données conduit à des
structures fonctionnelles simples (réduction des couplages exprimant des relations d'ordre) et
plus structurées que l'approche basée sur les fonctions, qui conduit à exprimer la structure
comme décrivant un enchaînement de transformations.
Analyse
environnement
Comportement
des
entités
Description
fonctionnelle
Délimitation
des
entrées/sorties
Comportement
entités
+ système
Spécifications
opératoires
Spécifications
technologiques
Modélisation
de
l’environnement
Elaboration
des
spécifications
CAHIER
DES
CHA
R
GES
Spécifications fonctionnelles
Fonctions
SPECIFICATIONS
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 9
La figure ci-dessous décrit la procédure à suivre.
-Figure 1.4- Les phases pour l'étape de Conception fonctionnelle.
1.2.3. Définition de la réalisation
La troisième étape consiste à rechercher, d'une part le support exécutif, d'autre part la
manière d'y implanter les fonctions réalisées par logiciel.
Tout d'abord, la description fonctionnelle doit être affinée, détaillée, enrichie pour tenir
compte des contraintes technologiques que sont: la répartition géographique (si nécessaire), les
interfaces physiques, les interfaces utilisateur.
Les contraintes de temps sont ensuite analysées pour déduire la répartition matériel/logiciel.
La partie matérielle est spécifiée par une structure d'exécution. L'intégration ou allocation
décrit complètement l'implantation de la description fonctionnelle sur la structure d'exécution.
Chaque sous-ensemble fonctionnel à réaliser par logiciel est décrit par un schéma
d'implantation logicielle qui exprime la priorité de chaque tâche, et les relations de dépendance
spatiale (par des données) ou temporelles. Cette implantation résulte de l'utilisation de règles
qui permettent d'effectuer des transformations tenant compte du support matériel.
L'enchainement des phases pour cette étape est représenté par la figure 1.5 ci-après.
Délimitation des
entrées sorties
première décomposition
fonctionnelle
Fonctions
Première approche fonctionnelle
Raffinement
Synthèse
fonctionnel
Raffinement
Description
algorithmique
Document de
conception
fonctionnelle
Structure fonctionnelle finale
Document
de
spécifications
ETUDES DE CAS
10 M.C.S.E
-Figure 1.5- Les phases pour l'étape de définition de la réalisation.
1.2.4. Réalisation
Les 2 parties - support matériel, implantation du logiciel - favorisent le travail de réalisation
d'un prototype, l'intégration et le test.
Il faut être conscient à ce stade de la variété des stratégies de réalisation qui dépendent d'au
moins 3 facteurs : les spécifications en entrée, les techniques à mettre en oeuvre, les outils et
méthodes disponibles.
La réalisation est une démarche ascendante puisqu’elle consiste à assembler. Il s'agit de
développer partie par partie la solution en faisant apparaître des fonctionnalités de plus en plus
abstraites pour se rapprocher de l'objectif. Chaque niveau de la construction est validé par une
vérification de la conformité aux spécifications du niveau correspondant de la démarche
descendante. Réalisation matérielle et réalisation du logiciel peuvent se développer
simultanément, ce qui permet de réduire le temps de la réalisation et de faire intervenir
conjointement des spécialistes des 2 domaines.
Pour achever la réalisation, l'intégration et le test ont pour objectif de réunir toutes les
parties des développements de manière à fournir un système opérationnel conforme aux
souhaits du demandeur.
Cette démarche pour la réalisation est représentée ci-après.
Introduction de
la répartition
Introduction des
interfaces
Solution fonctionnelle détaillée
contraintes de temps allocation
implantation
structure
d’exécution
Spécification des
implantations
logicielles
Spécification de
la réalisation
matérielle
Solution fonctionnelle + spécifications technologiques
Détermination de la
structure d’exécution
Document
pour la
réalisation
contraintes
électriques
contraintes de développement
contraintes de
répartition
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 11
-Figure 1.6- Démarche pour la réalisation.
1.3. CARACTERISTIQUES DE MCSE
MCSE est une démarche complète qui permet de passer du problème à une réalisation.
Nous reprenons ici les aspects généraux essentiels de la méthodologie.
-A- UN MODELE DE DESCRIPTION COMME BASE
Toute méthodologie est basée sur un ou des modèles, ceci permet une décomposition en
étapes. MCSE est basée sur un modèle de description interne en 3 composantes. Ce modèle
incite à décrire tout système selon une hiérarchie de niveaux de description. Chaque niveau sert
d'intermédiaire entre 2 étapes. La plupart des modèles sont graphiques, favorisant ainsi une
compréhension globale et rapide.
-B- UNE DEMARCHE GLOBALEMENT DESCENDANTE POUR LA CONCEPTION
Chaque étape de la méthodologie permet de passer d'un niveau de description au niveau
plus détaillé suivant en enrichissant la solution d'une composante supplémentaire.
La progression est donc globalement descendante puisqu'elle part du problème posé jusqu'à
aboutir à une réalisation opérationnelle.
SPECIFICATION DE REALISATION
Structure d’exécution Allocation Implantation logicielle
VERIFICATION DES SPECIFICATIONS
Schéma de
réalisation
Implantation
et réalisation
Test composants
et cartes
Ecritures : tâches
modules
procédures
Compilation
chargement
Test du
logiciel
Dialogue
Réalisation matérielle Réalisation logicielle
INTEGRATION et TESTS
produit opérationnel
Outils Outils
Instrumentation
Système
de
développement
ETUDES DE CAS
12 M.C.S.E
-C- UNE PROGRESSION ITERATIVE
Un développement ne peut pas se faire sans erreurs ou omissions. Des corrections sont
toujours nécessaires. Basée sur la correction par retours-arrières, une phase de vérification en
fin de chaque étape permet la détection des erreurs et induit un travail itératif avec des retours
à l'intérieur de l'étape ou sur les étapes précédentes.
-D- UNE METHODE SPECIFIQUE POUR CHAQUE ETAPE
Le modèle de description de la solution à l'issue de chaque étape n'est pas suffisant (le
QUOI). Le concepteur doit disposer pour chaque étape d'un guide précis lui expliquant
COMMENT passer de la spécification en entrée à une solution possédant des qualités. Ce guide
est la méthode à suivre : technique d'analyse, séquence des décisions, critères de choix. Par
opposition à une recherche intuitive, l'emploi d'une méthode garantit l'obtention rapide d'une
solution a priori de qualité.
Au-delà de l'aspect méthode, l'idée des modèles génériques de solutions a un intérêt certain.
De tels modèles ayant la particularité pour la décomposition fonctionnelle d’être générateurs
de multiples solutions, sont retenus car possédant des qualités intrinsèques: lisibilité,
maintenabilité, simplicité, adéquation au modèle global MCSE. La connaissance de tels
modèles, en complément des méthodes, améliore notablement le pourcentage des
développements corrects.
-E- UNE DEMARCHE GLOBALEMENT ASCENDANTE POUR LA REALISATION
L'assemblage n'est possible qu'après disponibilité des constituants. Ainsi, la réalisation
débute par la réalisation des plus petits sous-ensembles, puis remonte progressivement par
assemblage et intégration de fonctions plus globales. Le travail de réalisation est représentable
par un triangle juxtaposé à celui de la conception comme l’indique la figure suivante. La
largeur du triangle pour chaque stade indique la quantité d'informations à maîtriser.
-Figure 1.7- Forme en double triangle pour le développement.
BESOIN PRODUIT
SPECIFICATION
CONCEPTION
FONCTIONNELLE
DEFINITION
REALISATION
MATERIELLE LOGICIELLE
RECETTE
CERTIFICATION
TEST
VALIDATION
INTEGRATION
REALISATION
MATERIELLE
REALISATION
LOGICIELLE
DE LA
VERIFICATION
TEST
Spécification
conception
Validation
Réalisation
CONFORMITE
VALIDATION
PARTIE PARTIE
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 13
Chaque niveau de la réalisation est vérifiable, ce qui assure sa conformité au niveau
correspondant de la conception. La figure 1.7 illustre la correspondance entre les 2 démarches
complémentaires.
-F- UN MODELE DE CYCLE DE DEVELOPPEMENT HIERARCHIQUE
Pour un système relativement complexe, le modèle ci-dessus en double triangle n'est pas
suffisamment précis.
L'étape de définition de la réalisation conduit à mettre en évidence les 2 parties : matériel,
logiciel. Chaque partie est à nouveau à développer selon une démarche en 3 phases :
spécification, conception, définition de la réalisation, et ceci jusqu'à la mise en évidence des
constituants disponibles (composants matériels ou logiciels).
Ainsi comme le montre la figure ci-après, le modèle de cycle de développement est un
emboîtement de développements. Au premier niveau, la conception est générale et concerne
l'application dans son ensemble. Au fur et à mesure du raffinement de la solution, les
développements concernent des problèmes plus spécifiques en rapport avec la réalisation :
développement d'un composant, d'une fonction spécifique, d'un module logiciel ...
-Figure 1.8- Modèle hiérarchique pour le développement.
-G- GUIDE POUR LA DOCUMENTATION
Le modèle de description induit directement la structure des documents à produire durant
le développement. Chaque document est le résultat d'une étape, et sert comme informations
pour l'étape suivante.
SYSTEME
SOUS-ENSEMBLE
MATERIEL LOGICIEL
CARTE , COMPOSANT TACHE , MODULE
MCSE
Spécification conception
fonctionnelle
définition réalisation
Sous-
Assemblage
Test
Validation
Spécification
Spécifi-
Spécifi-
Spécifi-
Spécificonception
fonctionnelle
conception
conception
conception
fonctionconception
préliminaire
définition réalisation Intégration
Test
Définition
Réalisation
Définition
Réalisation
comp. i
carte i
Tache i
Module i
Matériel Logiciel
Assem-
Test
Test
détaillée unitaire
conception
Réalisation
Assem-
Test
Domaine de
Cahier
des charges
Problème Produit
ensemble i
cation
blage
cation
nelle
blage
cation cation
Etude
préliminaire
ETUDES DE CAS
14 M.C.S.E
Ainsi, en respectant la démarche par étapes successives, la documentation est générée au
fur et à mesure du développement et non en final. Elle possède alors une réelle qualité quant à
la forme et au fond puisqu'elle relate, en plus de la solution, la démarche suivie et
l'argumentation qui justifie les décisions importantes.
Produite de cette manière, la documentation est utilisable durant le cycle de
développement: pour les phases de vérification selon un cycle auteur-lecteurs, pour
l'observation de l'état d'avancement, mais aussi pour les étapes ultérieures et en particulier pour
la maintenance.
-H- GUIDE POUR LA CONDUITE DE PROJET
Le modèle de cycle de développement est utilisable pour la mise en place d'une procédure
de conduite d'un ensemble de projets. Pour chaque projet, cette activité concerne :
- le management : planification, organisation, direction, contrôle et suivi du projet,
- l'obtention de la conformité : planification des tests, nature des tests techniques à
utiliser, les résultats, conformité et certification,
- la gestion de la documentation : spécification des documents, planification des revues,
méthodes de gestion, mises à jour ...
- la gestion de la maintenance : domaine et procédures de maintenance, solutions et
outils, planification,
- la gestion de la qualité : assurance qualité, méthode pour l'obtention de la qualité,
procédures de contrôle.
-I- UNE METHODOLOGIE OUVERTE ET COMPLEMENTAIRE
MCSE ne se trouve pas restreinte à une méthode particulière et à un domaine bien
spécifique. Au contraire, pour chaque étape, plusieurs méthodes sont utilisables et c'est au
concepteur de choisir selon des critères, celle qui lui permet de résoudre au mieux son
problème.
Développée au départ pour les systèmes de contrôle/commande temps-réel à
microprocesseurs, l'expérience nous a montré son adéquation pour une large classe
d'application et de techniques, et tout particulièrement pour les applications qui utilisent
l'électronique et l'informatique. MCSE n'est pas à opposer aux autres méthodologies, bien au
contraire, elle se veut complémentaire. La plupart des modèles proposés par différents auteurs
s'avèrent utilisables. Par exemple, SADT et les méthodes de spécification de WARD et
MELLOR et de HATLEY favorisent la tâche d'analyse du problème. La méthodologie de
JACKSON est dans l'esprit relativement proche de MCSE. Les méthodologies DARTS et
SDWMC de BUHR ont aussi des points communs.
1.4. CONSEILS POUR UNE UTILISATION RATIONNELLE DE MCSE
Nous rappelons ici les principes essentiels de la Méthodologie qu'il est conseillé de suivre
pour obtenir les meilleurs résultats. Ces principes répondent à des difficultés couramment
rencontrées par les concepteurs.
Au préalable, il est bon de rappeler que le développement est une activité humaine mettant
en jeu une méthodologie et un système social. Les 2 parties ont une importance pour la réussite.
Aussi, l'attitude volontariste des concepteurs est une première condition strictement nécessaire
pour le succès de la démarche.
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 15
Ensuite, un bon concepteur doit savoir se placer au dessus des aspects techniques et ceci en
utilisant le plus possible des concepts. Il ne doit pas se laisser guider par une solution a priori;
dans ce cas problablement, il aboutira à la conclusion qu’elle est correcte sans avoir évaluer
d’autres alternatives. Il est aussi essentiel de chercher à satisfaire la demande et non pas se
satisfaire de son développement.
Nous citons ci-dessous pour chaque étape, quelques-unes des difficultés que tout utilisateur
de la méthodologie risque de rencontrer et le point de vue à adopter.
-A- ETAPE DE SPECIFICATION
Concernant l’étape de spécification, il y a 2 difficultés. Tout d'abord pour la modélisation
de l'environnement, il faut décider du modèle le plus approprié pour cet environnement, à la
fois sa nature et son niveau de détail. Pour être bonne, l'analyse doit se faire sur un plan
fonctionnel et non matériel. Il faut donc penser aux entités fonctionnelles. Ceci est une
difficulté qui conduit à des erreurs fréquentes. De l'analyse se déduit la nature du modèle qu'il
faut rechercher dans l'ordre de complexité: modèle statique données/évènements, modèle
dynamique global, modèle des activités. La modélisation est à faire selon un niveau de détails
nécessaire mais juste suffisant pour résoudre le problème. Elle ne doit pas faire intervenir le
système à concevoir.
Ensuite, pour l'élaboration des spécifications fonctionnelles, celles-ci doivent se limiter à
une description externe du système. Les fonctions du système ne doivent être que des fonctions
de l'application, qu'il ne faut surtout pas confondre avec les fonctions internes du système.
S’assurer de la complétude d’une spécification est aussi une réelle difficulté. Celle-ci doit
apparaitre cohérente, claire et doit être vérifiée par le demandeur.
-B- ETAPE DE CONCEPTION
Pour cette étape, le premier point important est de faire une conception indépendante de la
technologie. La première difficulté est donc de faire abstraction des contraintes technologiques
et donc de toute idée de réalisation. Pour cela, il faut éliminer tous les problèmes de répartition
géographique et d'interfaces pour se consacrer au seul aspect fonctionnel. Il faut donc déjà
partir des entrées et sorties fonctionnelles et non pas physiques.
Ensuite, la recherche d'une solution est à faire sur la base des variables internes nécessaires
et non pas sur la base des fonctions internes, alors que la tendance naturelle consiste à
appréhender le problème par les fonctions. L'approche préconisée conduit à une solution plus
simple à comprendre et plus simple à implanter. Les idées de solutions peuvent aussi se déduire
de modèles génériques de solution. L'intérêt est de disposer d'un guide pour la recherche de
variables.
D'une manière générale, le concepteur doit avoir des idées pour être créatif mais doit faire
abstraction de son idée a priori, sinon il conduira son développement sur la base de cette idée
inhibant alors l’évaluation de toute autre solution peut-être meilleure.
C- ETAPE DE DEFINITION DE LA REALISATION
Une des tendances naturelles consiste à entreprendre la réalisation rapidement:
développement ou choix du matériel très tôt et écriture du logiciel. L’étape de définition de la
réalisation est une étape de réflexion importante qui conduit à réduire l’effort de
développement pour en particulier la réalisation. Cette étape permet de s'adapter aux
ETUDES DE CAS
16 M.C.S.E
caractéristiques de l'environnement, en introduisant les interfaces. Pour cela, il faut rechercher
la solution la plus appropriée, c'est particulièrement le cas pour l'interface homme-machine.
D’autre part, les contraintes de temps doivent être évaluées correctement pour le cas le plus
défavorable de manière à pouvoir prouver a priori le bon fonctionnement de l'application.
De cette analyse découle ensuite la recherche de la répartition matériel/logiciel qui a pour
objectif de réduire au maximum le développement. La démarche conduit à minimiser le
matériel, puis le logiciel. Concernant le logiciel, il est composé de 2 parties: la partie opératoire
strictement nécessaire pour le fonctionnement et donc relativement incompressible si la
spécification comportementale a été bien élaborée, et la partie dite organisationnelle qui
concerne les relations entre les fonctions. Cette deuxième partie est compressible, et l'objectif
des transformations pour obtenir le schéma d'implantation logicielle est de réduire au
maximum cette partie. La Méthodologie favorise cette réduction. Cette approche est tout à fait
justifiée pour les applications temps-réel dédiées où le développement est assuré une fois pour
toutes.
1.5. SUIVI D’UN PROJET
Développer un projet nécessite de mener en parallèle 3 activités:
- le développement à proprement dit en procédant étape par étape,
- la vérification du développement,
- la documentation du projet.
La fiche jointe sur la page suivante a été établie comme guide simplifiée utilisable dans le
cas d’un projet qui peut se développer d’une manière linéaire. Pour des projets plus
conséquents, une telle fiche peut aussi servir mais en limitant son rôle à chaque sous-ensemble
à développer.
Les concepteurs et les responsables de projets sont invités à utiliser une telle fiche ou une
variante de celle-ci, de manière à disposer d’une observation sur l’avancement du travail, ceci
pour mieux répondre aux objectifs de coût, de délais et de qualité.
Cette présentation succincte, loin d’être suffisante, n’est donnée ici qu’à titre de rappel et
de guide pour la méthodologie MCSE. Pour des informations plus précises sur la démarche et
pour mieux comprendre les études de cas décrites dans les chapitres suivants, le lecteur est
invité à lire l’ouvrage: "Spécification et Conception des systèmes, une méthodologie MCSE"
de l’auteur.
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 17
ETUDES DE CAS
18 M.C.S.E
M.C.S.E 3
1
PRESENTATION GENERALE
DE LA METHODOLOGIE
Cette première partie rappelle les éléments caractéristiques et la démarche de la
méthodologie MCSE (Méthodologie pour la Conception des Systèmes Electroniques) décrits
dans l’ouvrage "Spécification et conception des systèmes, une Méthodologie MCSE" de
l’auteur [CALVEZ-90]. Ce schéma d’organisation des développements est illustré par toutes
les études de cas qui suivent.
La méthodologie MCSE couvre les phases de Spécification, de Conception Fonctionnelle
aussi appelée par ailleurs Conception Préliminaire, de définition de la Réalisation ou
Conception Détaillée.
Développée spécialement pour les applications temps-réel en contrôle/commande, elle a été
appliquée sur de multiples problèmes industriels. L'adéquation du modèle à la problématique
traitée a ainsi été validée ainsi que l'intérêt de toutes les étapes.
Si cette méthodologie concerne plus particulièrement le domaine des systèmes
électroniques temps-réel, il se trouve que la démarche suivie pour les premières phases du
développement - spécification, conception architecturale - se trouve indépendante de la
réalisation, puisqu'il s'agit d'une approche SYSTEME. Des expériences intéressantes ont été
entreprises quant à son utilisation pour des applications variées : systèmes de contrôle/
commande, réseaux et protocoles, systèmes répartis, outils interactifs, conception de
composants intégrés.
ETUDES DE CAS
4 M.C.S.E
Une large expérimentation de la méthodologie a montré l'importance du modèle, puis
l'importance des règles et conseils qui engendrent chez les concepteurs des solutions de qualité.
Nous avons aussi constaté que les solutions de qualité peuvent s'exprimer sous la forme de
modèles génériques. Ainsi, la connaissance de tels modèles génériques de solutions pour
diverses classes de problèmes facilite la tâche du concepteur et favorise la production de
solutions de qualité au sens : lisibilité, maintenabilité, efficacité ... et donc coût.
En aval de la conception, la phase de définition de la réalisation propose une démarche
systématique qui conduit, à partir d'une solution fonctionnelle, à choisir la technique de
réalisation la plus appropriée pour le problème (type de technologie, répartition matériel/
logiciel, respect des contraintes de temps...).
1.1. DESCRIPTION D’UN SYSTEME
Une méthodologie est un guide pour le développement d’applications. MCSE préconise
une démarche globalement descendante qui conduit à rechercher par approches successives,
une réalisation appropriée.
La décomposition en étapes est basée sur la possibilité de décrire un système selon plusieurs
niveaux d’abstraction. Ainsi une méthodologie se comprend bien lorsque le modèle de
description des systèmes à concevoir est explicité.
Pour résumer la démarche préconisée, la structuration d’un système pour MCSE est décrite
selon un ensemble de niveaux comme l’indique la figure ci-après.
Si on part du niveau le plus abstrait pour descendre jusqu’au niveau de la réalisation, on
trouve:
- le niveau Cahier des charges, qui correspond à l’expression du besoin. Pour ce niveau,
le système n’est pas encore défini. Les informations concernent l’application dans son
ensemble avec les objectifs souhaités.
- le niveau Spécification. Il correspond à la description du système à concevoir selon une
vue purement externe. Les spécifications incluent toutes les contraintes auxquelles doit
satisfaire le système.
- le niveau Description Fonctionnelle, exprimant la structure du système sur le plan
fonctionnel. Cette description interne a la particularité d’être indépendante de toutes les
contraintes technologiques.
- le niveau Description exécutive, qui explicite les spécifications complètes de la
réalisation en décrivant la partie matérielle par une structure d’exécution et la partie
logicielle par des schémas d’implantation logicielle. Entre ce niveau et le précédent 2
sous-niveaux sont intéressants comme intermédiaires:
. le niveau fonctionnel avec les interfaces qui découle du sous-niveau précédent avec
ajout de toutes les interfaces physiques nécessaires pour le couplage avec
l’environnement réel du système.
. le niveau fonctionnel avec répartition qui résulte de la description fonctionnelle en
y ajoutant la contrainte de répartition géographique, ce qui se traduit par l’utilisation
de mécanismes pour le transport des informations entre les sous-ensembles répartis.
- le niveau Réalisation qui décrit la solution finale comme un ensemble de cartes et de
logiciels.
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 5
-Figure 1.1- Niveaux de description d’un système.
Cette décomposition en niveaux permet d’induire assez simplement la démarche à suivre.
En partant du problème posé, chaque étape a pour objectif d’enrichir la description par ajout
d’informations à partir des contraintes à satisfaire.
processeur 2
+ logiciel
processeur 1
+ logiciel
carte 1 carte 2
logiciel 1 logiciel 2
Application
Système
Ve Vi Vs
F1 F2
MVI
E R
Etape 1
Spécification
Etape 2
Conception
fonctionnelle
Etape 3
Partitionnement
Adaptation
Implantation
Etape 4
Réalisation
Description
externe
Description
fonctionnelle
détaillée
exécutive
Description de
la réalisation
Description
Description
fonctionnelle
Niveau spécification
Niveau fonctionnel
Niveau répartition
Niveau interfaces
Niveau exécutif
Niveau réalisation
Cahier des charges
4
3
2"
2’
2
1
0
Modèle de description d’un système Démarche
Allocation
implantation
Description
fonctionnelle
avec répartition
sous-ensemble 1 sous-ensemble 2
Définition de la
réalisation
Allocation
ETUDES DE CAS
6 M.C.S.E
1.2. LA DEMARCHE
La démarche de conception basée sur l'emploi du modèle précédent exprime le processus
de réflexion que doit suivre le concepteur pour aboutir à une description conforme au modèle,
tout en répondant à des critères de qualité : robustesse, modularité, lisibilité, maintenabilité.
Chaque niveau de description sert d'intermédiaire entre 2 étapes consécutives. Le
développement s'effectue selon 4 étapes:
- L'élaboration des spécifications, de manière à exprimer à partir du besoin une vue
purement externe du système (WHAT).
- La conception fonctionnelle, qui a pour objectif de trouver la description fonctionnelle,
composée d’une structure fonctionnelle pour l’organisation interne de la solution et du
comportement de toutes les fonctions nécessaires (HOW).
- La définition de la réalisation (aussi appelée conception détaillée), le but étant de
trouver une structure d'exécution comme support matériel, ainsi qu'une implantation
logicielle sur la structure matérielle retenue, en considérant toutes les contraintes
technologiques: contraintes de répartition, contraintes de temps, contraintes électriques.
- La réalisation conduisant à un système opérationnel.
La figure suivante décrit l'enchaînement des 4 étapes.
-Figure 1.2- Enchaînement des étapes pour MCSE.
Niveau 1
Niveau 2
Niveau 3
Niveau 4
Abstrait
Concret
PRODUIT
Temps
DEFINITION
de la
REALISATION
REALISATION
Spécifications
Description fonctionnelle
Description exécutive
Modèles
Spécification
Modèle
fonctionnel
Modèle
d’exécution
Spécifications
Spécifications
fonctionnelles
et opératoires
CHARGES
CAHIER
DES
technologiques
CONCEPTION
FONCTIONNELLE
Spécifications technologiques de réalisation
SPECIFICATION
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 7
Pour chaque étape, le concepteur dispose en entrée : de la description d'un niveau
intermédiaire comme résultat de l'étape précédente, de renseignements complémentaires que
sont les contraintes imposées dans les spécifications. L'étape produit une description du niveau
suivant conforme au modèle pour l’étape. Une vérification de conformité est possible à l'issue
de chaque étape.
Dans les paragraphes suivants et sans entrer dans les détails, nous passons en revue les
différentes étapes de la méthodologie en précisant les principes.
1.2.1. Elaboration des spécifications
Pour pouvoir concevoir, il faut tout d'abord disposer des spécifications. Par spécifications,
il faut entendre une description complète mais purement externe du système à concevoir. Plus
ces spécifications sont détaillées et conformes à des modèles formels, plus il est facile de
déduire une solution. Mais cette spécification doit aussi être vérifiable, en particulier par le
demandeur.
Le point de départ est le cahier des charges décrivant le besoin du demandeur. Pour décrire
ce que doit faire un système, celui-ci est considéré comme observant et agissant sur les objets
de son environnement. Il faut donc tout d'abord connaître cet environnement. Le connaître,
c'est dans un premier temps modéliser les objets, et dans un second temps, expliciter les
relations entre eux sous la forme d'une description fonctionnelle.
Ensuite, expliciter le rôle du système et donc exprimer ses spécifications consiste à énoncer
et à caractériser les fonctions demandées. Ceci se fait en détaillant le comportement souhaité
des objets de l'environnement sous le contrôle du système, ainsi que toutes les contraintes
imposées.
Par cette approche, la méthodologie fait apparaître une similitude de raisonnement entre la
démarche pour obtenir les spécifications et celle pour concevoir. L'analyse de l'environnement
conduit à une synthèse de la réalité sous la forme d’un modèle, et l'introduction des objectifs à
atteindre conduit à un enrichissement de la modélisation précédente en considérant en
supplément l'apport du système.
Cette étape permet d'obtenir 3 types de spécifications:
- les spécifications fonctionnelles: elles comprennent la liste des fonctions du système
pour l'application (fonctions externes) et la description du comportement du système et
de l'environnement pour ces fonctions.
- les spécifications opératoires, qui concernent le comportement, les performances,
précisions, les méthodes à utiliser ...
- les spécifications technologiques, qui incluent : les contraintes de temps et de
répartition, les caractéristiques des interfaces physiques, les contraintes de réalisation.
Les spécifications fonctionnelles et opératoires sont utilisées durant l'étape de conception
fonctionnelle, tandis que les spécifications technologiques ne servent que pour les étapes de
définition de la réalisation et de réalisation.
ETUDES DE CAS
8 M.C.S.E
Les phases pour cette étape sont décrites par la figure ci-après.
-Figure 1.3- Déroulement pour l'étape de spécification.
1.2.2. Conception fonctionnelle
La solution pour cette étape se déduit d'une analyse des spécifications fonctionnelles. Elle
doit être conforme au modèle fonctionnel.
La recherche de la structure fonctionnelle se fait tout d'abord à partir de la délimitation du
système avec ses entrées et ses sorties. Il s'agit ensuite de trouver une première décomposition
fonctionnelle. Cette première approche est importante car elle induit la qualité ou la non-qualité
pour le reste du développement.
La démarche consiste ensuite à rechercher par raffinements successifs et pour chaque
fonction à concevoir, les variables et événements internes caractéristiques nécessaires et si
possible suffisants. Se déduisent alors les fonctions qui exploitent et assurent la mise à jour de
ces variables ainsi que le comportement de chaque fonction. Le raffinement est poursuivi
jusqu'à l'obtention de fonctions élémentaires qui peuvent s'exprimer par une description
purement séquentielle.
L'expérience nous a montré que cette approche basée sur les données conduit à des
structures fonctionnelles simples (réduction des couplages exprimant des relations d'ordre) et
plus structurées que l'approche basée sur les fonctions, qui conduit à exprimer la structure
comme décrivant un enchaînement de transformations.
Analyse
environnement
Comportement
des
entités
Description
fonctionnelle
Délimitation
des
entrées/sorties
Comportement
entités
+ système
Spécifications
opératoires
Spécifications
technologiques
Modélisation
de
l’environnement
Elaboration
des
spécifications
CAHIER
DES
CHA
R
GES
Spécifications fonctionnelles
Fonctions
SPECIFICATIONS
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 9
La figure ci-dessous décrit la procédure à suivre.
-Figure 1.4- Les phases pour l'étape de Conception fonctionnelle.
1.2.3. Définition de la réalisation
La troisième étape consiste à rechercher, d'une part le support exécutif, d'autre part la
manière d'y implanter les fonctions réalisées par logiciel.
Tout d'abord, la description fonctionnelle doit être affinée, détaillée, enrichie pour tenir
compte des contraintes technologiques que sont: la répartition géographique (si nécessaire), les
interfaces physiques, les interfaces utilisateur.
Les contraintes de temps sont ensuite analysées pour déduire la répartition matériel/logiciel.
La partie matérielle est spécifiée par une structure d'exécution. L'intégration ou allocation
décrit complètement l'implantation de la description fonctionnelle sur la structure d'exécution.
Chaque sous-ensemble fonctionnel à réaliser par logiciel est décrit par un schéma
d'implantation logicielle qui exprime la priorité de chaque tâche, et les relations de dépendance
spatiale (par des données) ou temporelles. Cette implantation résulte de l'utilisation de règles
qui permettent d'effectuer des transformations tenant compte du support matériel.
L'enchainement des phases pour cette étape est représenté par la figure 1.5 ci-après.
Délimitation des
entrées sorties
première décomposition
fonctionnelle
Fonctions
Première approche fonctionnelle
Raffinement
Synthèse
fonctionnel
Raffinement
Description
algorithmique
Document de
conception
fonctionnelle
Structure fonctionnelle finale
Document
de
spécifications
ETUDES DE CAS
10 M.C.S.E
-Figure 1.5- Les phases pour l'étape de définition de la réalisation.
1.2.4. Réalisation
Les 2 parties - support matériel, implantation du logiciel - favorisent le travail de réalisation
d'un prototype, l'intégration et le test.
Il faut être conscient à ce stade de la variété des stratégies de réalisation qui dépendent d'au
moins 3 facteurs : les spécifications en entrée, les techniques à mettre en oeuvre, les outils et
méthodes disponibles.
La réalisation est une démarche ascendante puisqu’elle consiste à assembler. Il s'agit de
développer partie par partie la solution en faisant apparaître des fonctionnalités de plus en plus
abstraites pour se rapprocher de l'objectif. Chaque niveau de la construction est validé par une
vérification de la conformité aux spécifications du niveau correspondant de la démarche
descendante. Réalisation matérielle et réalisation du logiciel peuvent se développer
simultanément, ce qui permet de réduire le temps de la réalisation et de faire intervenir
conjointement des spécialistes des 2 domaines.
Pour achever la réalisation, l'intégration et le test ont pour objectif de réunir toutes les
parties des développements de manière à fournir un système opérationnel conforme aux
souhaits du demandeur.
Cette démarche pour la réalisation est représentée ci-après.
Introduction de
la répartition
Introduction des
interfaces
Solution fonctionnelle détaillée
contraintes de temps allocation
implantation
structure
d’exécution
Spécification des
implantations
logicielles
Spécification de
la réalisation
matérielle
Solution fonctionnelle + spécifications technologiques
Détermination de la
structure d’exécution
Document
pour la
réalisation
contraintes
électriques
contraintes de développement
contraintes de
répartition
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 11
-Figure 1.6- Démarche pour la réalisation.
1.3. CARACTERISTIQUES DE MCSE
MCSE est une démarche complète qui permet de passer du problème à une réalisation.
Nous reprenons ici les aspects généraux essentiels de la méthodologie.
-A- UN MODELE DE DESCRIPTION COMME BASE
Toute méthodologie est basée sur un ou des modèles, ceci permet une décomposition en
étapes. MCSE est basée sur un modèle de description interne en 3 composantes. Ce modèle
incite à décrire tout système selon une hiérarchie de niveaux de description. Chaque niveau sert
d'intermédiaire entre 2 étapes. La plupart des modèles sont graphiques, favorisant ainsi une
compréhension globale et rapide.
-B- UNE DEMARCHE GLOBALEMENT DESCENDANTE POUR LA CONCEPTION
Chaque étape de la méthodologie permet de passer d'un niveau de description au niveau
plus détaillé suivant en enrichissant la solution d'une composante supplémentaire.
La progression est donc globalement descendante puisqu'elle part du problème posé jusqu'à
aboutir à une réalisation opérationnelle.
SPECIFICATION DE REALISATION
Structure d’exécution Allocation Implantation logicielle
VERIFICATION DES SPECIFICATIONS
Schéma de
réalisation
Implantation
et réalisation
Test composants
et cartes
Ecritures : tâches
modules
procédures
Compilation
chargement
Test du
logiciel
Dialogue
Réalisation matérielle Réalisation logicielle
INTEGRATION et TESTS
produit opérationnel
Outils Outils
Instrumentation
Système
de
développement
ETUDES DE CAS
12 M.C.S.E
-C- UNE PROGRESSION ITERATIVE
Un développement ne peut pas se faire sans erreurs ou omissions. Des corrections sont
toujours nécessaires. Basée sur la correction par retours-arrières, une phase de vérification en
fin de chaque étape permet la détection des erreurs et induit un travail itératif avec des retours
à l'intérieur de l'étape ou sur les étapes précédentes.
-D- UNE METHODE SPECIFIQUE POUR CHAQUE ETAPE
Le modèle de description de la solution à l'issue de chaque étape n'est pas suffisant (le
QUOI). Le concepteur doit disposer pour chaque étape d'un guide précis lui expliquant
COMMENT passer de la spécification en entrée à une solution possédant des qualités. Ce guide
est la méthode à suivre : technique d'analyse, séquence des décisions, critères de choix. Par
opposition à une recherche intuitive, l'emploi d'une méthode garantit l'obtention rapide d'une
solution a priori de qualité.
Au-delà de l'aspect méthode, l'idée des modèles génériques de solutions a un intérêt certain.
De tels modèles ayant la particularité pour la décomposition fonctionnelle d’être générateurs
de multiples solutions, sont retenus car possédant des qualités intrinsèques: lisibilité,
maintenabilité, simplicité, adéquation au modèle global MCSE. La connaissance de tels
modèles, en complément des méthodes, améliore notablement le pourcentage des
développements corrects.
-E- UNE DEMARCHE GLOBALEMENT ASCENDANTE POUR LA REALISATION
L'assemblage n'est possible qu'après disponibilité des constituants. Ainsi, la réalisation
débute par la réalisation des plus petits sous-ensembles, puis remonte progressivement par
assemblage et intégration de fonctions plus globales. Le travail de réalisation est représentable
par un triangle juxtaposé à celui de la conception comme l’indique la figure suivante. La
largeur du triangle pour chaque stade indique la quantité d'informations à maîtriser.
-Figure 1.7- Forme en double triangle pour le développement.
BESOIN PRODUIT
SPECIFICATION
CONCEPTION
FONCTIONNELLE
DEFINITION
REALISATION
MATERIELLE LOGICIELLE
RECETTE
CERTIFICATION
TEST
VALIDATION
INTEGRATION
REALISATION
MATERIELLE
REALISATION
LOGICIELLE
DE LA
VERIFICATION
TEST
Spécification
conception
Validation
Réalisation
CONFORMITE
VALIDATION
PARTIE PARTIE
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 13
Chaque niveau de la réalisation est vérifiable, ce qui assure sa conformité au niveau
correspondant de la conception. La figure 1.7 illustre la correspondance entre les 2 démarches
complémentaires.
-F- UN MODELE DE CYCLE DE DEVELOPPEMENT HIERARCHIQUE
Pour un système relativement complexe, le modèle ci-dessus en double triangle n'est pas
suffisamment précis.
L'étape de définition de la réalisation conduit à mettre en évidence les 2 parties : matériel,
logiciel. Chaque partie est à nouveau à développer selon une démarche en 3 phases :
spécification, conception, définition de la réalisation, et ceci jusqu'à la mise en évidence des
constituants disponibles (composants matériels ou logiciels).
Ainsi comme le montre la figure ci-après, le modèle de cycle de développement est un
emboîtement de développements. Au premier niveau, la conception est générale et concerne
l'application dans son ensemble. Au fur et à mesure du raffinement de la solution, les
développements concernent des problèmes plus spécifiques en rapport avec la réalisation :
développement d'un composant, d'une fonction spécifique, d'un module logiciel ...
-Figure 1.8- Modèle hiérarchique pour le développement.
-G- GUIDE POUR LA DOCUMENTATION
Le modèle de description induit directement la structure des documents à produire durant
le développement. Chaque document est le résultat d'une étape, et sert comme informations
pour l'étape suivante.
SYSTEME
SOUS-ENSEMBLE
MATERIEL LOGICIEL
CARTE , COMPOSANT TACHE , MODULE
MCSE
Spécification conception
fonctionnelle
définition réalisation
Sous-
Assemblage
Test
Validation
Spécification
Spécifi-
Spécifi-
Spécifi-
Spécificonception
fonctionnelle
conception
conception
conception
fonctionconception
préliminaire
définition réalisation Intégration
Test
Définition
Réalisation
Définition
Réalisation
comp. i
carte i
Tache i
Module i
Matériel Logiciel
Assem-
Test
Test
détaillée unitaire
conception
Réalisation
Assem-
Test
Domaine de
Cahier
des charges
Problème Produit
ensemble i
cation
blage
cation
nelle
blage
cation cation
Etude
préliminaire
ETUDES DE CAS
14 M.C.S.E
Ainsi, en respectant la démarche par étapes successives, la documentation est générée au
fur et à mesure du développement et non en final. Elle possède alors une réelle qualité quant à
la forme et au fond puisqu'elle relate, en plus de la solution, la démarche suivie et
l'argumentation qui justifie les décisions importantes.
Produite de cette manière, la documentation est utilisable durant le cycle de
développement: pour les phases de vérification selon un cycle auteur-lecteurs, pour
l'observation de l'état d'avancement, mais aussi pour les étapes ultérieures et en particulier pour
la maintenance.
-H- GUIDE POUR LA CONDUITE DE PROJET
Le modèle de cycle de développement est utilisable pour la mise en place d'une procédure
de conduite d'un ensemble de projets. Pour chaque projet, cette activité concerne :
- le management : planification, organisation, direction, contrôle et suivi du projet,
- l'obtention de la conformité : planification des tests, nature des tests techniques à
utiliser, les résultats, conformité et certification,
- la gestion de la documentation : spécification des documents, planification des revues,
méthodes de gestion, mises à jour ...
- la gestion de la maintenance : domaine et procédures de maintenance, solutions et
outils, planification,
- la gestion de la qualité : assurance qualité, méthode pour l'obtention de la qualité,
procédures de contrôle.
-I- UNE METHODOLOGIE OUVERTE ET COMPLEMENTAIRE
MCSE ne se trouve pas restreinte à une méthode particulière et à un domaine bien
spécifique. Au contraire, pour chaque étape, plusieurs méthodes sont utilisables et c'est au
concepteur de choisir selon des critères, celle qui lui permet de résoudre au mieux son
problème.
Développée au départ pour les systèmes de contrôle/commande temps-réel à
microprocesseurs, l'expérience nous a montré son adéquation pour une large classe
d'application et de techniques, et tout particulièrement pour les applications qui utilisent
l'électronique et l'informatique. MCSE n'est pas à opposer aux autres méthodologies, bien au
contraire, elle se veut complémentaire. La plupart des modèles proposés par différents auteurs
s'avèrent utilisables. Par exemple, SADT et les méthodes de spécification de WARD et
MELLOR et de HATLEY favorisent la tâche d'analyse du problème. La méthodologie de
JACKSON est dans l'esprit relativement proche de MCSE. Les méthodologies DARTS et
SDWMC de BUHR ont aussi des points communs.
1.4. CONSEILS POUR UNE UTILISATION RATIONNELLE DE MCSE
Nous rappelons ici les principes essentiels de la Méthodologie qu'il est conseillé de suivre
pour obtenir les meilleurs résultats. Ces principes répondent à des difficultés couramment
rencontrées par les concepteurs.
Au préalable, il est bon de rappeler que le développement est une activité humaine mettant
en jeu une méthodologie et un système social. Les 2 parties ont une importance pour la réussite.
Aussi, l'attitude volontariste des concepteurs est une première condition strictement nécessaire
pour le succès de la démarche.
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 15
Ensuite, un bon concepteur doit savoir se placer au dessus des aspects techniques et ceci en
utilisant le plus possible des concepts. Il ne doit pas se laisser guider par une solution a priori;
dans ce cas problablement, il aboutira à la conclusion qu’elle est correcte sans avoir évaluer
d’autres alternatives. Il est aussi essentiel de chercher à satisfaire la demande et non pas se
satisfaire de son développement.
Nous citons ci-dessous pour chaque étape, quelques-unes des difficultés que tout utilisateur
de la méthodologie risque de rencontrer et le point de vue à adopter.
-A- ETAPE DE SPECIFICATION
Concernant l’étape de spécification, il y a 2 difficultés. Tout d'abord pour la modélisation
de l'environnement, il faut décider du modèle le plus approprié pour cet environnement, à la
fois sa nature et son niveau de détail. Pour être bonne, l'analyse doit se faire sur un plan
fonctionnel et non matériel. Il faut donc penser aux entités fonctionnelles. Ceci est une
difficulté qui conduit à des erreurs fréquentes. De l'analyse se déduit la nature du modèle qu'il
faut rechercher dans l'ordre de complexité: modèle statique données/évènements, modèle
dynamique global, modèle des activités. La modélisation est à faire selon un niveau de détails
nécessaire mais juste suffisant pour résoudre le problème. Elle ne doit pas faire intervenir le
système à concevoir.
Ensuite, pour l'élaboration des spécifications fonctionnelles, celles-ci doivent se limiter à
une description externe du système. Les fonctions du système ne doivent être que des fonctions
de l'application, qu'il ne faut surtout pas confondre avec les fonctions internes du système.
S’assurer de la complétude d’une spécification est aussi une réelle difficulté. Celle-ci doit
apparaitre cohérente, claire et doit être vérifiée par le demandeur.
-B- ETAPE DE CONCEPTION
Pour cette étape, le premier point important est de faire une conception indépendante de la
technologie. La première difficulté est donc de faire abstraction des contraintes technologiques
et donc de toute idée de réalisation. Pour cela, il faut éliminer tous les problèmes de répartition
géographique et d'interfaces pour se consacrer au seul aspect fonctionnel. Il faut donc déjà
partir des entrées et sorties fonctionnelles et non pas physiques.
Ensuite, la recherche d'une solution est à faire sur la base des variables internes nécessaires
et non pas sur la base des fonctions internes, alors que la tendance naturelle consiste à
appréhender le problème par les fonctions. L'approche préconisée conduit à une solution plus
simple à comprendre et plus simple à implanter. Les idées de solutions peuvent aussi se déduire
de modèles génériques de solution. L'intérêt est de disposer d'un guide pour la recherche de
variables.
D'une manière générale, le concepteur doit avoir des idées pour être créatif mais doit faire
abstraction de son idée a priori, sinon il conduira son développement sur la base de cette idée
inhibant alors l’évaluation de toute autre solution peut-être meilleure.
C- ETAPE DE DEFINITION DE LA REALISATION
Une des tendances naturelles consiste à entreprendre la réalisation rapidement:
développement ou choix du matériel très tôt et écriture du logiciel. L’étape de définition de la
réalisation est une étape de réflexion importante qui conduit à réduire l’effort de
développement pour en particulier la réalisation. Cette étape permet de s'adapter aux
ETUDES DE CAS
16 M.C.S.E
caractéristiques de l'environnement, en introduisant les interfaces. Pour cela, il faut rechercher
la solution la plus appropriée, c'est particulièrement le cas pour l'interface homme-machine.
D’autre part, les contraintes de temps doivent être évaluées correctement pour le cas le plus
défavorable de manière à pouvoir prouver a priori le bon fonctionnement de l'application.
De cette analyse découle ensuite la recherche de la répartition matériel/logiciel qui a pour
objectif de réduire au maximum le développement. La démarche conduit à minimiser le
matériel, puis le logiciel. Concernant le logiciel, il est composé de 2 parties: la partie opératoire
strictement nécessaire pour le fonctionnement et donc relativement incompressible si la
spécification comportementale a été bien élaborée, et la partie dite organisationnelle qui
concerne les relations entre les fonctions. Cette deuxième partie est compressible, et l'objectif
des transformations pour obtenir le schéma d'implantation logicielle est de réduire au
maximum cette partie. La Méthodologie favorise cette réduction. Cette approche est tout à fait
justifiée pour les applications temps-réel dédiées où le développement est assuré une fois pour
toutes.
1.5. SUIVI D’UN PROJET
Développer un projet nécessite de mener en parallèle 3 activités:
- le développement à proprement dit en procédant étape par étape,
- la vérification du développement,
- la documentation du projet.
La fiche jointe sur la page suivante a été établie comme guide simplifiée utilisable dans le
cas d’un projet qui peut se développer d’une manière linéaire. Pour des projets plus
conséquents, une telle fiche peut aussi servir mais en limitant son rôle à chaque sous-ensemble
à développer.
Les concepteurs et les responsables de projets sont invités à utiliser une telle fiche ou une
variante de celle-ci, de manière à disposer d’une observation sur l’avancement du travail, ceci
pour mieux répondre aux objectifs de coût, de délais et de qualité.
Cette présentation succincte, loin d’être suffisante, n’est donnée ici qu’à titre de rappel et
de guide pour la méthodologie MCSE. Pour des informations plus précises sur la démarche et
pour mieux comprendre les études de cas décrites dans les chapitres suivants, le lecteur est
invité à lire l’ouvrage: "Spécification et Conception des systèmes, une méthodologie MCSE"
de l’auteur.
1 - PRESENTATION GENERALE DE LA METHODOLOGIE
M.C.S.E 17
ETUDES DE CAS
18 M.C.S.E
HES-SO//HEIA-FR Page 1 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
M
ÉTHODOLOGIE DE CONCEPTION DE SYSTÈMES ELECTRONIQUES
R
ÉSUMÉ
COURS INDUSTRIALISATION DE SYSTÈMES
PARTIE I
DOMINIQUE RHÊME, HEIA-FR
© Dominique Rhême, 2003-2014, EIA-FR, Fribourg
MCSE
HES-SO//HEIA-FR Page 2 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
D
ÉFINITIONS
•Un système électronique est un produit dont l’objectif est de répondre à un besoin industriel.
•La conception est un processus, une suite d’étapes:
>les spécifications,
>la conception proprement dite,
>la réalisation,
>le test et la validation.
•La spécification et la conception sont des processus descendants (top-down Design), alors que la réalisation et le test est une démarche ascendante (bottom-up).
•La méthodologie est l’application d’une démarche.
Le but de cet exposé est d'expliquer les principales notions de la méthodologie d’un développement de circuit ou d’un système électronique. Il ne faut pas perdre de vue l'objectif de la méthode: parvenir, en une suite d'étapes précises, à développer un produit qui satisfait pleinement au cahier des charges, c-à-d. au besoin. C'est ainsi que l'on peut garantir, au sens large, la qualité du produit.
Les pages qui suivent consistent principalement en un résumé d'une méthodologie assez représentative de ce qui est possible d'étudier dans ce domaine: MCSE = Méthodologie de Conception de Systèmes Electroniques [1]. Toutefois, quelques compléments ou quelques éclairages ont leur source dans les autres références bibliographiques.
Cette méthodologie, comme toutes les autres, montre bien les avantages d'une démarche de conception descendante (top-down design). Il faut d'abord traiter les aspects généraux avant les aspects particuliers, les concepts avant les techniques.
MCSE
HES-SO//HEIA-FR Page 3 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
LA DÉMARCHE DE CONCEPTION
RéalisationValidationConceptionSpécificationTESTVERIFICATIONVALIDATIONCONFORMITEPRODUITBESOINRECETTECERTIFICATIONTESTVALIDATIONINTEGRATIONREALISATIONLOGICIELLEREALISATIONMATERIELLEPARTIELOGICIELLEPARTIEMATERIELLEDEFINITIONDE LA REALISATIONSPECI-FICATIONCONCEPTIONFONCTIONNELLE
FIGURE 1. Du besoin au produit, figure reprise de [1]
Les étapes principales décrites dans cette méthodologie sont les suivantes:
•le cahier des charges
•les spécifications
•la conception fonctionnelle
•la conception de détail ou la définition de la réalisation
•la réalisation
•le test et la validation.
Chacun de ces points est brièvement développé ci-après.
MCSE
HES-SO//HEIA-FR Page 4 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
ETAPE 1: LE CAHIER DES CHARGES
•Le cahier des charges est l’expression du BESOIN.
•C’est un document !
•Il exprime les souhaits du demandeur et va donc répondre à la question du "POURQUOI ?" (WHY).
•Le cahier des charges est le premier interface entre le commanditaire (le demandeur, le client) et le concepteur (le réalisateur).
Le cahier des charges est écrit par le demandeur. (Dans un projet d’étudiant, le cahier des charges correspond en principe à la donnée du projet). La qualité d'un premier cahier des charges est a priori plutôt mauvaise et/ou incomplète. Dans la mesure où le demandeur aborde sérieusement la rédaction du cahier des charges, il devra:
•recueillir toutes les informations pertinentes sur le produit envisagé,
•effectuer une analyse systématique des besoins,
•définir les critères d'appréciation du résultat.
Souvent, les premières considérations à prendre en compte ne sont pas de nature technique. C’est plutôt de savoir “qui est à l’origine du projet?”, “comment se fait-il que cette demande aboutit ici?” ou encore “pour qui vais-je travailler?”. Toutes ces questions montrent que le cadre dans lequel un projet se réalise a beaucoup d’importance.
Les contraintes économiques ou juridiques sont trop souvent sous-estimées. Qu’en est-il des brevets, des réglementations, des normes ou des certifications nécessaires?
MCSE
HES-SO//HEIA-FR Page 5 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
DIALOGUE DEMANDEUR - CONCEPTEUR
•Le concepteur est l'ingénieur qui va concevoir le produit demandé.
•Par un DIALOGUE approfondi avec le demandeur, le concepteur devra comprendre:
>Quelles sont les motivations du développement ? (But, «qualité» attendue, marché, etc.)
>Quels seront les utilisateurs du système ?
>A quel contexte doit se raccorder le système ? (interfaces..)
>Quelles fonctions doit-il réaliser ?
>Quelles sont les contraintes matérielles, économiques, juridiques, temporelles ?
>Quelle doit être la forme finale du produit: prototype de laboratoire, prototype industrialisable, design, etc. ?
Un besoin n'est jamais clairement et complètement défini. Une collaboration importante entre le demandeur et le concepteur est dès lors nécessaire.
Le document appelé cahier des charges, s'il est suffisamment explicite, peut servir pour un appel d'offre. Le cahier des charges assorti de propositions de développement doit permettre de décider de l'avenir du produit. Si une réalisation est souhaitée, ces documents seront à la base d'un contrat de développement.
Savoir rédiger correctement un cahier des charges est le fruit d'une longue expérience qui s'acquière progressivement, de projets en projets. L'apprentissage est d'autant plus efficace si le concepteur a pu prendre quelquefois la responsabilité de toutes les phases d'un projet: cahier des charges, spécifications, développement, réalisation, tests, production.
MCSE
HES-SO//HEIA-FR Page 6 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
ETAPE 2: LES SPECIFICATIONS
•La spécification est une VUE purement EXTERNE du système demandé.
•C’est un document.
• Il répond donc à la question "QUOI ?" (WHAT).
•L’ingénieur concepteur est chargé du travail de spécification. C’est lui qui écrit ce document.
Ecrire le document de spécification est la première phase du travail de conception. Le concepteur est chargé de rédiger ce document. A cette fin, il devrait se poser les questions préalables suivantes:
•A quelles questions ce document doit-il vraiment répondre ?
•Qui en seront les lecteurs ?
•Comment vont-ils utiliser le document ?
•Quelles sont les connaissances nécessaires pour lire et comprendre le document ?
Parfois le demandeur peut imposer une partie de la solution, non pas parce qu’elle est la meilleure, mais parce qu’elle lui convient !
MCSE
HES-SO//HEIA-FR Page 7 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
STRUCTURE CONSEILLÉE DU DOCUMENT
•1.Présentation du problème
•2.Caractéristique de l'environnement
•3.Description des entrées-sorties
•4.Spéc. fonctionnelles (= description des fonctions)
•5.Spéc. opératoires (= déroulement des opérations)
•6.Spéc. technologiques (= contraintes et limitations)
•7.Informations complémentaires, en particulier la description du test final
Il est conseillé de structurer le document de spécification de la manière présentée ci-dessus.
•Présentation du problème: reprise du cahier des charges, analyse succincte, définition de la terminologie.
•Caractéristiques et modélisation de l'environnement du produit à réaliser : description de toutes les entités utilisées, et de toutes les connexions entre elles et le système à développer.
•Description des entrées-sorties: nature des informations et de tous les signaux, avec leur codage, nature des protocoles si nécessaire, etc.
•Spécifications fonctionnelles (= description des fonctions du système). La vue fonctionnelle doit bien définir toutes les transformations prévues sur les informations.
•Spécifications opératoires (= déroulement des opérations, précision...).
•Spécifications technologiques (= contraintes et limitations du système, consommation).
•Informations complémentaires, en particulier la description de la procédure du test final ou de validation par le client. Pourquoi pas le mode d’emploi? S’il y a lieu, faire référence à aux brevets, aux normes, etc.
MCSE
HES-SO//HEIA-FR Page 8 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
QUALITÉ DU DOCUMENT
•Un document de spécifications doit être:
>correct
>complet
>cohérent
>compréhensible
>vérifiable
>exploitable
>rédigeable et modifiable!
Les critères d'évaluation d'un document de spécifications peuvent être résumés par les qualificatifs suivants:
•correct (refléter les besoins effectifs du demandeur et non les envies du concepteur)
•complet (réunir toutes les caractéristiques et contraintes sans laisser des points “sous le tapis”)
•cohérent (pas de contradictions à l’intérieur du document, attention à ne pas placer la même information à plusieurs endroits dans le document)
•compréhensible (structuré et compréhensible pour le client demandeur ou le lecteur)
•vérifiable (tout est justifié, en évitant les affirmations qualitatives du type: la vitesse sera assez élevée...)
•exploitable (utilisable pour le futur développement et la réalisation)
•rédigeable et modifiable! (hélas, rien n’est jamais définitif, il faut donc s’attendre à devoir le modifier un jour.)
MCSE
HES-SO//HEIA-FR Page 9 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
IMPORTANCE DU DOCUMENT
ProduitBesoinTravail de...SpécificationDéveloppementValidationValidationDocument...cdcDocument"contractuel"
FIGURE 2. Rôle central du document de spécification d'un produit.
Le document de spécification est probablement le document le plus important dans les relations demandeur - concepteur. De son côté, le demandeur validera le document de spécifications par rapport à ses besoins. De l'autre, le développeur évaluera son produit selon les spécifications. Donc, ce document doit être approuvé et il a une valeur contractuelle, formelle ou non, entre les deux parties. (voir FIGURE 2.)
MCSE
HES-SO//HEIA-FR Page 10 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
ETAPE 3: LA CONCEPTION FONCTIONNELLE
•Le document conception fonctionnelle est la première véritable vue interne du système demandé.
•Il est réalisé sur les éléments qui ressortent des spécifications fonctionnelles.
•Dans cette partie du travail, il est répondu à la question "COMMENT ?"(HOW)
•Il est nécessaire de procéder à une décomposition des blocs fonctionnels en sous-ensemble (raffinement).
Le document de conception fonctionnelle s'appuie sur les éléments qui ressortent des spécifications fonctionnelles. Dans cette partie du travail, il est répondu à la question "COMMENT ?"(HOW). C’est donc la première véritable vue interne du système demandé.
A partir de la délimitation des entrées-sorties, l'objectif est de décomposer le projet en sous-blocs qui seront peu à peu affinés.
Le raffinement est poursuivi jusqu'à l'obtention de fonctions élémentaires qui peuvent s'exprimer par une description purement séquentielle (un algorithme).
La fin de cette étape est marquée par la publication d'un document de conception fonctionnelle, qui doit être validé par rapport au document de spécifications et qui servira lui-même de base pour l'étape suivante.
MCSE
HES-SO//HEIA-FR Page 11 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
ETAPE 4: LA DEFINITION DE LA
REALISATION
•A la fin de la décomposition, toutes les fonctions sont définie dans le détail.
•C’est aussi la décision définitive des répartitions:
>Répartition géographique, éloignement, liaisons...
>Répartition logiciel / matériel selon les vitesses de traitements souhaitées.
•C’est aussi la prise en compte de toutes les contraintes de toutes natures.
•Cette étape se termine par la réalisation du document de réalisation dans lequel on trouvera toutes les descriptions des circuits et des programmes.
La définition de la réalisation est l'étape ultime de la conception proprement dite. Toutes les fonctions sont définie dans le détail. Dans cette étape a lieu le découpage entre les fonctions logicielles et matérielles (software et hardware = CODESIGN []).
C'est ici qu'interviennent les contraintes technologiques, les contraintes d’autonomie, les contraintes géographiques, les contraintes d'interface, les contraintes de temps, etc. En général, la répartition logiciel/matériel découle des contraintes de temps d'exécution d'une fonction.
Cette étape se termine par la réalisation du document de réalisation dans lequel on trouvera toutes les descriptions des circuits et des programmes.
MCSE
HES-SO//HEIA-FR Page 12 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
ETAPE 5: LA REALISATION
•Par réalisation, on comprend construction et programmation hardware aussi bien que software.
•On réalise de petits blocs qui sont testés pour assemblés entre eux.
•C’est une démarche bottom - up.
La réalisation de la partie logicielle et matérielle dépend beaucoup du contexte, des techniques à mettre en oeuvre et des technologies utilisées.
Cependant, il faut être conscient que la réalisation est par principe une démarche ascendante (bottom-up), puisque qu'elle consiste à assembler les éléments de base entre eux, pour former ainsi de suite le système complet.
MCSE
HES-SO//HEIA-FR Page 13 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
ETAPE 6: LA VALIDATION
•Toutes les méthodologies existantes insistent sur le fait de tester et valider à chaque phase de production du système.
•La stratégie de test doit être définie dès le début, dans la phase de spécification déjà.
•Les simulations effectuées durant le développement forment un bon point de comparaison pour les tests.
•Les tests aussi méritent une bonne documentation !
A chaque étape de la réalisation, il y a lieu de vérifier si le comportement du circuit est conforme à celui qui a été prévu dans le développement (en particulier, aux simulations).
Finalement, lorsque l’appareil est complètement assemblé, la validation consiste à exécuter point par point le protocole d’essai prévu dans le document de spécifications.
A ce stade, le système est terminé, ainsi que sa documentation. Si tout s’est bien passé, le client est satisfait...
MCSE
HES-SO//HEIA-FR Page 14 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
LA MODELISATION
•La modélisation est l’opération souvent délicate qui consiste à représenter une réalité physique complexe par des mécanismes plutôt simples.
•Modéliser, c’est avant tout décrire!
•Il est souvent impossible de modéliser un système avec un seul point de vue. Deux ou trois vues sont nécessaires pour la description d'une entité:
>Modélisation des données/informations (quoi)
>Modélisation des activités (comment)
>Modélisation du comportement (quand)
Une bonne modélisation s’appuie toujours sur un solide modèle de l’environnement (appelé parfois diagramme de contexte). Exemple:
Gestion éclairageHorloge18kHzModule HTBIN2TRIGfonction principalezero_synctrig_outclk_18kHzclk_8Hzlight_enablelight_inGestion touchesclk_35Hz
MCSE
HES-SO//HEIA-FR Page 15 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
MODÉLISATION DES DONNÉES / INFORMATIONS (QUOI)
•Définir de façon complète et précise la nature des données et la structure des données.
•S’attacher à la signification et non à l’implantation.
>WARD-1985 relève qu’il faut, pour caractériser une donnée, expliciter la signification, la composition et le type.
•Cette modélisation est primordiale et ne doit en aucun cas être négligée.
•C’est exclusivement une modélisation structurelle et correspond bien à la notion “orienté objet”.
Modélisation des données/informations (quoi).
Comme type de données possibles, on distingue :
•les relations de synchronisation (ex : un événement)
•les relations par partage de variable ( ex. : une variable d’état)
•les relations de transfert d’information ( ex. : un message)
Pour les références bibliographiques, voir les ouvrages de JACKSON, WARD, DEMARCO, HARTLEY pour une modélisation hiérarchique; CHEN pour une modélisation entités/relations
La description "orienté objet" est un exemple actuel de modélisation de données. (ex. C++)
MCSE
HES-SO//HEIA-FR Page 16 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
MODÉLISATION DES ACTIVITÉS (COMMENT)
•Décrire les activités de l’entité et les relations avec son environnement.
•Un activité désigne une transformation de donnée ou d’information en entrée en d’autres données ou informations en sorties.
•C’est aussi une modélisation structurelle.
Modélisation des activités (comment)
C’est une vue matérielle. C’est une description exécutive, qui décompose la fonction en terme de processus, de mémoires de données, de noeuds de communication.
Le diagramme FLOT DE DONNEES (DEMARCO + WARD&MELLOR) fait partie des possibilités.
MCSE
HES-SO//HEIA-FR Page 17 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
MODÉLISATION DU COMPORTEMENT (QUAND)
•Déterminer les instants d’apparitions des événements ou des informations en entrée qui vont faire évoluer le comportement du système et le faire changer d’état.
•Un graphe du type état/transition est souvent un modèle adéquat (FSM en particulier).
•C’est une vue importante pour la spécification d’un système contrôle/commande temps-réel.
•Convient aussi pour traduire un comportement stimuli/réponse (protocole de communication)
•C’est une vue temporelle, elle ne correspond donc pas à un circuit proprement dit.
Modélisation du comportement (quand)
C’est une vue temporelle. C’est une description du comportement, dans le temps. Elle exprime la transformation de l’information entrée -> sortie. Elle montre le séquencement : un algorithme.
Il est nécessaire de faire la distinction entre :
•une fonction temporaire : elle s’active à l’arrivée d’un événement, à la manière d'une fonction séquencielle (machine d'états).
•une fonction permanente : elle est tout le temps active, à la manière d’une fonction combinatoire.
Un DIAGRAMME A ETATS FINIS convient bien à ce genre de description. Le GRAFCET (particulièrement utilisé en automatique), le STATECHART et le RESEAU DE PETRI sont d'autres variantes.
MCSE
HES-SO//HEIA-FR Page 18 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
DES OUTILS POUR MODÉLISER
•Tous les environnements CAE de développement logiciel (software) implémentent l’une ou l’autre de ces techniques de modélisations.
•Ce sont les méthodes utilisées dans le développement d’applications temps-réel qui se rapprochent le plus de celles qu’on utilise pour le développement matériel (hardware).
•VHDL est le langage de modélisation d’électronique numérique le plus significatif. Une extension vers la modélisation analogique est en cours: VHDL-AMS.
•Un environnement CAE pour l’électronique :
HDL-Designer de Mentor-Graphics.
Au delà des techniques de modélisation citées ci-dessus, le concepteur dispose d’outils informatiques pour effectuer concrètement le travail de modélisation. A ce titre, on peut citer le langage de description VHDL [3] souvent associé à un environnement de description graphique tel que HDL-Designer ou bien des environnements de modélisation de systèmes comme Matlab-Simulink.
MCSE
HES-SO//HEIA-FR Page 19 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
SPÉCIFICATION ET CONCEPTION DES ASICS
•ASIC = Application-Specific IC, c’est à dire un circuit intégré créé spécialement pour une application spécifique.
•La méthodologie de conception des ASIC n’est pas fondamentalement différente. Par rapport au développement d’un appareil ou d’un système tout entier, le travail peut paraître plus simple.
•Mais un IC est presque inaccessible et sa réalisation est définitive. En ce sens, la conception en vue du test (DFT) est primordiale pour la réussite du projet.
•Pour compenser un peur ces défauts, le prototype se fait en principe avec une technologie programmable (FPGA, par exemple).
L’ingénieur électronicien est parfois amené à développer un seul circuit intégré pour une application spécifique (ASIC = Application-specific IC). Par rapport au développement d’un appareil ou d’un système tout entier, le travail peut paraître plus simple.
Pourtant la méthodologie n’est pas fondamentalement différente (voir [4]). En effet, l’apparente simplicité du développement d’un circuit intégré est largement compensée par l’inaccessibilité et l’aspect définitif de sa réalisation. En ce sens, l’application des principes de conception en vue du test (DFT) est primordiale pour la réussite du projet. [5]
MCSE
HES-SO//HEIA-FR Page 20 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
D
ÉVELOPPER OU ACHETER ?
•Faire ou acheter est une vraie question qu’il faut se poser souvent dans un processus de développement technique.
•Pour une entreprise, le développement d’un produit s’évalue en termes de :
>coûts d’achat versus coûts de développement
Les achats de produits standard limite les coûts mais augmentent la dépendance.
>time-to-market
La première solution qui donne satisfaction n’est pas forcément la meilleure. Mais si elle est la première sur le marché, c’est le succès (presque) garanti !
Faire ou acheter est une vraie question dans le processus de conception. Les éléments de réponse sont multiples et dépendent fortement du point de vue et des expériences antérieures. Pour une entreprise, le développement d’un produit s’évalue en termes de :
Coûts: Il faut connaître le véritable coût d’un développement en interne, mais aussi le véritable coût d’un projet sous-traité. Au niveau des coûts, il est souvent possible de s’approvisionner sur les marché des produits standard à meilleur prix. L’achat des composants électroniques standard ne se discute donc pas. Mais la dépendance peut aussi mener tout droit à la perte. Actuellement, les fabricants de composants proposent des circuits dont les fonctionnalités sont toujours plus complexes. En maîtriser l’usage coûte cher !
Time-to-market : la vitesse de pénétration sur le marché est un des facteur les plus important pour assurer la survie de l’entreprise. On admet généralement que dépasser le budget de développement de 25% est moins domageable que de prendre plusieurs mois de retard pour la sortie du circuit. Acheter à bon escient peut faire gagner un temps précieux.
MCSE
HES-SO//HEIA-FR Page 21 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
D
ÉVELOPPER OU ACHETER ? (2)
>allocation des ressources en personnel et matériel
Mettre les bonnes personnes au bon endroit, en leur donnant les moyens adéquats, c’est une source de motivation.
>maintien du savoir-faire
Produire en interne peut être une bonne protection contre la concurrence.
>favoriser le partenariat
Une collaboration profitable aux deux parties est basée sur le principe “win-win”.
Allocation des ressources en personnel et matériel: Un groupe de développement est forcément limité. Est-ce que les concepteurs se consacrent aux travaux les plus importants et profitables pour l’entreprise ? Mais sans oublier que la motivation est un facteur déterminant pour la réussite. Acheter ne doit donc pas seulement « priver » les ingénieurs internes du joli boulot et les charger de tâches rébarbatives (quoique peut-être profitables).
Le savoir-faire d’une entreprise, qui est en particulier le savoir-faire de son personnel, est un élément stratégique pour le futur. Dans ce sens, faire au lieu d’acheter est une bonne protection contre la concurrence, car on évite de divulger des connaissances à des sous-traitants ou des fournisseurs. Cependant, il faut être attentif à ne pas paralyser son propre développement. Par l’achat de composants nouveaux il est possible de gagner du temps. Si des connaissances importantes pour l’entreprise doivent être discutées avec des tiers, il y a lieu de signer au préalable un accord de confidentialité (NDA = Non-Disclosure Agreement).
Partenariat: lorsque les compétences d’un fournisseur de composants ou de systèmes sont tellement évidentes, il faut envisager avec lui un partenariat de type OEM. (OEM = Original Equipment Manufacturer) Il faut trouver un équilibre « win-win » dans ce genre de collaboration, c’est à dire que chacun des deux partenaire y trouve son compte : le fournisseur produit et vend son système sans avoir le soucis de la commercialisation finale, l’acheteur peut bénéficier de la priorité et de la sécurité d’approvisionnement. De plus, ses besoins influencent le développement de nouveaux produits OEM.
MCSE
HES-SO//HEIA-FR Page 22 / 22
Dominique.Rheme@hefr.ch / févr. 2014 / MCSE_2014.FM
R
ÉFÉRENCES ET BIBLIOGRAPHIE:
[1] Spécification et conception de systèmes. Une Méthodologie (MCSE) [deux tomes, T 1: description de la méthodologie MCSE, T 2: études de cas] J-P. Calvez, éd. Masson 1992.
[2] Codesign, collectif, éd. Masson 1998.
[3] VHDL, notes du cours Electronique-Systèmes, EIF/Rhm.
[4] Spécification et conception des ASIC. J-P. Calvez, éd. Masson 1993.
[5] DFT, notes du cours Electronique-Systèmes, EIA-FR/Rhm.
[6] Electronique numérique et séquentielle, Noël Richard, éd. Dunod, 2002
[7] Make or buy ? Analog Devices

M.C.S.E 1
1
Introduction
Ce chapitre introductif présente le contexte général de cette thèse, la problématique traitée
et donne un aperçu global de la démarche suivie et du travail effectué. Nous décrivons tout
d’abord l’activité de conception conjointe matériel/logiciel appelée usuellement co-design, son
domaine d’application et les raisons de l’émergence de ce nouveau cycle de développement.
Nous présentons ensuite succinctement l’approche particulière que nous avons adoptée pour
résoudre deux problèmes sous jacents de l’activité de co-design: le partitionnement matériel/
logiciel et la co-simulation. Pour conclure ce chapitre, nous donnons l’apport de cette thèse et
le plan de ce manuscrit.
1.1 L’ACTIVITE DE CO-DESIGN
La complexité croissante des systèmes pour lesquels la réalisation résulte de l’association
d’une partie matérielle et d’une partie logicielle, la diversité des choix technologiques et les
contraintes de coûts et délais de plus en plus sévères nécessitent l’utilisation de nouvelles
méthodologies et outils logiciels associés pour diminuer leur durée de conception et accroître
leur qualité. Le co-design est l’une de ces méthodologies.
1.1.1 Définition du terme co-design
Le terme "Hardware/Software Concurrent Design" souvent abrégé par "Hw/Sw Codesign"
et qui se traduit par conception conjointe matériel et logiciel représente un processus de
conception complet basé sur la trilogie: modèles, méthodes et outils ESDA (Electronic System
Design Automation). Ce processus doit permettre aux concepteurs de transformer
correctement du premier coup les spécifications d’un système en un produit industriel
comportant une partie logicielle et une partie matérielle et satisfaisant les contraintes
Chapitre 1
2 M.C.S.E
fonctionnelles et non fonctionnelles de son cahier des charges. Il doit également permettre
d’accroître la qualité de conception et de réduire le temps de développement.
Dans la trilogie, un modèle est une représentation formelle d’un système à un niveau
d’abstraction donné. Il est bon de noter qu’une méthode efficace doit reposer sur un ensemble
de concepts de modélisation restreint mais suffisant pour décrire n’importe quel système. Le
terme méthode représente une procédure ou démarche bien définie et structurée permettant de
résoudre un problème. Les outils ESDA se composent d’outils de capture de modèles, de
simulation, d’analyse statique ou dynamique, de recherche de compromis, de synthèse et de
co-vérification. Les spécifications non fonctionnelles représentent tout ce qui dans le cahier des
charges n’est pas une exigence fonctionnelle. Il s’agit habituellement d’un ensemble de
contraintes d’intégration avec l’environnement (taille, puissance consommée), de
performances (temps de réponse, débit), d’ordre économique (coût, délai de fabrication), de
qualité (durée de vie, MTBF), de sûreté de fonctionnement, etc.
Gajski donne la définition suivante [MCC/OMI-96]: "CoDesign is defined as a
methodology and technique for designing software and hardware concurrently, thus reducing
the design time and time to market". Dans cette définition, le terme le plus important est
"concurrently" qui signifie que le développement simultané de la partie logicielle et de la partie
matérielle du système s’effectue avec une interaction forte et permanente entre les deux parties.
Cette approche diffère fondamentalement du cycle de conception conventionnel des systèmes
qui repose sur un développement séparé des deux parties.
1.1.2 Les classes de systèmes concernées par le co-design
Le développement des systèmes électroniques composés d’une partie matérielle et d’une
partie logicielle n’est pas un problème nouveau. Généralement, concevoir et réaliser de tels
systèmes nécessite une compétence technique dans au moins 3 domaines: l’électronique
analogique, l’électronique numérique et l’informatique. La nature spécifique du traitement à
effectuer et le couplage du système avec son environnement nécessitent aussi des compétences
complémentaires: en traitement de l’information (signal, image, parole...), en électronique de
puissance lorsque l’environnement utilise des courants forts, en réseaux et
télécommunications, etc.
Une analyse des types de systèmes conduit à la classification suivante [CALVEZ-90]:
- les systèmes typiquement électroniques qui impliquent essentiellement le
développement de matériel. Ils ne font donc pas directement partie du domaine de
l’activité de co-design même si l’apparition de composants matériels programmables,
des langages de description de matériel (VHDL, Verilog) et des outils de synthèse tend
à rendre de plus en plus floue la frontière entre matériel et logiciel.
- Les systèmes interactifs concernés par l’exploitation d’interfaces pour le dialogue
homme-machine. Ces systèmes sont constitués principalement de logiciels (système
d’information exploitant une base de données par exemple). Ils ne font donc pas partie
du champs d’application de l’activité de co-design.
Introduction
M.C.S.E 3
- Les systèmes de communications dominés par le transfert d’informations. Ces systèmes
reçoivent, transforment et émettent des flots de messages. Ils sont représentatifs des
systèmes pour lesquels les réalisations autrefois à dominante matérielle ont
progressivement évoluées vers un partage matériel/logiciel avec un accroissement de la
partie logicielle car les microprocesseurs sont devenus de plus en plus puissants. Mais,
une partie matérielle est pour ce type de systèmes indispensable pour respecter les débits
élevés des protocoles de communications (réseau ATM par exemple).
- Les systèmes de traitement concernés principalement par les traitements de toutes
formes d’informations: signal, image, parole... Ces systèmes sont caractérisés par des
techniques de conception orientées flot de données. Tout comme pour les systèmes de
communications, les réalisations de ces systèmes étaient autrefois surtout matérielles et
basées sur une partie opérative (ordonnancement ASAP ou ALAP en fonction du
compromis surface de silicium/performance) et une partie contrôle. Puis peu à peu,
l’arrivée de microprocesseurs spécifiques (DSP) de plus en plus performants a donné
une part de plus en plus importante au logiciel. Aujourd’hui, le développement de ces
systèmes est bien maîtrisé et repose sur l’utilisation de méthodes et outils efficaces
(COSSAP, SPW, DSP WorkStation,...) mais limités uniquement à leur domaine
d’application (approche algorithmique, CFG/DFG, synthèse haut niveau).
- Les systèmes de contrôle/commande dominés par des problèmes de suivi et de
commande pour des applications incluant des procédés physiques en tous genres à
piloter. Ils font partie d’un ensemble (système+environnement) composé d’actionneurs
qu’ils contrôlent en fonction des événements perçus par des capteurs.
Les travaux présentés dans ce manuscrit concernent surtout les systèmes de contrôle/
commande, les systèmes de communications et partiellement les systèmes de traitement. Ces
systèmes dit dédiés sont généralement conçus pour répondre à un besoin spécifique et entrent
dans la catégorie des systèmes électroniques embarqués et temps-réel (Real-Time Embedded
Systems).
Un système temps-réel réalise ses activités en respectant des contraintes de temps de nature
externe (fréquence d’événement, débit de sortie) ou interne (temps de réaction). Lorsque les
contraintes de temps sont assez faibles, la réalisation est logicielle avec ou sans l’emploi d’un
exécutif temps-réel (utilisation du mécanisme de gestion des interruptions du processeur).
Dans le cas contraire, le concepteur doit trouver le meilleur compromis entre une implantation
tout en matériel aux performances dynamiques et coût élevés et une implantation
complètement logicielle aux performances et coût faibles, ce qui en co-design correspond à la
problématique du partitionnement matériel/logiciel.
Les systèmes électroniques embarqués sont caractérisés par de fortes contraintes
d’intégration avec leur environnement: taille physique réduite, consommation faible,
résistance aux chocs et aux variations climatologiques, sûreté de fonctionnement, etc.
Aujourd’hui, ces systèmes intègrent systématiquement du matériel et du logiciel et sont de plus
en plus présents dans une grande variété de produits. Lorsqu’ils sont produits en grande série,
ils doivent présenter un coût de fabrication minimum. Le temps de mise sur le marché (timeto-
market), qui est un facteur clef pour le succès d’un produit, doit également être le plus court
possible. Enfin, tout comme les systèmes temps-réel, ils doivent généralement respecter des
contraintes dynamiques (temps de réaction faible, débit élevé). Ils constituent donc la cible
privilégiée de l’activité de co-design: "Creating an embedded computer system which meets its
Chapitre 1
4 M.C.S.E
performance, cost and design time goals is a hardware/software co-design problem. The
design of the hardware and software components influence each other" [WOLF-94].
1.1.3 La nécessité d’un nouveau cycle de développement
Sachant que l’implantation matérielle permet d’obtenir des performances dynamiques plus
élevées qu’une implantation logicielle mais à un coût plus élevé, depuis l’avènement de la
technologie VLSI et des premiers microprocesseurs, les équipes de conception recherchent le
meilleur partitionnement matériel/logiciel permettant de respecter les contraintes de coûts et de
performances imposées. A l’époque où les possibilités d’implantation matérielle et logicielle
étaient limitées, l’expérience seule des concepteurs pouvait suffire à les guider vers une
solution proche de l’optimum.
Les progrès réalisés aussi bien dans le domaine du génie logiciel (environnement de
programmation, langages de haut niveau, méthodes et langages orientés objet) que dans le
domaine du génie matériel (technologie VLSI, outils de synthèse logique, outils de synthèse de
haut niveau) permettent de réaliser des systèmes de plus en plus complexes. Jusqu’à encore peu
de temps, la réalisation des systèmes électroniques embarqués de grande complexité reposait
sur une approche d’ingénierie système caractérisée par une séparation nette de la conception et
réalisation des parties logicielles et matérielles. Les ingénieurs système avaient en effet la
responsabilité de concevoir l’architecture du système et d’identifier et spécifier les parties
matérielles et logicielles dont les réalisations étaient ensuite à la charge d’équipes de
conception distinctes ou étaient sous-traitées. Cette approche a entraîné un certain
cloisonnement et une absence de dialogue entre les concepteurs des deux catégories
professionnelles de culture différente: les concepteurs d’architectures matérielles et les
informaticiens. Ce manque de dialogue conduit ensuite à des difficultés importantes
découvertes tardivement durant l’intégration du logiciel sur le matériel. Malgré la malléabilité
du logiciel, les problèmes rencontrés lors de l’intégration se traduisent généralement par un
surcoût financier et temporel important.
L’approche d’ingénierie système est indispensable pour la conception des systèmes
hétérogènes complexes et/ou caractérisés par une sous-traitance importante (avionique,
automobile par exemple). Mais l’utilisation d’un tel cycle de développement pour les systèmes
électroniques embarqués s’est révélé très pénalisante et inadaptée pour répondre à des
contraintes de qualité, de coûts et délais de plus en plus sévères.
Tout d’abord, pour faire face aux problèmes de l’intégration tardive des parties matérielles
et logicielles, les concepteurs ont exploité la simulation conjointe de la partie logicielle et la
partie matérielle du système (co-simulation). Ils pensaient en effet que la possibilité de détecter
les erreurs de spécification et de conception en simulant le système relativement tôt dans le
cycle de développement, suffisait à obtenir une conception sans erreur et de qualité.
Ils se sont très vite aperçus que leurs besoins allaient bien au delà de la co-simulation et que
pour réduire la durée des développements et accroître la complexité des systèmes et la qualité
de conception, il fallait utiliser une méthodologie de conception complète et les outils supports
associés permettant de développer conjointement la partie matérielle et logicielle tout au long
du cycle de développement. Le terme méthodologie représente ici un ensemble structuré et
cohérent de modèles, de règles bien définies (méthodes), guides (démarche) et outils
permettant de déduire la manière de résoudre un problème [CALVEZ-90]. Dans le court terme,
les efforts concernent principalement le développement d’une telle méthodologie. Par
Introduction
M.C.S.E 5
exemple, le projet américain RASSP développe actuellement une méthodologie de co-design
en se basant sur l’utilisation d’un ensemble d’outils commerciaux et universitaires pour couvrir
toutes les phases de développement d’un projet et en utilisant principalement le langage VHDL
comme format d’échange entre les différents outils [SCHAMING-96].
Naturellement, une méthodologie de co-design apparaît comme un enrichissement d’une
méthodologie de conception système existante. En effet, il est plus judicieux d’adapter à la
problématique du co-design une méthodologie de conception système éprouvée que de
redéfinir entièrement une nouvelle méthodologie. Une méthodologie de conception système
est habituellement organisée selon quatre étapes principales: l’élaboration des spécifications,
la conception fonctionnelle ou préliminaire, la conception architecturale ou détaillée et la
réalisation. L’enrichissement d’une méthodologie système pour l’activité de co-design
concerne principalement l’étape de conception architecturale. A ce stade, les concepteurs
effectuent facilement en tenant compte de différents critères (répartition géographique,
performance, coût, sûreté de fonctionnement, flexibilité, testabilité, etc.) une répartition de la
solution fonctionnelle en une partie purement logicielle, une partie purement matérielle et une
partie plus délicate où une variation est possible entre le matériel et le logiciel. Notons que dans
les systèmes actuels, la part du logiciel est croissante. Des chiffres de plus de 70 % sont cités,
ce pourcentage étant bien entendu très dépendant du problème traité.
-Figure 1.1- Exemple de sous-système concerné par le co-design.
La description fonctionnelle détaillée de la partie spécifique ou sous-système sert de point
de départ de l’activité de co-design.
L’activité de co-design concerne également les systèmes de complexité moyenne à faible
pour lesquels une approche système n’est pas nécessaire. Aujourd’hui, le concepteur bénéficie
d’une grande diversité de choix pour la réalisation d’un système. L’offre en matière de
microprocesseurs (MPU, ASSP, ASIP, DSP), de langages de programmation et compilateurs
associés est vaste. Parallèlement, on peut aussi implanter de plus en plus de fonctions dans le
silicium (ASICs, FPGA, system-on-a-chip). Même pour les petits systèmes, cette diversité
rend de plus en plus difficile la conception intuitive basée sur l’expérience du concepteur.
1.1.4 Méthodologie pour le co-design
Dans le rapport [MCC/OMI-96], le processus de co-design est représenté par la figure 1.2.
L’activité de co-design (partie en blanc de la figure 1.2) est intégrée dans la démarche
d’ingénierie système. Les spécifications de la partie relevant du co-design résultent de
l’approche système qui consiste en la spécification, la conception fonctionnelle et le
partitionnement au niveau système. A partir de ces spécifications, le concepteur doit définir
l’architecture matérielle constituée de processeurs matériels (ASICs, FPGA, composants
Description au niveau système
Logiciel Matériel
Logiciel
et
matériel
Systèmes industriels de moyenne ou forte complexité
Spécification Partie concernée par le CoDesign
Chapitre 1
6 M.C.S.E
standards) et de processeurs logiciels (MPU, ASIP, DSP) et l’allocation des éléments de la
solution fonctionnelle sur cette architecture: c’est la problématique communément appelée
partitionnement matériel/logiciel. Il est bon de noter pour éviter toute confusion qu’un sens
différent est parfois donné au terme allocation. Par exemple dans [GAJSKI-95], le terme
allocation correspond à la sélection d’une architecture et le terme partitionnement à la
répartition des éléments de la description fonctionnelle sur l’architecture: "Allocation is the
problem of finding a set of system components to implement the system’s functions. Given a
functional specification and an allocation of system components, we need to partition the
specification and assign each part to one of the allocated components".
-Figure 1.2- Représentation du processus de co-design.
Un balayage rapide de l’espace des solutions conduit à sélectionner la solution la plus
appropriée. Ce parcours de l’espace des solutions possibles peut être automatique ou interactif
et repose toujours sur une estimation des propriétés résultantes du partitionnement choisi. Les
propriétés retenues sont généralement des contraintes de coût et de performances statiques
(taille, puissance consommée) ou dynamiques (temps de réponse, charge du processeur).
Une fois le partitionnement matériel/logiciel terminé, les descriptions fonctionnelles sont
transformées en code machine pour une implantation en logiciel et en un ensemble de portes
logiques et de bistables pour une implantation en matériel. C’est le rôle de la phase de cosynthèse
qui concerne la synthèse des parties matérielles et logicielles et la synthèse des
interfaces matériel/logiciel. Avant et après synthèse, une vérification fonctionnelle détaillée
(co-verification) est effectuée généralement par une technique de co-simulation. Un prototype
ou directement le produit est le résultat en sortie de l’activité de co-design et s’intègre alors
dans le système global.
Plusieurs aspects de la conception conjointe des systèmes matériels et logiciels sont
actuellement étudiés:
- la co-spécification qui concerne les étapes de spécification et de conception
fonctionnelle et pour lesquelles beaucoup de formalismes existent [GAJSKI-95]
[GAJSKI-96] [MICHELI-95] [CALVEZ-96a] [CALVEZ-96d]. Ces formalismes
(modèles et langages) servent à décrire principalement l’aspect fonctionnel. Les
spécifications non-fonctionnelles telles que les performances, la fiabilité, la sécurité, le
(Performances, coût, puissance consommée, etc)
Spécification de la partie relevant du co-design
Sélection de l’architecture & Partitionnement &
Exploration de l’espace des solutions possibles
synthèse
Synthèse des interfaces
logicielle
Synthèse
matérielle
Co-Verification
Prototypage / fabrication du produit
Spécification, conception fonctionnelle et partitionnement
Estimation des propriétés du système
au niveau système
matériel/logiciel et des
communications
inter-processeurs
Allocation &
Introduction
M.C.S.E 7
coût, sont beaucoup plus délicates à formaliser et pourtant elles sont essentielles pour
décider d’un partitionnement approprié et justifié. A ce stade, les différences de culture
et de jargon entre le monde du génie logiciel et du génie matériel ont nécessité des
efforts d’uniformisation de la terminologie [RTWG-95].
- le partitionnement matériel/logiciel qui concerne l’étape de conception architecturale.
Différentes techniques de partitionnement sont présentées dans le chapitre 2. Dans le
cas général, l’architecture matérielle peut être quelconque, c’est-à-dire hétérogène et
distribuée. Plus l’architecture est particularisée, plus les concepts et les outils associés
sont actuellement avancés. Souvent, l’architecture générique cible est choisie. Dans un
ensemble de travaux, par exemple [GUPTA-93], [THOMAS-93], on retrouve très
souvent l’emploi d’une architecture du type maître/esclave utilisant un microprocesseur
conventionnel ou un microcontrôleur comme maître associé à un ou plusieurs ASICs
comme esclaves. Il résulte que la solution est fortement dépendante de l’architecture et
des composants standards utilisés pour la réalisation [WOLF-94].
- laco-simulation qui concerne l’étape de conception architecturale pour la co-simulation
fonctionnelle et l’étape de réalisation pour la co-vérification détaillée. La co-simulation
est une simulation de la description mixte matériel-logiciel résultant d’un
partitionnement: "Hardware-software cosimulation is a means of verifying the
functionality of mixed hardware-software descriptions" [THOMAS-93]. La difficulté
de la co-simulation est liée à la différence de modèles et/ou de niveaux d’abstraction des
représentations du logiciel et du matériel. Les solutions de co-simulation reposent sur
l’emploi d’un langage de représentation unique et exécutable ou pour une simulation
hétérogène sur l’utilisation d’un mécanisme de communications entre différents
simulateurs. Différentes techniques de co-simulation sont présentées dans le chapitre 2.
- la co-synthèse (étape de réalisation) qui se charge de transformer les descriptions
fonctionnelles en descriptions directement implantables sur les processeurs matériels et
logiciels de l’architecture cible. Considérés séparément, le développement des
constituants logiciels (debuggeur symbolique, générateur d’IHM, profiler, approche
objet, exécutif temps-réel) et matériels (synthèse logique et haut niveau) sont
aujourd’hui bien maîtrisés. Les outils de synthèse logique sont très robustes. Les outils
de synthèse comportementale même s’ils manquent encore un peu de maturité, sont
aussi maîtrisés par les compagnies EDA/ESDA. Pour s’ouvrir de nouveaux marchés,
celles-ci s’intéressent de plus en plus à la conception au niveau système. La synthèse
logicielle souffre cependant de deux problèmes: le manque d’outil de compilation
efficace pour des microprocesseurs spécifiques, et le manque d’outil de génération de
code exécutable pour une description multi-tâches (ordonnancement des tâches
compris). Beaucoup de travaux de co-synthèse concernent aussi la génération des
interfaces matériel/logiciel [GUPTA-93] [YEN-95] [DAVEAU-95] [BORIELLO-96]
[FISCHER-96] [MULLER-96].
1.2 MOTIVATIONS DE L’EQUIPE
La plupart des techniques de partitionnement automatique se limitent à une architecture
matérielle constituée d’un microprocesseur, d’un ensemble de composants matériels
programmables et éventuellement d’une mémoire commune. Cette architecture est intéressante
pour son aspect générique mais elle correspond de moins en moins à la réalité industrielle. La
Chapitre 1
8 M.C.S.E
communauté du co-design a donc pris peu à peu conscience que le partitionnement
automatique plus ou moins rejeté par le milieu industriel [TUCK-97], n’est efficace que sur une
classe limitée de systèmes et que les recherches doivent s’orienter vers des solutions plutôt de
nature semi-automatique guidées par le concepteur et basées sur des outils d’estimation
rapides.
Le travail présenté ici est une contribution à cette nouvelle orientation. Comme la plupart
des techniques de partitionnement reposent sur des estimateurs statiques et que de nombreux
travaux ont déjà été effectués dans ce domaine, nous avons opté pour une technique différente
et complémentaire: l’évaluation des performances dynamiques d’un système par cosimulation.
La technique de partitionnement proposée repose sur la démarche itérative suivante:
compte tenu des contraintes diverses qui lui sont imposées, le concepteur définit une première
architecture matérielle et l’allocation des fonctions sur les processeurs matériels et logiciels de
cette architecture. La méthodologie MCSE fournit la démarche à suivre pour cette première
recherche de solution. Puis, l’évaluation des performances dynamiques du modèle du système
résultant donne en retour des estimations de performances tel que le temps de latence de
messages, le débit sur un bus ou encore le taux d’occupation d’une ressource. L’analyse de ces
performances permet de vérifier le respect des contraintes de performances et d’identifier les
ressources critiques. Une estimation des propriétés de la solution est alors possible et sert à
guider le concepteur qui peut alors modifier les ressources jugées critiques et l’implantation des
fonctions et réévaluer le modèle de sa solution.
Pour l’évaluation des performances dynamiques d’un système, nous avons retenu une
technique de co-simulation macroscopique et non interprétée basée sur la transcription en
VHDL d’un modèle de performance et sa simulation à l’aide d’un simulateur VHDL du
commerce. Le terme macroscopique signifie que le système n’a pas besoin d’être entièrement
détaillé et le terme non-interprété indique que seul les temps des opérations et les dépendances
temporelles sont prises en compte.
Cette approche se distingue donc par:
- l’utilisation de la simulation au lieu de l’évaluation analytique pour extraire les
performances dynamiques (temps de réponse, taux d’occupation d’une ressource) d’un
système. Contrairement à l’évaluation analytique, la simulation a l’avantage de pouvoir
analyser tout type de systèmes. Même si celle-ci souffre encore de temps de simulation
relativement longs, l’élévation du niveau d’abstraction des modèles et l’accroissement
régulier de la puissance de calcul des ordinateurs tend à minimiser cet inconvénient. De
plus, contrairement aux estimateurs statiques utilisés dans le partitionnement
automatique, notre approche permet de faire une analyse assez fine des comportements
et des performances très tôt dans le cycle de développement et éventuellement dès
l’étape de spécification (étude de faisabilité du projet). Durant l’étape de conception
fonctionnelle, elle permet aussi de dimensionner les éléments internes d’un modèle
(taille d’un port de communication par exemple); ce qui en général ne sera pas possible
ou très difficile avec l’utilisation d’un estimateur statique (théorie des réseaux de files
d’attente et des réseaux de Petri stochastiques).
- une modélisation du système à un niveau d’abstraction plus élevé que celui
habituellement utilisé pour la co-simulation qui généralement nécessite une description
détaillée de la solution.
Introduction
M.C.S.E 9
Dans le projet RASSP, la méthodologie de co-design mise en oeuvre repose sur l’utilisation
successive de plusieurs outils et modèles. Bien qu’elle soit hiérarchique et incrémentale, nous
pensons que cette approche basée sur un multi-formalisme entraîne un morcellement du
processus de conception qui a au moins deux conséquences:
- le passage d’une phase de conception à l’autre nécessite une transcription de modèle qui
peut entraîner des erreurs ou des déformations,
- il n’y a pas de traçabilité simple des informations et donc il est plus difficile de vérifier
l’adéquation de la solution obtenue par rapport aux spécifications du système.
Notre approche méthodologique basée sur la méthodologie MCSE [CALVEZ-90] pour
l’approche système est aussi hiérarchique et incrémentale et permet donc de faire face à la
complexité des systèmes en procédant par décomposition. Pour la phase de spécification, un
multi-formalisme s’impose face à la diversité des informations concernées qui sont de nature
fonctionnelles et non fonctionnelles. La phase de spécification [CALVEZ-96a] concerne en
effet l’analyse des entités de l’environnement du système (modélisation des informations
échangées, des activités et du comportement), la description du comportement du système vis
à vis des entités de l’environnement (automate à états finis, SpecChart, etc.) et la définition des
spécifications opératoires (précision des calculs par exemple) et technologiques (contraintes de
répartition, de temps, d’interfaces physiques, de sûreté de fonctionnement, etc.). Mais notre
approche méthodologique se distingue très nettement par l’utilisation d’un modèle unique à
partir de la phase de conception fonctionnelle. Le modèle de performance utilisé est en effet la
composition du modèle fonctionnel et du modèle exécutif préconisés par la méthodologie
MCSE et d’une vue comportementale qui permet de décrire le comportement de chaque
fonction de la vue fonctionnelle sous forme d’une composition d’activités. L’unicité du modèle
facilite la transition d’une phase de conception à l’autre: le modèle d’une phase de conception
donnée s’obtient par raffinement et enrichissement du modèle de l’étape précédente. La
continuité du modèle facilite aussi la conception sans erreur (pas de déformation ou perte
d’information liées à une transcription de modèle) et améliore la traçabilité.
1.3 CONTEXTE DE CETTE THESE
Cette thèse effectuée au sein de l’équipe MCSE de l’IRESTE a été financée par le CNET
dans le cadre de la CTI 9 (contrat no 941B CNET France-Télécom).
Le programme proposé des travaux était le suivant:
1- Montrer l’adéquation de la méthodologie MCSE pour la spécification, la conception et
l’évaluation des performances d’un système complexe. Ce travail a été effectué sur la
base d’un exemple d’application et en collaboration avec le CCETT de Rennes (G.
Babonneau) et l’équipe de J.M Bergé du CNET de Meylan. L’exemple d’application
fourni par le CCETT de Rennes est le serveur vidéo temps-réel décrit dans le chapitre 7.
2- Obtenir un modèle VHDL simulable pour l’extraction de performances. Pour cela, nous
avons défini les règles de transcription du modèle MCSE en une description VHDL. Ces
règles de transcription ont été validées à l’aide de deux exemples: le serveur vidéo et un
système de communication réparti. Puis elles ont été implantées dans un générateur de
code.
Chapitre 1
10 M.C.S.E
3- Développer une technique de génération de code automatique (modèle non-interprété
pour l’évaluation des performances) ou semi-automatique (modèle interprété pour la
vérification fonctionnelle et la synthèse) permettant de cibler sur différents langages.
4- Développer une démarche de partitionnement interactif basée sur une évaluation rapide
des performances dynamiques du partitionnement choisi.
Ces travaux s’intègrent au développement d’un support informatisé pour la méthodologie
MCSE. Ce développement constitue actuellement l’activité principale de l’équipe MCSE. En
amont des travaux effectués lors de cette thèse qui portent sur la modélisation des performances
et la génération de code pour la simulation, l’équipe développe des outils graphiques de
description (saisie des structures fonctionnelle et exécutive, saisie du comportement des
fonctions, configuration et allocation). En aval, le travail concerne la génération de code
exécutable [CALVEZ-93c], la synthèse des interfaces logiciel/matériel [CALVEZ-94]
[CALVEZ-96c], l’analyse des performances en différé (analyse de traces obtenues par
simulation) ou en temps-réel (monitoring) [CALVEZ-95b] [CALVEZ-95c] [CALVEZ-98a].
1.4 CONTRIBUTIONS
Le modèle de performance utilisé pour la co-simulation est le résultat d’une réflexion de
l’équipe sur la modélisation des performances qui a débuté en 1992 [CALVEZ-93b]. Le travail
effectué lors de cette thèse a débouché sur:
- l’enrichissement et la validation des concepts du modèle de performance.
- la définition d’une méthode d’évaluation des performances dynamiques d’un système
basée sur une transcription en VHDL du modèle de performance et l’utilisation d’un
simulateur VHDL du commerce.
Concernant l’aspect développement d’outils, ce travail a conduit à la réalisation d’un
générateur de générateur de code ou méta-générateur et d’un générateur de code VHDL
comportemental pour l’évaluation des performances et la vérification fonctionnelle. Le
principe de génération de code développé permet de transcrire facilement le modèle MCSE (ou
tout autre langage source) vers d’autres langages cibles. Le travail effectué sur la génération de
code a aussi amené l’équipe MCSE à revoir sa stratégie de développement des outils comme
support pour la méthodologie MCSE. En effet, l’expérience de génération de code effectuée
lors des travaux de cette thèse a permis d’appréhender les concepts de générateurs d’analyseurs
syntaxiques et de méta-structures sur lesquels repose entièrement la nouvelle "philosophie" de
développement des outils MCSE. Ces deux concepts et le nouveau principe de développement
de la plate-forme d’outils pour MCSE sont détaillés dans le chapitre 5 sur le méta-générateur.
1.5 PLAN DE LA THESE
Ce manuscrit de thèse est découpé en 6 chapitres principaux numérotés de 2 à 7. Dans le
chapitre 2, nous présentons la méthodologie de co-design, le principe de partitionnement et la
technique de co-simulation préconisés par l’équipe MCSE. Ce chapitre contient également un
état de l’art sur les techniques de partitionnement matériel/logiciel, les techniques de cosimulation
et la modélisation des performances. Le modèle de performance de MCSE est
approprié pour le co-design car il représente simultanément la partie matérielle et la partie
logicielle d’un système, est décrit dans le chapitre 3. Transcrit en VHDL en appliquant les
règles décrites dans le chapitre 4, ce modèle de performance permet de faire une co-simulation
Introduction
M.C.S.E 11
et d’extraire les performances dynamiques d’un système. La technique de génération de code
que nous avons utilisée pour transcrire le modèle textuel du modèle de performance en VHDL
est particulière. Nous avons en effet développé un générateur de générateur de code ou métagénérateur
nommé MetaGen et qui fait l’objet du chapitre 5. Avec cet outil, un générateur
particulier s’obtient par l’écriture d’un script qui définit les manipulations à effectuer sur les
structures de données pour mener à bien la transcription. Le chapitre 6 décrit le générateur de
VHDL comportemental. Le chapitre 7 valide les concepts du modèle de performance et les
méthodes de co-simulation et de partitionnement développées en présentant deux exemples
d’application: le serveur vidéo temps-réel fourni par le CCETT de Rennes et un système de
communication distribué basé sur l’interconnexion d’un ensemble de cartes identiques avec un
bus série du type anneau à jeton. En guise de conclusion, le chapitre 8 rappelle les points
essentiels du travail présenté et donne un ensemble de perspectives possibles.
Chapitre 1
12 M.C.S.E

M.C.S.E 13
2
Méthodologie de co-design et
estimation des performances
Dans le chapitre précédent nous avons présenté le problème du co-design comme celui du
développement d’une méthodologie de conception et des outils supports. Nous avons montré
qu’une approche système est nécessaire pour déterminer les parties du système relevant de
l’activité de co-design. Le développement de ces parties se distingue des approches système
par la nécessité d’une interaction forte entre les développements de la partie logicielle et de la
partie matérielle.
Lorsque les parties du système relevant de l’activité de co-design ont été clairement
identifiées et spécifiées, le concepteur doit effectuer la sélection d’une architecture matérielle
et l’allocation des constituants fonctionnels sur les unités matérielles de l’architecture choisie.
L’espace des solutions possibles apparaît très vaste. Les choix du concepteur doivent satisfaire
à un nombre important de critères (performances, flexibilité, testabilité, reutilisabilité, sécurité,
etc). Il s’agit de la problématique du partitionnement matériel/logiciel. En limitant le nombre
de critères et en figeant l’architecture cible, le problème se réduit à un problème d’allocation
qui peut se résoudre automatiquement avec une heuristique basée sur une fonction pondérée
dont les coefficients dépendent des critères retenus. Dans le cas général (architecture cible
hétérogène et nombre de critères élevé), il faut aider le concepteur en lui offrant des moyens
d’estimations rapides des performances statiques et/ou dynamiques du partitionnement choisi.
Le niveau de description des modèles utilisés ainsi que le niveau de granularité du
partitionnement sont alors très influents sur les moyens et les résultats obtenus. L’estimation
des performances statiques telles que la surface de silicium occupée, la puissance consommée
repose sur des techniques de synthèse qui nécessitent une description au moins du niveau
algorithmique. Pour estimer les performances dynamiques, il faut recourir à une analyse des
contraintes temporelles ou à l’utilisation d’un modèle de performance. L’analyse temporelle
nécessite une description sous la forme de diagramme de flot de données et/ou flot de contrôle
Chapitre 2
14 M.C.S.E
et permet de calculer une approximation des caractéristiques des processeurs. L’utilisation
d’un modèle de performance ne nécessite pas une description aussi détaillée que pour les
estimateurs cités précédemment et permet d’extraire un nombre plus important de résultats de
performances dynamiques du partitionnement choisi: temps de latence, débit sur un bus, taux
d’occupation d’une ressource, nombre moyen de messages dans un port de communication,
etc.
Ces résultats de performances s’obtiennent généralement par une approche analytique
(réseau de files d’attente, réseau de Petri stochastique) ou par simulation. La complexité des
systèmes que nous considérons sort souvent du domaine d’application strict des modèles
analytiques et la simulation reste alors la seule alternative possible. Comme le modèle de
performance représente à la fois la partie logicielle et la partie matérielle résultant du
partitionnement, il s’agit en fait d’une technique de co-simulation.
Ce chapitre présente la méthodologie de co-design préconisée au sein de l’équipe MCSE
caractérisée par sa méthode de partitionnement et sa technique de co-simulation. Avant de
décrire le principe de partitionnement qui repose sur une démarche itérative et sur une
évaluation des performances dynamiques du système, nous passons en revue différentes
méthodes de partitionnement. L’évaluation des performances dynamiques est effectuée par une
co-simulation. Nous présentons donc ensuite un panorama des techniques de co-simulation
existantes et celle retenue par l’équipe qui est macroscopique et non interprétée. Le terme
macroscopique signifie que le système n’a pas besoin d’être entièrement détaillé. Le terme
non-interprété signifie que seul le temps des opérations et les dépendances temporelles sont
pris en compte. Pour cette co-simulation, le modèle de performance de MCSE est transcrit en
un code VHDL. Nous allons donc aussi nous intéresser aux techniques de génération de code
et à la modélisation des performances dynamiques des systèmes. Pour la modélisation des
performances des systèmes, différentes classes de modèles de performances des systèmes et
leurs outils les plus représentatifs sont décrits et analysés. L’analyse des modèles de
performances présentés montre qu’ils ne sont pas bien adaptés au co-design. En effet, ils ne
distinguent pas clairement la vue fonctionnelle du système de sa vue architecturale. Or à notre
avis, cette séparation des deux vues est indispensable pour permettre l’exploration correcte du
domaine des solutions possibles lors du partitionnement.
2.1 PRESENTATION DE LA METHODOLOGIE DE CO-DESIGN
Les méthodologies proposées pour le co-design se distinguent essentiellement par:
- les concepts de modélisation utilisés de la spécification du système au produit final,
- les modèles de l’architecture cible. L’architecture cible peut être une architecture
mono-processeur constituée d’un processeur, d’un ensemble de composants matériels
spécifiques (ASIC, FPGA) et éventuellement une mémoire commune. Il peut s’agir
aussi d’une architecture distribuée composée d’un réseau de processeurs matériels
(ASIC, FPGA) et de processeurs logiciels (microprocesseur, DSP, ASIP).
- laméthode de partitionnement (interactif, semi-automatique ou automatique).
- La méthode et technique de co-vérification.
- Latechnique de co-synthèse où l’on retrouve la synthèse du logiciel, du matériel et des
interfaces matériel/logiciel.
Méthodologie de co-design et estimation des performances
M.C.S.E 15
Notre méthodologie de co-design basée sur la méthodologie MCSE est caractérisée par une
approche système, une modélisation selon 3 vues (fonctionnelle, comportementale et
architecturale), une architecture cible hétérogène et non figée, une méthode de partitionnement
interactif basée sur une évaluation des performances dynamiques, une technique de
co-simulation macroscopique et non-interprétée basée sur un modèle d’attributs et une
technique de co-synthèse incluant la génération des interfaces matériel/logiciel qui repose sur
un modèle de bus (protocole) générique et l’utilisation d’une librairie de fonctions d’adaptation
vers un bus spécifique (VME, PCI, I2C, etc.) [MULLER-96].
Nous recommandons l’utilisation de la méthodologie MCSE pour faire tout d’abord
l’approche système nécessaire afin de rechercher une solution si possible globalement optimale
vis-à-vis de l’ensemble des contraintes. La solution fonctionnelle développée servira alors
comme base pour identifier les parties qui relèvent du co-design. La description fonctionnelle
de chaque partie sert ainsi de spécification. L’architecture de la solution complète se déduit par
MCSE. Les parties de l’architecture plus spécifiques du co-design seront décidées selon les
contraintes à satisfaire. Une description détaillée et la justification de cette approche est
expliquée dans [CALVEZ-96e] et [CALVEZ-97a].
2.1.1 Rappel de la méthodologie MCSE
MCSE est une solution possible comme schéma d'organisation pour tout développement de
systèmes électroniques et informatiques à caractère temps-réel. Cette méthodologie conduit à
la conception et la réalisation de composants, de cartes, de systèmes à la fois pour les aspects
matériel et logiciel, ainsi qu’au développement de logiciels en divers langages de manière à
particulariser le matériel pour que celui-ci réponde aux fonctionnalités exigées de l'application
[CALVEZ-90], [CALVEZ-93a].
Un développement, selon MCSE, est décomposé en 4 étapes (figure 2.1):
- l'étape de Spécification qui a pour objectif d'élaborer une description externe la plus
complète possible du système à concevoir, et ceci à partir du cahier des charges.
-Figure 2.1- Démarche de développement avec MCSE.
Niveau 1
Niveau 2
Niveau 3
Niveau 4
Abstrait
Concret
PRODUIT
Temps
DEFINITION
de la
REALISATION
REALISATION
Spécifications
Description fonctionnelle
Description exécutive
Modèles
Spécification
Modèle
fonctionnel
Modèle
d’exécution
Spécifications
Spécifications
fonctionnelles
et opératoires
CHARGES
CAHIER
DES
technologiques
CONCEPTION
FONCTIONNELLE
Spécifications technologiques de réalisation
SPECIFICATION
Partie incluant
le co-design
Chapitre 2
16 M.C.S.E
- l'étape de Conception fonctionnelle. Elle conduit à rechercher une solution pour le
système sous la forme d'un ensemble de fonctions et de relations entre celles-ci. Cette
solution est une vue orientée vers l'application et se doit d'être indépendante de la
technologie.
- l'étape de Définition de la réalisation. Il s'agit d'introduire la répartition géographique
et les interfaces physiques pour satisfaire les contraintes technologiques, puis après
avoir défini le partitionnement matériel/logiciel compte-tenu des contraintes de temps
et autres contraintes de réalisation, de déterminer les spécifications des parties
matérielles et logicielles.
- l'étape de Réalisation qui consiste à développer le matériel et le logiciel à partir des
spécifications de l'étape précédente.
A chaque niveau de description correspond un modèle bien formalisé qui sert d’interface et
de documentation entre les étapes successives. L’étape 3 sert à identifier les spécifications de
la réalisation. Aussi, c’est dans cette étape que se situe l’activité de co-design.
2.1.2 Démarche pour la définition de la réalisation
L’étape de Définition de la Réalisation de MCSE est décomposée en 3 phases:
- Transformation de la solution fonctionnelle pour satisfaire les spécifications
technologiques de répartition géographique et d’interfaces. Il en résulte une solution
fonctionnelle détaillée et optimisée.
- Partitionnement au niveau système, qui vise à identifier à partir de la solution
fonctionnelle complète la partie purement logicielle, la partie purement matérielle, la
partie concernée par le co-design.
- Spécifications de réalisation pour le logiciel, le matériel et la partie co-design. Les 3
parties sont considérées conjointement. Une vérification et une analyse des propriétés
de la solution achèvent cette phase et l’étape pour s’assurer du respect de l’ensemble des
contraintes.
La figure 2.2 montre l’organisation de la démarche pour cette étape. Une partie des
spécifications technologiques est considérée ici. Il s’agit des contraintes de distance entre
constituants ou/et entre entrées/sorties, des contraintes d’interfaces physiques et d’interfaces
homme/machine, des contraintes de performances, de sûreté, de coût.
Durant l’activité de répartition géographique, un premier partitionnement est déjà effectué.
Il se base exclusivement sur les distances imposées entre certains constituants du système. Il
s’agit d’un partitionnement fonctionnel c’est-à-dire vis-à-vis de l’objectif à satisfaire. La
phase 1 amène ainsi à déformer la solution fonctionnelle de l’étape précédente au sens de son
enrichissement par des détails en vue de satisfaire des contraintes d’ordre technologique.
La phase 2 concerne cette fois le partitionnement du système complet et donc sa solution
fonctionnelle vis-à-vis de la technologie de réalisation, c’est-à-dire matériel ou logiciel. Les
contraintes influentes que sont les performances, la sûreté de fonctionnement au sens large du
terme, le coût, servent de base pour déterminer la ou les parties qui conduisent à une réalisation
purement logicielle, à une réalisation purement matérielle, à une réalisation où une variation
est possible entre le matériel et le logiciel (partie qualifiée de co-design). Ce partitionnement
est de niveau système et se comprend bien lorsque l’on considère un système possédant le
Méthodologie de co-design et estimation des performances
M.C.S.E 17
qualificatif de complexe. La séparation radicale matériel ou logiciel est généralement assez
simple pour une grande partie du système. La partie restante (frontière à délimiter) qui se veut
plus délicate est celle relevant du co-design.
-Figure 2.2- Description de la démarche pour l’étape de définition de la réalisation.
La phase 3 vise à déterminer les spécifications les plus complètes possible de chacune des
parties et les interfaces entre elles. En suivant la méthodologie MCSE, la spécification du
matériel pour le système complet se fait en définissant le support d’exécution (ou architecture
matérielle) et toutes ses propriétés. La spécification du logiciel s’obtient en définissant le
schéma d’implantation du logiciel pour chaque processeur programmable de l’architecture
matérielle. Il reste alors chaque partie co-design qui nécessite une démarche plus affinée pour
aboutir à sa spécification détaillée permettant ensuite la vérification et la réalisation. Le détail
de cette démarche est décrit dans le paragraphe suivant.
L’activité de vérification et d’analyse globale vise à garantir au mieux que les concepteurs
disposent de spécifications de réalisation complètes, cohérentes et optimales vis-à-vis des
contraintes permettant d’aboutir à un système complet en accord avec les spécifications du
niveau système et donc en accord avec toutes les exigences du client. Cette activité est basée
sur l’emploi d’un modèle de description mixte matériel-logiciel exécutable de la solution, ou
tout au moins des parties critiques.
L’intérêt fondamental de cette démarche basée sur MCSE pour faciliter le travail de
co-design est de se poser réellement la question d’un partitionnement système (logiciel ou
matériel ou les deux simultanément) pour l’ensemble de l’application de manière à
correctement isoler les seules parties qui sont du ressort du co-design. D’une manière générale,
la spécification en entrée de l’activité de co-design se doit d’être le résultat d’une démarche
d’un niveau supérieur qui est le niveau système. Ceci correspond au fait qu’une bonne
résolution d’un problème passe d’abord par son “immersion” dans un problème plus global.
Spécifications Description fonctionnelle
Contraintes interfaces
Spécifications de la réalisation complète
Spécifications
Description fonctionnelle détaillée et optimisée
Phase 1
Phase 2
Phase 3
Corrections
Améliorations
pour
vérification
Partitionnement géographique
Introduction des interfaces physiques et IHM
Synthèse
interfaces
Partitionnement système
Evaluation globale
Distances
Partie(s)
matérielle(s)
Partie(s)
logicielle(s)
Partie(s)
co-design
Performances, sûreté,
coût
Chapitre 2
18 M.C.S.E
2.1.3 Démarche pour le co-design
Le travail de co-design s’intègre ici comme un sous-ensemble de l’étape 3 de définition de
la réalisation de la méthodologie MCSE. Les données d’entrée en tant que spécifications sont:
la description fonctionnelle détaillée de la partie concernée par le co-design, les spécifications
non-fonctionnelles de cette partie. Il en résulte en sortie la spécification détaillée et complète
de la solution de réalisation.
La figure 2.3 représente les différentes phases de la démarche de co-design [CALVEZ-94]
[CALVEZ-96c]. On notera bien entendu l’importance de la phase de partitionnement matériel/
logiciel et d’allocation pour aboutir aux spécifications des 2 parties.
-Figure 2.3- Démarche de co-design avec maîtrise des performances.
La démarche de co-design est décomposée en 2 phases:
Phase 1: Partitionnement et allocation, évaluation
• Décomposition de la solution fonctionnelle d’entrée en une partie logicielle et une
partie matérielle compte-tenu des performances et des contraintes de temps à
satisfaire,
• Spécification de la structure d’exécution (architecture matérielle) et allocation des
fonctions sur les composants,
• Evaluation et vérification de la solution vis-à-vis des spécifications
non-fonctionnelles imposées, ce qui implique une co-simulation.
Phase 2: Synthèse, génération, évaluation
• Conception architecturale et synthèse de la partie matérielle,
• Spécification et génération de la partie logicielle,
• Synthèse et génération des interfaces entre le matériel et le logiciel,
Description fonctionnelle détaillée de
Architecture
Performances,
Specification pour la réalisation
Contraintes
Phase 1
Phase 2
Corrections,
améliorations
Contraintes de temps,
Spécifications non-fonctionnelles
workload
locales
Corrections
globales
Corrections
Partitionnement approprié
Rétro-annotation
Modélisation et évaluation Performances
(Co-vérification non-interprétée)
Partitionnement, allocation
Evaluation détaillée(Co-vérification interprétée)
Synthèse
Matériel
Synthèse
Logiciel
Corrections
la partie concernée par le co-design
Contraintes de
réalisation Synthèse
interfaces
technologiques
Méthodologie de co-design et estimation des performances
M.C.S.E 19
• Evaluation et vérification du comportement fonctionnel et des performances.
Ces phases sont décrites plus en détail ci-après.
-A- Partitionnement, allocation et évaluation
La phase 1 concerne la recherche d’une architecture matérielle appropriée comme support
de la description fonctionnelle détaillée et qui va permettre d’aboutir à une solution
opérationnelle qui satisfait les contraintes de performances, les contraintes de temps, le coût,
etc. Le partitionnement de la structure fonctionnelle est la première tâche qui permet
d’identifier les fonctions qui peuvent être implantées en logiciel et les fonctions à implanter
obligatoirement en matériel.
Avec la méthodologie MCSE, nous proposons de suivre une démarche de partitionnement
interactif assuré par le concepteur car il peut aisément décider pour chaque fonction le meilleur
choix, en particulier après une modélisation et une évaluation des performances.
La structure d’exécution peut alors être définie: les fonctions matérielles sont à implanter
sous la forme d’une architecture de composants matériels, les fonctions logicielles sur un ou
plusieurs microprocesseurs en fonction des contraintes de temps, de coût et de répartition. Des
liens nécessaires pour le couplage entre le matériel et le logiciel doivent alors être spécifiés
pour l’implantation des relations fonctionnelles. D’une manière générale, la structure
d’exécution résulte d’un travail d’abstraction fait sur la structure fonctionnelle détaillée.
Le résultat de ce travail doit être vérifié. Il s’agit de s’assurer que le partitionnement et
l’allocation choisis ainsi que les caractéristiques de l’architecture matérielle permettent de
satisfaire toutes les exigences attendues et écrites dans le document de spécification sous le
vocable spécifications non-fonctionnelles. Pour ce faire, le résultat est transcrit sous la forme
du modèle de performances de MCSE. Il s’agit d’un modèle non-interprété qui, par simulation,
permet de déduire les propriétés de performance [CALVEZ-96b] [CALVEZ-96d]. Une
modélisation de l’environnement est faite pour simuler les conditions d’utilisation (workload).
D’autres moyens de vérification et d’analyse peuvent être ajoutés pour augmenter la confiance
dans la solution retenue.
-B- Génération, synthèse, évaluation
La phase 2 concerne la génération de l’ensemble de la solution, ce qui comprend: la
description de l’architecture matérielle en y incluant la description de tous les composants
spécifiques et/ou programmables (ASICs), les programmes pour tous les microprocesseurs.
Pour la description du matériel, il faut distinguer 2 parties et donc 2 niveaux de détail. Le
premier niveau concerne le schéma d’interconnexion des composants retenus pour la solution:
microprocesseur(s), mémoires, EPLD, FPGA, etc. La description d’un tel schéma est
conventionnelle et s’obtient par l’emploi d’outils de saisie de schémas. Ce schéma permet
ensuite la réalisation directe par assemblage ou la réalisation de carte(s) imprimée(s) comme
support(s) des composants ou même la réalisation d’un "System on a chip". Le deuxième
niveau concerne la description de chaque ASIC. Cette description est à faire de préférence en
langage de haut-niveau tel que VHDL de manière à pouvoir utiliser un synthétiseur
architectural ou de haut niveau.
Pour la partie logicielle, très souvent, une organisation multi-tâches doit être retenue par
suite de l’existence de plusieurs fonctions asynchrones à implanter sur un même
microprocesseur. Une méthode efficace consiste à définir un schéma d’implantation logicielle
(voir MCSE) sans utiliser d’exécutif temps-réel. Une autre méthode consiste à utiliser un
Chapitre 2
20 M.C.S.E
exécutif temps-réel. Dans ce cas, chaque fonction est implantée comme une tâche et les
relations entre fonctions utilisent les mécanismes de sémaphore, de boite à lettre, de partage de
ressources. Une solution intermédiaire existe en utilisant judicieusement les qualités de ces 2
méthodes [CALVEZ-97b].
Des interfaces correctes entre le matériel et le logiciel doivent aussi être générées pour une
implantation appropriée et efficace des relations fonctionnelles. Ces interfaces sont produites
par synthèse à partir des caractéristiques du couplage matériel entre le microprocesseur et son
environnement. Des modèles génériques de bus sont ici exploitables (bus VME, bus PCI,....).
L’ensemble de la solution - matériel, logiciel, interfaces - sert ensuite pour une vérification
détaillée de toutes ses propriétés: propriétés fonctionnelles et non-fonctionnelles. Une
technique de co-simulation est alors appropriée pour ce type de vérification. Un modèle de
l’environnement est à nouveau nécessaire. Il résulte du travail déjà effectué pour l’ensemble du
système au niveau fonctionnel. Il s’agit donc d’exploiter le modèle fonctionnel complet et
optimisé pour lequel la partie co-design du système qui vient d’être conçue est remplacée par
le résultat de cette phase 2.
Le résultat issu de cette étape de co-design peut ensuite être prototypé, vérifié et validé puis
intégré dans la solution d’ensemble du système complet.
2.1.4 Bilan
La présentation faite dans ce paragraphe montre clairement que la démarche de co-design
n’est pas une activité isolée de la conception de l’ensemble du système. Faisant partie
intégrante de l’étape de définition de la réalisation, le travail de co-design est appliqué sur une
ou des parties qui ont été pleinement identifiées comme justifiant d’une telle approche. En
amont, en plus d’un partitionnement géographique réalisé durant la conception préliminaire,
un travail de partitionnement au niveau système conduit à décider d’une première grande
répartition matériel ou logiciel si possible optimale globalement. Il en résulte une identification
de zones intermédiaires qui nécessitent un travail plus approfondi qui est alors typiquement du
ressort du co-design. Pour ces parties, un optimum local est alors recherché. Une telle approche
système en 2 temps évite les écueils du “défaut de myopie” qui amènerait à trouver un optimum
local pour une spécification donnée sans s’être assuré que la spécification résulte elle aussi
d’un optimum pour le niveau système.
Bien entendu, lorsqu’un problème posé est seulement du ressort du co-design, seule la
démarche décrite par la figure 2.3 est suffisante à condition de disposer des spécifications
correctes et complètes de l’objet à concevoir. Pour décider de la bonne démarche à suivre, une
question importante à se poser est de savoir si le problème est ou non “immergé” dans un
problème plus vaste. On constate aujourd’hui que la plupart des problèmes sont présentés
isolés alors qu’en réalité ils ne le sont pas. MCSE impose une démarche plus globale ne
serait-ce qu’en imposant d’abord une analyse et une modélisation de l’environnement de
l’objet à concevoir, modélisation bien utile en final pour la vérification et la qualification du
système placé dans son environnement.
2.2 METHODES DE PARTITIONNEMENT
Le problème du partitionnement matériel/logiciel est au coeur de l’activité de co-design. Le
choix de l’architecture matérielle est un élément de décision essentiel et la démarche diffère
selon que l’architecture se trouve imposée ou choisie d’emblée ou que l’architecture et les
Méthodologie de co-design et estimation des performances
M.C.S.E 21
composants de celle-ci sont à déterminer. La première situation est la plus commune et la plus
simple. L’architecture matérielle est généralement une architecture générique constituée d’un
microprocesseur, d’un ensemble de circuits matériels programmables ou d’ASICs et d’une
mémoire commune. Le problème du partitionnement se réduit alors à un problème de
partitionnement binaire matériel/logiciel pour l’allocation des éléments fonctionnels sur les
constituants de l’architecture et peut se résoudre de manière automatique. Nous nous
intéressons à la deuxième situation plus complexe et plus proche de la réalité industrielle. Dans
ce cas, face à la nature hétérogène de l’architecture cible et à la diversité des contraintes
imposées, une démarche itérative et guidée par le concepteur s’impose. Il s’agit alors d’offrir
au concepteur des moyens rapides d’estimation des propriétés de l’implantation résultant du
choix de l’architecture, du partitionnement et de l’allocation pour vérifier si celles-ci répond
aux contraintes imposées. Pour les parties du système relevant du co-design, les contraintes
imposées sont surtout des contraintes de performances. En effet, les contraintes telles que la
flexibilité, la testabilité, l’utilisation de composants du commerce ou de technologies
maîtrisées par l’entreprise, la sûreté de fonctionnement et les coûts interviennent
principalement au niveau du partitionnement système qui a pour but le découpage du système
en un ensemble de partitions où chaque partition devra s’exécuter soit en logiciel soit en
matériel. Les contraintes de performances sont de nature statique ou dynamique. L’estimation
des performances statiques telles que la surface de silicium occupée, la puissance consommée
repose sur des techniques de synthèse. La plupart des travaux de la communauté du co-design
sur l’estimation des performances dynamiques d’un partitionnement, sont basés sur une
analyse des contraintes temporelles et un calcul de la charge du processeur par des techniques
proches de celles utilisées en ordonnancement de tâches pour des systèmes temps-réels. Nous
proposons une autre alternative qui consiste à utiliser un modèle de performance. La simulation
de ce modèle de performance permet d’extraire un ensemble d’estimations de performances
plus riches que les approches analytiques: débit sur un bus, taux d’occupation d’une ressource,
temps de latence d’un message, détection du non respect d’une contrainte temporelle, etc.
2.2.1 Le partitionnement matériel/logiciel
Le partitionnement matériel/logiciel assure la transformation des spécifications de la partie
du système relevant de l’activité co-design en une architecture composée d’une partie
matérielle et d’une partie logicielle. Les spécifications considérées sont en réalité une
description fonctionnelle détaillée résultant d’une approche système. Cette transformation
s’effectue habituellement en deux phases: la sélection d’une architecture matérielle et
l’allocation des éléments (fonctions et éléments de relations) du modèle fonctionnel sur les
éléments de cette architecture. Plusieurs critères peuvent intervenir sur le double choix
(architecture et allocation) d’un partitionnement tels que par exemple:
- les performances statiques (consommation, surface de silicium, coûts, taille du code,
taille de la mémoire, etc) et dynamiques (contraintes de temps, débit, temps de latence,
taux d’occupation, etc). Elles influent surtout sur l’allocation des fonctions.
- la sécurité: La prise en compte de la sûreté de fonctionnement peut induire des
contraintes au partitionnement matériel/logiciel (redondance de composants matériels
et de tâches logicielles par exemple),
- laflexibilité: l’implantation logicielle d’une fonction offre des possibilités d’évolution
plus importantes qu’une implantation matérielle,
Chapitre 2
22 M.C.S.E
- laréutilisation: La réutilisation de composants est un facteur important de productivité,
mais introduit des contraintes au niveau du partitionnement,
- latestabilité: l’extraction d’informations en temps-réel nécessite l’ajout de composants
matériels supplémentaires (Bist, Boundary Scan) ou l’ajout d’instructions de capture.
Actuellement, il n’existe pas de méthodes formelles réellement opérationnelles qui
permettent à partir des contraintes à satisfaire et des spécifications du système de générer
directement une répartition matériel/logiciel. La difficulté du problème est liée à la diversité
des contraintes à satisfaire et des possibilités de sélection d’architecture puis d’allocation.
Le partitionnement s’effectue par des approches successives soit de manière automatique
par le biais d’algorithmes de recherche soit de manière interactive avec l’aide du concepteur.
La plupart des techniques de partitionnement automatique repose sur une architecture cible
imposée et mono-processeur, une heuristique et l’utilisation d’une fonction de coût dont les
coefficients de pondération dépendent de critères tels que ceux cités précédemment. Le
partitionnement interactif cible généralement vers une architecture hétérogène à définir et
s’appuie sur des estimateurs de performances statiques et/ou une estimation des performances
dynamiques du système pour guider le concepteur dans le choix d’une répartition.
Les techniques de partitionnement décrites dans la littérature peuvent être classées par:
- leur degré d’automatisation allant d’une démarche manuelle à une démarche
entièrement automatique,
- Les critères influençant le choix d’un partitionnement (contraintes statiques ou
dynamiques, sûreté de fonctionnement, flexibilité, testabilité, coûts),
- le choix de l’architecture cible figée ou libre,
- le degré d’abstraction du modèle représentant les éléments de la spécification du
système à partitionner et de l’architecture matérielle allant d’une modélisation
macroscopique à une modélisation architecturale détaillée.
Pour les spécifications d’entrée d’un partitionnement, trois niveaux de granularité du
partitionnement sont habituellement utilisés: le niveau tâche, le niveau procédure et le niveau
instruction. Pour le niveau tâche (coarse-grain partitioning), l’unité d’allocation est la fonction
qui est considérée indivisible et dont le comportement n’est pas obligatoirement séquentiel.
Pour le niveau procédure, une fonction est décomposée en un ensemble de séquences
d’instructions appelées procédures et qui peuvent être allouées sur des processeurs différents.
Pour le niveau instruction (fine-grain partitioning), l’unité d’allocation est la plus petite
possible puisqu’il s’agit d’une instruction. L’utilisation d’un niveau de granularité fine
concerne plutôt des systèmes de faible complexité ou une conception architecturale avancée
qui se situe relativement tard dans le cycle de développement.
2.2.2 Le partitionnement automatique
Le problème du partitionnement est souvent présenté comme un problème NP complexe
dépendant d’un grand nombre de paramètres. Pour résoudre ce problème, la plupart des
méthodes automatiques réduit le nombre des paramètres (prise en compte d’un nombre limité
de critères) et utilise une heuristique basée sur une fonction de coût pondérée par les critères
retenus.
Méthodologie de co-design et estimation des performances
M.C.S.E 23
Actuellement de nombreuses heuristiques de partitionnement ont été développées. Une
synthèse des méthodes et algorithmes de partitionnement matériel/logiciel automatiques est
présenté par Rousseau, Bergé et Israel [ROUSSEAU-95]. On peut citer en autres (liste non
exhaustive):
- l’algorithme gourmand (Greedy algorithm) utilisé dans VULCAN [GUPTA-95] pour
lequel toutes les fonctions sont initialement implantées en matériel et sont migrées vers
le processeur logiciel en vérifiant les contraintes temporelles. La fonction de coût
utilisée est pondérée par la surface du matériel, la taille du programme de code
(mémoire) et le taux d’occupation du processeur.
- l’approche de COSYMA [ERNST-93] est opposée à celle utilisée dans VULCAN. Les
fonctions sont au départ toutes implantées en logiciel puis migrées vers le matériel
jusqu’au respect des contraintes de performances.
- Les algorithmes utilisés dans Co-Saw [ADAMS-95] et dans SpecSyn [VAHID-95] sont
basés sur la construction progressive de groupes de fonctions (clustering based
algorithm) pouvant partager la même ressource matérielle ou logicielle.
Les algorithmes cités précédemment dépendent fortement (coefficient de pondération de la
fonction de coût) des caractéristiques de l’architecture cible choisie. Souvent l’architecture
cible est composée d’un seul processeur logiciel couplé à un ou plusieurs FPGA ou ASICs et
éventuellement une mémoire commune. Peu de techniques de partitionnement ciblent vers une
architecture hétérogène composée d’un ensemble de processeurs logiciels (microprocesseur,
DSP, ASIP) et matériels (FPGA, ASIC). Hou [HOU-96] propose cependant une heuristique
basée sur la construction progressive de groupes de process (clustering based algorithm) dont
la fonction de coût dépend de la communication inter-processeurs, des temps de commutation
de contexte (approche préemptive et non synchrone) et du taux d’utilisation des ressources. Les
résultats obtenus sont très dépendants des coefficients de la fonction de coût: "the cost function
plays an important role in our partitioning approach" [ERNST-93].
L’architecture générique mono-processeur et constituée d’un ensemble de FPGA
correspond peu à la réalité industrielle. Les composants programmables ont des performances
plus faibles (surface de silicium occupée, fréquence maximale de fonctionnement) et un coût
plus élevé (production en grande série) que les circuit non programmables. De plus, même les
"System on a chip" ne sont pas mono-processeur car ils disposent de plus en plus souvent d’un
coeur de DSP et d’un coeur de microcontroleur (MCU). Ces techniques de partitionnement
automatique ne sont donc intéressantes que pour le prototypage rapide [WENDLING-94] sur
une carte constituée d’un microprocesseur, d’un ensemble de FPGA et éventuellement une
mémoire commune. Mais pour ce type d’application, la rapidité d’obtention d’une
implantation est un critère aussi important que la qualité du partitionnement obtenu: Il s’agit
avant tout de faire une vérification fonctionnelle et non une réelle analyse des performances du
futur produit industriel.
Les techniques de partitionnement automatique souffrent généralement du fait qu’elle ne
prennent pas en compte l’expérience et le bon sens des concepteurs. Dans la réalité industrielle,
le partitionnement d’un système ne pose problème que pour une petite partie du système. Le
concepteur peut facilement faire un partitionnement grossier du système avant de se concentrer
sur les parties délicates. Or les techniques de partitionnement automatique considèrent le
système dans son ensemble et n’utilise pas le fait que le concepteur peut fournir un
Chapitre 2
24 M.C.S.E
partitionnement initial proche de la solution. Elles vont donc balayer un ensemble
d’alternatives inutiles et dans certains cas sont moins efficaces (temps de recherche) qu’un
partitionnement interactif. Inclure le concepteur dans la boucle de recherche de la solution
optimale d’un partitionnement, offre aussi un avantage plus subtil: cela permet d’éliminer la
suspicion des concepteurs face aux résultats obtenus par un partitionnement automatique. En
effet, la nature humaine est ainsi faite qu’elle a souvent tendance à vouloir prouver qu’elle peut
obtenir un résultat meilleur que celui obtenu par une méthode automatique. De plus, le
concepteur a aussi la maîtrise complète de la solution retenue avec toutes ses justifications.
2.2.3 Le partitionnement interactif
Ismail [ISMAIL-94a] [ISMAIL-94b] propose une technique de partitionnement interactive
(PARTIF) permettant de cibler sur une architecture hétérogène. Le concepteur peut aisément
explorer plusieurs alternatives de partitionnement du système en manipulant une hiérarchie
d’automates à états finis concurrents représentée selon le formalisme SOLAR. Un ensemble de
primitives de transformations d’états (déplacement, regroupement, décomposition,...) est
disponible. Cette approche est intéressante mais pour l’instant le concepteur dispose de peu de
résultats quantitatifs en retour pour évaluer la partie logicielle (statistiques sur les
interconnexions et les variables partagées) et la partie matérielle (statistiques sur le nombre
d’états et sur le nombre d’opérateurs de la partie opérative) obtenues de manière à les comparer
aux contraintes imposées.
2.2.4 L’analyse des propriétés d’un partitionnement
Pour analyser les propriétés d’un partitionnement, la plupart des techniques de
partitionnement utilisent des estimateurs basés sur:
- une analyse des contraintes temporelles, ce qui nécessite de représenter le
comportement des fonctions à un niveau interprété et très détaillé. Généralement, le
comportement d’une fonction est représentée sous la forme d’un flot de donnée et d’un
flot de contrôle (CDFG). L’analyse des graphes [WOLF-94] [GUPTA-96] permet
d’extraire une approximation du temps d’exécution de chaque fonction et de vérifier le
respect des contraintes temporelles. Puis pour une implantation logicielle de la fonction,
on applique les algorithmes utilisés dans les problèmes d’ordonnancement des systèmes
temps réels pour calculer la charge du processeur. Formulé sous sa forme la plus simple
(mono-processeur et tâches périodiques), le problème se résoud souvent par
l’algorithme de base RMS "Rate Monotonic Scheduling". Le problème se complique
lorsque les tâches peuvent être sporadiques ou lorsque le système est distribué
[WOLF-94] [MALIK-95].
- une analyse statique basée sur des résultats de techniques de synthèse qui nécessite une
description des fonctions au moins au niveau algorithmique (synthèse haut niveau) pour
extraire des caractéristiques [NARAYAN-92b] telles que la surface de silicium
occupée, la puissance dissipée, le nombre de broches, la taille du programme code, la
taille de la mémoire nécessaire, etc.
Très peu de techniques de partitionnement sont basées sur un modèle plus abstrait et
non-interprété d’un système. Ambrosio [AMBROSIO-94] propose une technique de
partitionnement basée sur un modèle "système". Les processeurs sont représentés par des
Méthodologie de co-design et estimation des performances
M.C.S.E 25
ressources caractérisées par une taille mémoire et le temps d’exécution d’une instruction. La
partie logicielle est représentée par des tâches utilisant une quantité de mémoire et un nombre
d’instructions donné. Romdhani [ROMDHANI-96] propose une méthode de partitionnement
matériel/logiciel où l’évaluation des performances dynamiques du système est effectuée avec
l’outil SES/Workbench.
2.2.5 La méthode de partitionnement proposée
Notre approche consiste à considérer que le partitionnement se fait à un niveau
d’abstraction le plus élevé possible afin de considérer le système dans sa globalité et doit
exploiter au mieux le bon sens et l’expérience des concepteurs. Ainsi impliqué dans le
processus de partitionnement, le concepteur continue à accumuler une expérience et à
développer ses compétences.
Pour élever le niveau d’abstraction des modèles du système, nous n’utilisons pas pour
l’instant d’estimateurs statiques puisque ceux-ci nécessitent une description détaillée et
interprétée du comportement des fonctions. L’évaluation d’un partitionnement repose sur la
simulation d’un modèle des performances du système. Contrairement aux approches
analytiques, la simulation n’est pas limitée par la complexité du système et elle permet
d’obtenir un ensemble d’estimations de performances plus important.
La méthode de partitionnement proposée repose sur la démarche itérative suivante: Compte
tenu des divers critères qui lui sont imposés, le concepteur définit une première architecture
matérielle. Les critères tel que la flexibilité, la testabilité, l’utilisation de composants du
commerce (COTS) ou technologies maîtrisées par l’entreprise, la sûreté de fonctionnement, le
coût et l’expérience du concepteur influent directement sur cette première implantation. Une
fois cette architecture matérielle définie, le concepteur alloue les fonctions à très fortes
contraintes temporelles aux processeurs matériels et le reste des fonctions aux processeurs
logiciels en limitant si possible les communications inter-processeurs. Avec MCSE,
l’alternative logiciel/matériel se détermine par le temps d’exécution approximatif de chaque
fonction et sa fréquence maximale d’activation (hypothèse de tâches périodiques). Puis, la
co-simulation reposant sur la transcription en VHDL du modèle de performance du système
donne en retour des mesures de performances tels que le temps de réponse des fonctions, le
temps de latence de messages, le débit sur un bus ou encore le taux d’occupation d’une
ressource. L’analyse de ces performances permet de vérifier le respect ou non des contraintes
de performances à satisfaire et d’identifier les ressources critiques. Le concepteur modifie alors
l’implantation des fonctions et ressources jugées critiques et réévalue le modèle. Il peut aussi
revenir sur l’architecture matérielle en changeant sa constitution et/ou des caractéristiques de
ses composants.
Dans la plupart des cas, la mise à jour du modèle portera essentiellement sur des attributs
des modèles fonctionnel et architectural et l’allocation des fonctions. En effet, comme nous le
verrons plus tard le modèle de performance étant basé sur le concept d’attribut, une
modification de l’architecture matérielle ne nécessite pas forcément une nouvelle saisie
(graphique ou textuelle) du modèle: l’utilisation de paramètres génériques associés aux
attributs des éléments du modèle de performance permet de parcourir un espace assez vaste des
solutions possibles d’une architecture.
Chapitre 2
26 M.C.S.E
2.3 TECHNIQUES DE CO-SIMULATION
Les problèmes de la co-simulation et du partitionnement matériel/logiciel sont souvent liés.
Par exemple, notre méthode de partitionnement repose sur une co-simulation pour extraire les
performances dynamiques du système puisque le modèle de performance qui est simulé
représente à la fois la partie matérielle et la partie logicielle du système. De plus, une fois le
partitionnement effectué, le concepteur effectue généralement une vérification fonctionnelle
du résultat obtenu. Lors de l’analyse des résultats de cette co-simulation, la détection éventuelle
d’erreurs nécessite un retour vers les phases précédentes et notamment vers la phase de
partitionnement matériel/logiciel. La co-simulation n’est pas la seule technique disponible
pour vérifier la conception et l’implantation d’un système. D'une manière générale,
l'observation des propriétés d'un système peut résulter de 3 techniques différentes: l'évaluation
analytique (méthodes formelle), la simulation, l'observation et la mesure (monitoring) sur un
prototype ou un émulateur.
Le problème de la définition des vecteurs de test ou stimuli et de leur validité est
généralement peu abordé alors qu’il est essentiel. Il faut tenir compte de tous les cas de scénario
de charge du système. Il est bon de noter que pour cet aspect de la co-simulation, notre
approche se distingue par une modélisation du système et de son environnement avec le modèle
de performance de MCSE. Cette approche évite de passer des stimuli au simulateur et permet
surtout de modéliser plus facilement les comportements éventuellement complexes des entités
de l’environnement du système.
2.3.1 La co-simulation
Une co-simulation est une simulation simultanée de la partie logicielle et de la partie
matérielle d’un système et de leurs interactions. Elle est utilisée pour observer le comportement
du système complet qui se compose de quatre classes d’objets: les processeur matériels ou
co-processeur dédiés, les processeurs logiciels, le logiciel s’exécutant sur les processeurs
logiciels et la logique d’interface (communication inter-processeurs).
Un système complet peut être simulé à différents niveaux de détail. Par exemple, un
processeur logiciel peut être décrit comme un ordonnanceur de tâches et le logiciel comme un
ensemble de tâches. Mais le processeur logiciel peut aussi être représenté par une description
architecturale détaillée (pipeline, cache, registre, ALU...) et le logiciel par une séquence
d’instructions du jeu d’instructions du processeur. Généralement, plus le développement est
avancé, plus la co-simulation est détaillée. Au cours du cycle de développement, la
co-simulation repose donc sur différents modèles et vise plusieurs objectifs: elle sert à faire une
vérification fonctionnelle ou comportementale détaillée (modèle interprété), une évaluation
des performances (modèle non interprété) ou les deux simultanément (modèle hybride).
Nous considérons qu’une méthodologie de co-design repose sur l’utilisation de plusieurs
techniques de co-simulation: une co-simulation non-interprétée pour l’analyse des
performances lors de la phase de recherche de l’architecture et du partitionnement matériel/
logiciel, une co-simulation fonctionnelle détaillée après synthèse (ou co-vérification) pour
valider l’implantation. On parle alors de vérification d’un prototype virtuel.
Les techniques de co-simulation se distinguent par l’utilisation d’un modèle ou langage
unique ou non et par le niveau d’abstraction du modèle de description matérielle (VHDL
comportemental, RTL, netlist) et logicielle (C, jeu d’instruction, microcode) [CHANG-95].
Pour les techniques basées sur différents modèles de représentation des parties matérielles et
Méthodologie de co-design et estimation des performances
M.C.S.E 27
logicielles, il faut faire communiquer différents simulateurs (IPC d’unix [THOMAS-93], fond
de paniers de simulateurs, Ptolemy [KALAVADE-95], interface via le bus du microprocesseur
[McCabe-94]). Les techniques mono-modèle se distinguent par le degré d’abstraction du
modèle des processeurs logiciels (modèle d’attributs, modèle flot de ressource, modèle ISA du
jeu d’instructions [BALBONI-95]).
2.3.2 Les techniques multi-langages
Les techniques basées sur des modèles ou langages différents de représentation des parties
matérielles et logicielles, reposent sur la coopération de simulateurs. On parle alors de
simulation hétérogène.
La plupart des projets de co-design (COSMOS du groupe TIMA [ISMAIL-94b]
[LIEM-97], Co-Saw [THOMAS-93]) utilisent une simulation VHDL de la partie matérielle et
l’exécution d’une description algorithmique de haut niveau de la partie logicielle. Le langage
VHDL permet en effet d’intégrer une description écrite dans un langage autre que VHDL grâce
à l’interface Foreign Language Interface (VHDL’93). Il s’agit souvent du langage C avec
lequel a été également écrit le noyau du simulateur VHDL auquel on accède via un ensemble
de primitives spécifiques. L’interface entre l’API du simulateur VHDL et l’environnement de
programmation C (compilateur, debuggeur, etc) utilise des mécanismes de communication
inter-process (IPC d’unix) [THOMAS-93] [VALDER.-95]. Lorsque le simulateur VHDL
reçoit une information de l’exécution de la partie C (socket), il met à jour les signaux concernés
après un délai d’attente qui correspond au temps d’exécution de la partie C. Ainsi, l’exactitude
de la simulation est préservée: "The hardware simulator thus serves as a supervisor, ensuring
that data is accessed in correct order" [GAJSKI-95].
Le processeur logiciel qui est l’élément clef de la co-simulation est souvent représenté sous
la forme d’une machine virtuelle. Cette machine virtuelle peut se décrire à différents niveaux:
système d’exploitation multi-tâches, jeu d’instructions, architecture physique [KUMAR-96].
Dans le projet COBRA [SOININEN-94], la machine virtuelle est modélisée au niveau système
d’exploitation (ordonnanceur de tâches à priorité fixe décrit en VHDL) et le logiciel est
modélisé par un ensemble de tâches écrites en C (couplage avec l’API du simulateur VHDL).
Le plus souvent la machine virtuelle est modélisée par son jeu d’instructions. Dans ce cas, le
logiciel doit être compilé pour le microprocesseur cible. Il n’est pas toujours possible d’obtenir
d’un fabricant de microprocesseurs, un modèle de simulation basé sur le jeu d’instruction du
processeur. Parfois pour protéger la propriété intellectuelle du fabricant, le modèle de
simulation du microprocesseur est uniquement un modèle de bus (bus level model). Un modèle
de bus simule les cycles requis pour une transaction sur le bus (accès en lecture ou écriture)
mais ne modélise pas les actions d’une instruction.
Pour faire communiquer un simulateur HDL (VHDL, Verilog) et un simulateur du jeu
d’instructions d’un processeur, un simulateur de modèle de bus d’un processeur ou l’exécution
d’une description algorithmique de la partie logicielle, on peut également utiliser un fond de
panier de simulateur tel que Ptolemy [KALAVADE-92] ou simMatrix de Precedence Inc.
Enfin, les vendeurs d’outils EDA fournissent aujourd’hui des solutions spécifiques au
problème de la co-simulation (Seamless CVE de Mentor, Eagle i de Viewlogic). Par exemple,
l’outil Seamless CVE de Mentor Graphics permet de synchroniser par une modélisation
particulière du bus du processeur un simulateur du jeu d’instructions du microprocesseur (outil
XRAY de Microtec) et un simulateur VHDL ou Verilog.
Chapitre 2
28 M.C.S.E
L’utilisation d’un simulateur VHDL pour la partie matérielle et éventuellement pour la
partie logicielle augmente sensiblement les temps de simulation. Pour réduire les temps de
simulation, il faut élever le niveau d’abstraction des modèles. Ceci est possible pour une
évaluation des performances mais pas pour une vérification fonctionnelle détaillée. Dans ce
dernier cas, il faut recourir à un émulateur matériel. L’emploi d’un émulateur matériel a
cependant deux inconvénients majeurs:
- les émulateurs sont très chers,
- ils ne permettent d’émuler le système qu’à une fréquence 10 à 100 fois plus faible que
la fréquence nominale de fonctionnement. Par exemple, l’émulation du processeur
MicroSPARCII (Sun) sur le système de prototypage QuickTurn n’a pu s’effectuer qu’à
une fréquence de fonctionnement maximale de 750 Khz.
Pour la co-simulation hétérogène, l’équipe MCSE a expérimenté une technique de
co-simulation basée sur une implantation en Java des éléments de relations du modèle MCSE
(port de communication et variable partagée) pour coupler différents simulateurs
[COUSINS-97]. Cette approche se caractérise par une portabilité multi plate-forme
(l’utilisation de Java permet de cibler sur tout type de plate-forme) et par la possibilité de faire
de la co-simulation distribuée en Intranet (sockets) ou en Internet (applet Java et utilisation du
protocole Remote Method Invocation).
2.3.3 Les techniques mono-langage ou mono-modèle
Les techniques mono-modèle ou mono-langage se distinguent par leur concept de
modélisation et le degré d’abstraction du modèle des processeurs qui varie en fonction de la
finalité de la co-simulation (évaluation des performances et/ou vérification fonctionnelle).
Le processeur logiciel est encore souvent modélisé par son jeu d’instructions et son
architecture qui peut être plus ou moins détaillée (modélisation d’un cache mémoire, pipeline
d’instructions, gestion des interruptions, registres, ALU, etc.). Dans le projet TOSCA
[ANTONIA.-94], un processeur est modélisé pour la description VHDL d’un jeu d’instructions
virtuel et d’une architecture générique qui permettent de cibler sur différents processeurs
spécifiques. Ce type de co-simulation souffre d’un temps de simulation important mais offre
un avantage au niveau de la synthèse logicielle: la qualité du code obtenu en appliquant les
techniques de synthèse (allocation des registres, ordonnancement,...) directement sur un
modèle de jeu d’instructions est meilleur que le résultat obtenu par compilation d’une
description algorithmique de haut niveau tel que le langage C. Dans le projet RASSP, le
processeur est aussi modélisé par son jeu d’instructions [ROSE-95], mais le modèle est plus
grossier, est non-interprété et sert uniquement à l’analyse des performances dynamiques d’un
système (outil Cosmos de Omniview présenté plus loin).
Le processeur logiciel peut aussi être modélisé comme une ressource active caractérisée par
un ensemble d’attributs influençant son comportement temporel. Le système est alors modélisé
soit par un flot de transactions (modèle de SES/workbench [ROMDHANI-96]) soit par un
modèle d’architecture dont tous les éléments sont caractérisés par des attributs temporels tel
que le modèle de performance de MCSE [CALVEZ-96d].
Méthodologie de co-design et estimation des performances
M.C.S.E 29
2.3.4 La technique de co-simulation utilisée
La technique de co-simulation retenue par l’équipe MCSE repose sur la transcription du
modèle de performance de la méthodologie MCSE en une description VHDL et l’utilisation
d’un simulateur VHDL du commerce.
La figure suivante illustre le principe de co-simulation retenu.
-Figure 2.4- Principe de co-simulation retenu.
Le modèle de performance de MCSE décrit sous une forme textuelle ou résultant d’une
saisie graphique sert de point d’entrée à un générateur de code (MCSE-GEN) qui le transforme
en un code VHDL simulable. La simulation du code généré produit un fichier de trace
représentant l'évolution des fonctions et des relations inter-fonctions (mécanismes de
communication et de synchronisation). Ce fichier est alors directement exploitable par un outil
d’analyse de performances (MCSE-PERF) pour la présentation des résultats.
Le modèle de performance capable de modéliser la partie logicielle et la partie matérielle
du système est détaillé dans le chapitre 3. Il s’agit d’un modèle:
- macroscopique: le système n’a pas besoin d’être entièrement détaillé ce qui autorise à
faire une évaluation des performances très tôt dans le cycle de développement.
- non-interprété: seuls les temps des opérations et des dépendances temporelles sont pris
en compte ce qui permet un parcours rapide du domaine des solutions possibles d’un
partitionnement tout en évitant l’écriture des parties algorithmiques des opérations.
- évolutif: la notion d’attributs permet d’enrichir le modèle. L’élément délicat qui est le
processeur logiciel pour la co-simulation, est représenté par sa puissance qui intervient
comme un facteur multiplicatif du temps d’exécution des opérations (attribut ‘Power),
son degré de concurrence (attribut ‘Concurrency), sa politique d’ordonnancement des
tâches (attribut ‘Policy) et son temps de commutation de tâches (attribut ‘Overhead).
Le générateur de code VHDL ne se limite pas à la génération automatique d’un code
non-interprété pour l’évaluation des performances. En effet, en remplaçant le temps des
opérations élémentaires par une description algorithmique on obtient alors un modèle VHDL
interprété qui permet de faire en plus une vérification fonctionnelle du système. Le code
algorithmique des opérations doit alors être saisi manuellement par le concepteur. Mais comme
VHDL est un langage très déclaratif, le générateur produira entre 60-80% du code
Configuration
Fichiers pour la simulation
MCSE-GEN MCSE-SIM Resultats
MCSE-PERF
Modèle MCSE
VHDL VHDL
Trace
Ordre de l’utilisateur
de la trace
Controle du simulateur
Chapitre 2
30 M.C.S.E
automatiquement car il se charge de traduire toute l’organisation (ou composante structurelle)
du modèle.
Une autre technique de co-simulation est également en cours de développement dans
l’équipe MCSE. Il s’agit de transcrire le modèle de performance en un code C++ et d’obtenir
les résultats par exécution du programme C++. Cette technique a été testée sur l’exemple du
système de communication présenté dans le chapitre 7 et a permis de constater une réduction
des temps de simulation d’un facteur 4 environ par rapport à l’utilisation d’une simulation
VHDL.
2.4 GENERATION DE CODE
Compte tenu de la solution décrite dans le paragraphe précédent, le problème de la
co-simulation devient un problème de génération de code. Il s’agit de transcrire le modèle
textuel MCSE en un langage cible (VHDL, C++). Pour réaliser cette transformation de textes,
le premier travail du développeur d’un générateur consiste en la définition des règles de
transcription. Ce travail pour le langage VHDL fait l’objet du chapitre 4. Ensuite, il s’agit de
choisir la technique à utiliser pour effectuer les transformations de textes. Dans les paragraphes
suivants, nous passons en revue différentes solutions. La solution retenue par l’équipe est
particulière et sera détaillée dans les chapitres 5 et 6.
Pour manipuler du texte, on peut utiliser des langages dédiés à la manipulation de texte ou
utiliser un générateur d’analyseur syntaxique.
2.4.1 Les langages dédiés à la manipulation de texte
Ces langages interprétés (Perl et awk par exemple) sont utilisés pour extraire des
informations d’un texte source et les reformatter. Contrairement à awk, Perl (Pratical
Extraction and Report Language) permet d’utiliser des hashtables très utiles pour trier et
rechercher des informations selon des mots clés.
Ces outils sont optimisés pour générer de la documentation à partir d’un modèle textuel. Par
contre, comme ils utilisent seulement un buffer de ligne (pas de structure interne complète de
stockage) et que l’accès au fichier source est séquentiel, ils sont peu appropriés pour notre
problème car les transformations sont complexes.
2.4.2 Technique des compilateurs
Les compilateurs de code utilisent un analyseur lexical et un analyseur syntaxique.
Le code source est décomposé en unités significatives appelées tokens. L’outil réalisant
cette décomposition en différentes unités s’appelle un analyseur lexical (ou scanner). Des
expressions régulières définissent les tokens à reconnaître et l’analyseur lexical est souvent
implanté par une machine à états finis.
Les relations possibles entre les différentes unités significatives d’un langage constituent
les règles grammaticales de ce langage. Une grammaire dite libre de tout contexte définit les
phrases correctes. La syntaxe d’entrée est souvent au format BNF (Backus Naur Form). L’outil
réalisant la vérification grammaticale d’un texte s’appelle un analyseur syntaxique (ou parser).
Le principe de fonctionnement est le suivant: l’analyseur lexical envoie une par une les unités
à l’analyseur syntaxique qui les stocke (utilisation d’une pile) jusqu’à ce qu’une règle
grammaticale soit complète. Par défaut, lorsqu’une règle est complétée, l’analyseur syntaxique
Méthodologie de co-design et estimation des performances
M.C.S.E 31
désempile les unités concernées et empile le symbole (ou unité) correspondant à la règle réduite
(on parle de réduction car le nombre d’éléments stockés dans la pile a diminué). A chaque
réduction de règle, on peut associer une action permettant par exemple de produire ou
compléter une structure de données: la structure de données est alors construite au fur et à
mesure de la vérification syntaxique. Elle se termine quand l’analyseur lexical n’émet plus
d’unités et que la pile de l’analyseur syntaxique est vide.
Les analyses lexicale et syntaxique ne constituent que la phase d’analyse d’un compilateur,
phase qui est ensuite suivie par une phase de synthèse pour la production du code cible. La
structure traditionnelle d’un compilateur est la suivante.
-Figure 2.5- Structure traditionnelle d’un compilateur.
Généralement la structure de donnée interne s’appelle un "parse tree" ou encore
"intermediate code representation". Cette structure interne peut alors être interprétée (cas d’un
interpréteur) ou transcrite en un langage cible (cas d’un compilateur). L’outil MetaGen
présenté dans le chapitre 5 est capable de fonctionner dans les deux modes: interpréteur du
langage Script et compilateur du langage Script en code Java. Pour un compilateur classique,
elle est utilisée pour faire des contrôles sémantiques (vérification du type des opérandes par
exemple), une optimisation et une génération de code (optimisation du code, analyse du flot de
donnée et allocation des ressources).
Il existe dans les domaines universitaire et commercial un certain nombre d’outils qui
regroupent un générateur d’analyseur lexical, un générateur d’analyseur syntaxique et de
structure interne et une interface de programmation (API C/C++). On peut citer par exemple
PCCTS, SORCERER, Gentle Compile-Compiler et Eli Compiler Construction System
[GRAY-92]. Ces outils se distinguent par le format de spécification de la grammaire et
l’algorithme d’analyse syntaxique utilisé. Eli Computer Construction System est le plus
complet car il fournit également des outils pour les phases d’optimisation et de génération de
code.
Analyse Lexicale (Scanner)
Analyse Syntaxique (Parser)
Analyse Sémantique
Structure de Donnée Interne (Parse Tree)
Optimisation de Code
Génération de Code
Langage Source
Langage Cible
Analyse
Synthèse
(Back-End)
(Front-End)
Interpréteur
Chapitre 2
32 M.C.S.E
Certains outils de ce type sont en plus capables de générer un éditeur orienté par la syntaxe.
C’est le cas de LEdit de Parallax et de Synthesizer Generator [REPS-88] de la société
GrammaTech.
2.4.3 Technique retenue pour la génération de code
La technique que nous avons développée pour la génération utilise un analyseur lexical et
syntaxique et repose sur deux concepts: le concept de méta-modèle et le concept de template.
Un méta-modèle est un modèle de modèle. Par exemple, le langage de définition de langage
Backus Naur Form (BNF) est un méta-modèle puisqu’il permet de spécifier des grammaires
qui constituent déjà un modèle de texte.
Le terme "template" représente ici un fichier écrit dans le langage cible souhaité et
contenant toutes les constructions nécessaires pour la translation texte à texte. Il s’agit d’un
modèle générique du résultat attendu.
La structure interne construite à partir d’un fichier texte par un analyseur syntaxique, est le
coeur du générateur à concevoir. Pour que notre générateur soit indépendant des langages
source et cible, il faut que cette structure soit construite selon un modèle générique. Nous avons
pour cela défini le méta-modèle de toute structure de données. La réponse a été trouvée tout
simplement dans le formalisme BNF. En effet, une grammaire se décrit elle même selon une
grammaire qui est alors appelée méta-grammaire. Or, le formalisme BNF spécifie une
grammaire uniquement à l’aide de quatre éléments de base que sont:
- la séquence d’éléments (Y := A B C),
- l’optionel (Y := [ A ]),
- l’alternative (Y:= A | B | C),
- la liste ou ensemble (Y := {A})
Dans la littérature sur la modélisation des données, on retrouve d’ailleurs sous diverses
formes, un modèle dit de composition hiérarchique basé sur les opérateurs de composition,
alternative et ensemble [CALVEZ-90]. Par analogie et pour la compréhension du lecteur, un
programme peut s’écrire uniquement à l’aide des trois structures de contrôle que sont la
séquence, l’itération et la sélection. On s’aperçoit que l’élément optionnel du méta-modèle de
donnée a disparu. Ceci est normal car le modèle de composition hiérarchique est le modèle
d’une structure de donnée qui est une instance de notre méta-modèle et pour laquelle l’élément
optionnel est remplacé soit par la valeur A soit par l’élément nul.
Dans un premier temps, notre principe de génération reposait uniquement sur les concepts
de méta-modèle et de template. Le principe était le suivant: Le générateur charge sous la forme
de structure interne le texte source et le fichier template. Puis, la production de la structure de
sortie consiste à parcourir la structure de données du modèle source, copier des parties de la
structure du template puis les mettre à jour. La figure 2.6 illustre le principe de génération de
code.
En prenant du recul par rapport à cette figure, nous avons pu trouver un principe général
applicable pour tous les générateurs de code ou même de texte. Il est possible de spécifier de
l’extérieur de l’outil les transformations à faire sur la structure de donnée interne pour obtenir
le résultat escompté en sortie. Pour cela, nous avons développé le concept de Script qui est un
langage de description des manipulations à effectuer sur les structures de données
Méthodologie de co-design et estimation des performances
M.C.S.E 33
[CALVEZ-98b]. Comme le script est un texte, il est à son tour analysé et chargé sous la forme
d’une structure de données. L’exécution du script est alors le résultat d’un automate de
parcours de la structure de données du script et d’exécution des opérations élémentaires qu’il
spécifie. Un générateur est donc le résultat de l’écriture d’un script fourni à un programme
(automate d’exécution). Nous avons appelé ce programme MetaGen. Il est décrit dans le
chapitre 5.
-Figure 2.6- Principe de la génération de code.
Le méta-générateur MetaGen est aussi capable de transcrire automatiquement le script
correspondant à un générateur en un programme JAVA équivalent. Cette possibilité est très
intéressante pour produire un générateur plus rapide que l’interprétation du script par le
méta-générateur. Le choix du langage JAVA pour l’implantation offre un certain nombre
d’avantages et notamment la garantie d’avoir un outil multi plate-forme.
Dans la plate-forme d’outils en cours de développement pour la méthodologie MCSE, le
modèle de performance de MCSE est ou doit être transcrit vers différents langages cibles:
VHDL comportemental ou C++ pour l’évaluation des performances (partitionnement et
co-simulation), VHDL de niveau RTL pour la synthèse matérielle et C avec l’emploi d’un
exécutif temps-réel pour la synthèse logicielle.
Comme tous ces générateurs utilisent le même modèle d’entrée et sont (ou seront) décrits
par un script, il est apparu judicieux de décomposer tous les scripts en une partie analyse du
modèle source et une partie génération. Le chapitre 6 sur le générateur VHDL pour les
performances décrit une partie analyse qui a été développée de façon suffisamment générique
pour qu’elle soit commune à tous les générateurs. La difficulté repose alors sur la sélection des
informations pertinentes pour la génération et le choix de l’emplacement des appels des règles
de génération. La qualité de la partie analyse est importante car elle conditionne la partie
génération et influe directement sur l’efficacité et la qualité d’écriture d’un générateur.
Modèle
MCSE
Modèle
Générique du code
Parcours
Analyse
Analyse et
Transformation
Sauvegarde Ascii
Analyse
Code
Généré
à générer
Syntaxique Syntaxique
Ordonné
Reverse-Coding
possible
Copie
Chapitre 2
34 M.C.S.E
2.5 MODELISATION DES PERFORMANCES DES SYSTEMES
Les paragraphes qui suivent ont pour but de répondre à la question suivante: pourquoi avoir
défini un nouveau modèle de performance alors qu’il existe déjà un éventail assez large de
modèles de performance? Nous commencerons par décrire les principaux modèles de
performances existants et les outils les plus représentatifs qui leur sont associés. Puis pour
conclure, nous justifierons le développement d’un nouveau modèle de performance lié à la
méthodologie MCSE et approprié à la problématique du co-design.
2.5.1 Catégories de modèles de performance
Tout modèle est construit sur la base d’un ensemble de concepts de modélisation.
L’efficacité d’un modèle dépend directement de ces concepts: l’ensemble des concepts de
modélisation doit être restreint mais suffisant pour décrire n’importe quel système pour le
domaine concerné. Pour mieux interpréter les différences existant entre les modèles de
performance qui vont être présentés dans ce chapitre, considérons l’espace de modélisation
tri-dimensionnel représenté par la figure 2.7 [CALVEZ-96d].
-Figure 2.7- Espace de modélisation des systèmes.
La classification des modèles pour les systèmes électroniques se fait selon trois axes:
- l’axe des niveaux de description, qui représente les degrés d’abstraction possibles pour
la description des solutions intermédiaires entre le besoin et le produit final. Les niveaux
habituellement considérés sont: le niveau système ou spécification, le niveau
fonctionnel, le niveau architectural, le niveau logique et/ou physique,
- l’axe de représentation, qui considère les différents types de modèles utilisables pour
la description. Trois modèles, chacun exprimant un point de vue, sont usuels : le modèle
structurel, le modèle comportemental, et le modèle donnée ou objet,
- l’axe d’interprétation, qui représente le niveau de détail du modèle.
Interprétation
interprété
non-interprété
Abstrait
Concret
Spécification
niveau fonctionnel
niveau architectural
niveau physique
Niveaux de description
Comportement Structure Donnée/Objet Représentation
1 2
Méthodologie de co-design et estimation des performances
M.C.S.E 35
Une séparation nette apparaît sur l’axe Interprétation entre :
- les modèles non-interprétés pour lesquels seul le comportement ou les dépendances
temporelles entre les sorties et les entrées sont observées. Les valeurs en entrée et celles
des données internes ne sont pas prises en compte. Les entrées et les données internes
influencent le comportement du système uniquement par l’intermédiaire d’attributs. Par
exemple, les attributs Size (taille) et Id (destinataire) d’un message remplace le contenu
du message.
- et les modèles interprétés pour lesquels les valeurs des données sont considérées. Ces
modèles décrivent un comportement fonctionnel représenté le plus souvent sous la
forme d’un flot de données et d’un flot de contrôle.
La zone grisée de la figure 2.7 correspond à la zone de modélisation que nous estimons utile
pour l’évaluation des performances. Un modèle approprié pour l’évaluation des performances
est de type non-interprété. Il doit associer la vue structurelle pour représenter la décomposition
ou l’organisation du système et la vue comportementale pour décrire les propriétés temporelles
de chaque constituant.
Sur la figure 2.7, il y a également une séparation nette entre un modèle de structure et un
modèle de comportement. Le premier est une description spatiale ou topologique du système.
Le second est une description temporelle. Pour modéliser un système complexe, les deux types
de modèle sont nécessaires et complémentaires. De plus, un modèle de comportement peut se
remplacer par un modèle de structure lors d’une opération de raffinement et réciproquement un
modèle de structure peut se remplacer par un modèle de comportement lors d’une opération
d’abstraction. Dans le formalisme utilisé par la méthodologie MCSE, la vue structurelle
regroupe la vue fonctionnelle et la vue architecturale ou exécutive.
Enfin, un modèle de performance peut être élaboré et utilisé pour trois niveaux de
description: les spécifications (étude de faisabilité), la conception fonctionnelle
(dimensionnement des éléments internes du système) et la conception architecturale (aide au
partitionnement logiciel/matériel).
Selon l’approche de modélisation que doit faire le concepteur, les modèles de performances
peuvent être classés en deux catégories:
- le modèle de flot de transaction basé sur la modélisation des files d’attentes et/ou les
réseaux de Petri: modèle UVa, SES/WorkBench, Bones... Ces modèles ont l’avantage
de s’appuyer sur un formalisme mathématique qui dans certains cas permet d’extraire
des informations sans qu’une simulation dynamique soit nécessaire.
- le modèle d’architecture: RD100, Cosmos de Omniview appelé encore récemment
Performance Modeling WorkBench. Le modèle UVa est aussi un modèle d’architecture
mais il s’appuie également sur le formalisme des réseaux de Petri pour le comportement
de chaque bloc.
2.5.2 Modélisation par réseau de files d’attente
Le modèle basé sur la théorie des files d’attente [BORDEW.-93] se compose:
- d’une source d’événements ou jetons (source) caractérisée par une distribution
(Uniforme, Normale, Erlang, Poisson, etc...),
- une file d’attente caractérisée par sa taille et sa discipline de stockage (LIFO, FIFO),
Chapitre 2
36 M.C.S.E
- des serveurs caractérisés par un temps de service (fixe, uniforme ou exponentiel),
- des mécanismes de synchronisation: la divergence (fork) caractérisée par une loi de
distribution et le regroupement (join).
- d’un mécanisme d’élimination du jeton (sink).
La figure 2.8 représente un exemple de modélisation d’une architecture de processeurs
distribuée [MOHANTY-94].
-Figure 2.8- Modélisation par réseau de files d’attente d’une architecture parallèle.
Dans ce modèle, un utilisateur est représenté par une transaction (ou jeton) qui accède au
processeur par l’intermédiaire d’une file d’attente. Le nombre d’utilisateurs est fixe et doit être
inférieur à la taille des files d’attente. Une fois que le processeur a effectué le travail désiré, la
transaction accède aléatoirement à l’un des deux disques du système modélisés comme le
processeur par la combinaison d’une file d’attente et d’un noeud de service. Puis la transaction
passe par un service d’affichage (probabilité p) ou retourne directement au début du réseau.
Ce type de modélisation permet d’obtenir le taux d’utilisation des processeurs, la taille
moyenne des files d’attente, le temps moyen de service, le temps moyen d’attente pour un
service, le temps total passé par une transaction dans le système, etc.
2.5.3 Réseau de Petri stochastique
Ce modèle est également basé sur un principe de jetons: une transition n’est franchissable
que si toutes les places précédentes possèdent au moins 1 jeton, et lorsqu’elle est franchie, un
jeton est retiré de toutes les places en amont et un jeton est ajouté dans toutes les places en aval.
Il permet donc de contrôler les cycles, de détecter l’existence de blocages éventuels et de
s’assurer que tous les états sont atteignables. Pour étendre l’usage des réseaux de Petri
classiques à l’évaluation de performances temporelles, un paramètre temps leur a été associé:
- soit au niveau des transitions, ce qui permet alors d’exprimer l’intervalle temporel
d’exécution de la transition.
- soit au niveau des places. Dans ce cas, une transition n’est franchie que si toutes les
places précédentes sont marquées et si le temps associé à chacune est écoulé.
Les réseaux de Petri ont donc été étendus (Extended Timed Petri Net) avec un attribut de
durée pour faciliter l’étude du comportement temporel d’un système. Lorsque cette durée
dépend d’une loi aléatoire, le réseau de Petri est appelé réseau de Petri stochastique.
Méthodologie de co-design et estimation des performances
M.C.S.E 37
Une approche de modélisation, d’évaluation des performances et de co-synthèse des
systèmes matériel/logiciel basée sur l’utilisation des réseaux de Petri étendu (ETPN) est
présentée dans [STOY-94]. Les réseaux de Petri représentent le flot de contrôle et le flot de
données des parties matérielles et logicielles. La simulation des réseaux de Petri permet de
vérifier le respect des contraintes temporelles et de faire une évaluation des performances du
système. Cette évaluation des performances est alors utilisée par une heuristique et une
fonction de coût pour réaliser le partitionnement matériel/logiciel. Puis, un outil de synthèse
haut niveau nommé CAMAD transforme les réseaux de Petri en une netlist pour l’implantation
en matériel et en un programme C pour l’implantation en logiciel. Le nombre d’états et de
transition croit très rapidement en fonction de la complexité du système étudié. L’approche
proposée par Stoy est donc surtout intéressante pour les systèmes de faible complexité.
Les deux modèles précédents s’appuient sur un formalisme mathématique qui peut devenir
rapidement complexe lorsque la taille de l’application augmente. De plus, l’évaluation
analytique n’est possible que sur une classe limitée de systèmes et ne permet pas d’analyser
correctement ou facilement un certain nombre de constructions tels que:
- les politiques d’ordonnancement avec priorité,
- les ressources passives (disques, mémoire),
- les mécanismes de synchronisation (join, fork),
- les protocoles de communications complexes (et non une simple transition de jeton),
- les interruptions,
- les requêtes d’accès simultanés à une ressource.
C’est pourquoi, la plupart des outils d’analyse de performances basés sur ces modèles
utilisent principalement la simulation et non l’évaluation analytique pour faire une estimation
des performances. Il existe de nombreux outils spécifiques aux réseaux de files d’attente et/ou
aux réseaux de Petri stochastiques: TimeNet [KELLING-95], QNAP2, Bones, SimScript. Ces
outils se composent généralement d’une interface graphique pour la modélisation et
l’animation des réseaux, d’un langage algorithmique de haut niveau pour décrire le
comportement de certains noeuds et d’un générateur de code automatique à partir de la
description graphique et algorithmique. Basé uniquement sur un flot de transaction ou jeton,
ces modèles sont moins appropriés que les modèles d’architecture pour étudier les
performances d’un partitionnement logiciel/matériel car ils ne permettent pas de représenter la
vue structurelle du système.
2.5.4 Modélisation d’architectures
Ces modèles permettent de décrire un système selon deux vues:
- une vue structurelle qui décrit le système sous la forme d’une interconnexion de
constituants,
- une vue comportementale qui permet de décrire le comportement de chaque constituant.
Des attributs sont associés aux constituants et aux éléments de description
comportementale pour permettre l’étude du comportement temporel du système.
Le modèle d’architectures est un modèle naturel pour le concepteur. Offrant une séparation
plus nette entre la partie matérielle et logicielle du système, il est aussi mieux adapté au
Chapitre 2
38 M.C.S.E
co-design que le modèle de transactions qui est surtout utilisé pour l’analyse de solutions
existantes.
2.6 PANORAMA DES MODELES ET OUTILS DE PERFORMANCES
Dans ce paragraphe, nous présentons succinctement les outils les plus représentatifs ou les
plus utilisés des modèles de flot de transactions et d’architectures. Pour chaque outil de cette
liste non exhaustive, on s’intéresse plus aux propriétés des modèles de performances
considérés qu’aux caractéristiques de l’outil support.
2.6.1 SES/Workbench
SES/workbench est un environnement de simulation vendu par SES (Scientific and
Engineering Software Inc). Il permet de modéliser des systèmes complexes et de faire une
évaluation des performances [SES-89].
Le modèle est spécifié graphiquement par une hiérarchie de graphes composés d’un
ensemble de noeuds auquels on peut éventuellement associer une forme graphique et des
méthodes écrites en C. Le principe de description repose sur l’évolution d’une transaction à
travers les divers noeuds d’un graphe.
Un ensemble de librairies de noeuds prédéfinis est disponible. Une des librairies dédiée à
l’analyse de l’architecture des systèmes regroupe des noeuds pour modéliser:
- la gestion de ressources: service, ressource, retards, allocation et désallocation, etc. Le
noeud de service est constitué d’une file d’attente et d’un temps de traitement. Comme
il est possible de définir la politique d’ordonnancement des transactions (préemptif,
non-préemptif, temps partagé,...) et le temps de commutation (overhead), ce type de
noeud permet de modéliser un processeur logiciel ou une ressource active. Le noeud de
ressource (réservoir de jeton) permet de modéliser une ressource passive telle qu’une
mémoire, un bus, etc.
- le contrôle du flot de transactions: source, destruction, boucle, divergence, jonction,
interruption, reprise d’activité, etc.
Pour illustrer le modèle, la figure 2.9 décrit un exemple qui montre clairement que la
description suit le chemin parcouru par une transaction.
-Figure 2.9- Exemple de modélisation sous SES/Workbench.
New_Work
+ -
Get_memory
Disk1
Disk2
Cpu
not finished
Release_memory
Exec End_Work
Source Allocation Service
Désallocation
Réference
Destruction
Rafinement
Méthodologie de co-design et estimation des performances
M.C.S.E 39
La technique d’évaluation repose sur l’exécution d’un programme en C++ généré à partir
des descriptions graphiques et algorithmiques du modèle. L’outil permet d’animer la
modélisation (flot de transactions) et de générer (API et langage de requêtes) des rapports
statistiques (valeur min, max, moyenne, histogramme de fréquence,...) sur les performances
des divers noeuds du modèle.
Romdhani [ROMDHANI-96] a utilisé SES/Workbench pour faire une évaluation des
performances dynamiques d’un système lors d’un partitionnement matériel/logiciel. Il
modélise en parallèle un flot de données (axe fonctionnel) décrivant les transformations sur les
données et un flot de contrôle décrivant les ressources utilisées (axe architectural). La
synchronisation entre les deux flots est réalisée à l’aide de noeuds du type "Interrupt Node" et
"Resume Node". Le système est alors décrit sous la forme d’une partie opérative et une partie
contrôle dans lesquelles la vue fonctionnelle et la vue architecturale sont complètement
amalgamées. Par conséquent, même si l’architecture matérielle cible est figée, une
modification de l’allocation d’une fonction nécessite au minimum de redessiner le flot de
données, ce qui est plutôt contraignant lorsque l’on doit parcourir un domaine assez vaste des
solutions possibles.
Le modèle de SES/wokbench est plus riche en concepts de modélisation que le modèle de
performance que nous avons développé. A ce titre, il est capable de modéliser n’importe quel
modèle de performance MCSE. Mais la différence essentielle entre les deux modèles réside
dans l’approche de modélisation. SES/workbench est orienté flot de transactions: le concepteur
décrit explicitement le chemin suivi par chaque transaction et les ressources qu’elle utilise.
L’absence de dimension structurelle stricte (zone 2 de la figure 2.7) a au moins deux
conséquences. En premier, la méthode de modélisation est différente de celle utilisée par les
concepteurs en co-design (description du modèle fonctionnel, puis du modèle architectural et
allocation), ce qui implique un surcoût de temps pour exploiter les concepts de SES et obtenir
les résultats appropriés. En second, il n’y a pas continuité du modèle d’une phase de conception
à l’autre: un nouveau modèle doit être réécrit à chaque étape de conception. En effet, avec ce
modèle, la description d’une phase de conception ne peut pas être enrichie ou détaillée en
remplaçant le modèle comportemental d’un composant par son raffinement structurel. L’outil
est donc très efficace pour faire une analyse des performances d’un système figé ou existant,
mais convient nettement moins pour une démarche de modélisation incrémentale et pour
l’exploration du domaine des solutions possibles lors d’un partitionnement logiciel/matériel.
Sous l’impulsion du projet RASSP, SES/Workbench est maintenant capable de générer du
code C et du code VHDL. L’outil offre aussi une interface de co-simulation appelée SES/
Co-sim. Elle permet au simulateur de SES/Workbench de communiquer avec n’importe quel
autre processus unix externe (simulateur par exemple). L’interface définit les données à
échanger et le mode de synchronisation.
2.6.2 Le modèle UVa/ADEPT
SES/Workbench et ADEPT sont relativement proches car ils sont tous les deux basés sur
un principe de modélisation par flot de transactions.
Chapitre 2
40 M.C.S.E
Le modèle UVa est présenté dans [AYLOR-92]. Il génère un programme VHDL simulable
à partir d’un ensemble de blocs prédéfinis ou composants spécialisés. Ces blocs ont chacun un
comportement décrit par un réseau de Petri écrit en VHDL. L’interconnexion entre ces blocs
se fait par un passage de jeton selon un protocole de communication du type rendez-vous. Une
couleur est associée au jeton. Ce concept de couleur caractérise le modèle comme étant non
interprété et est proche du concept d’attribut associé aux échanges d’information de notre
modèle MCSE.
Pour l’évaluation des performances, les blocs prédéfinis sont classés en trois groupes
principaux. Il y a tout d’abord les modules de contrôle (19 différents): ils agissent uniquement
sur l’état du jeton. Il y a par exemple les “Source”, les “Sink”, les “Switch” ou les "Junction".
-Figure 2.10- Exemple de modules de contrôle du modèle UVa.
Il y a ensuite les modules de gestion des couleurs (9). Ils n’agissent que sur la couleur:
lecture, modification, comparaison, addition et soustraction. Il y a par exemple les modules
“Read Color”, “Set Color” ou “Comparator”.
-Figure 2.11- Exemple de modules de gestion des couleurs.
Il y a enfin les modules Délais (4). Il y a par exemple “Fixed Delay” qui fournit toujours le
même retard, “Dependent Delay” qui introduit un délai dépendant de la couleur du jeton et
“Random” qui introduit des délais aléatoires.
-Figure 2.12- Exemples de modules de Délai.
La plupart des blocs ont un comportement non-interprété. Mais le modèle comporte aussi
des blocs d’analyse de fautes (13), de collecte d’informations (4), et des blocs hybrides (7) qui
permettent de connecter au modèle des descriptions comportementales (modèle interprété).
Ainsi, le modèle UVa permet d’analyser la tolérance aux fautes et la sûreté de fonctionnement
d’un système. La description d’une architecture avec ce modèle se fait à l’aide d’un outil
ADEPT [KUMAR-94] basé sur l’utilisation d’outils graphiques de CAO (Mentor Graphics
Design Architect). La vérification fonctionnelle et l’évaluation des performances est faite par
simulation du programme VHDL. Les possibilités d’évaluation sont importantes car il est
possible d’observer l’état de chaque bloc et de chaque jeton.
Signaux de données
Signaux de contrôle
SO
Source
OUT_1
SI
Sink
IN_1
SW
Switch
IN_1 OUT_1
IN_C1
OUT_1
IN_1
IN_2 J
Junction
RC
Read Color
IN_1 OUT_1
OUT_C
SC_D
Set Color
IN_1 OUT_1
IN_C
CP
Comparator
IN_1 IN_2
OUT_C
FD
Fixed Delay
IN_1 OUT_1
DD
Dependent Delay
IN_1 OUT_1
R
Random
IN_1 OUT_1
Méthodologie de co-design et estimation des performances
M.C.S.E 41
Le modèle est surtout un modèle structurel (zone 2 de la figure 2.7). La description se fait
à un niveau d’abstraction beaucoup moins élevé que celui des spécifications et des descriptions
comportementales. Par conséquent, le concepteur doit faire un effort important pour trouver
l’architecture basée sur les blocs disponibles même s’il veut simplement analyser un système
à un niveau fonctionnel abstrait. La comparaison avec notre modèle de performance est
similaire à la distinction qui existe entre la description comportementale de haut-niveau d’un
circuit et sa description architecturale basée sur des registres, additionnneurs, compteurs, etc.
Par exemple, dans [KUMAR-94], l’auteur présente la modélisation d’un cache mémoire qui a
nécessité pas moins de 2000 blocs.
A notre point de vue, un modèle non accompagné d’une démarche favorisant l’élaboration
de solutions n’est pas suffisant. Récemment, l’université de Virginie a pris conscience de la
nécessité d’avoir une démarche système: "a local optimization made at the structural level of
Design may have a detrimental effect on overall system performance" [KUMAR-96]. Elle a
alors développé une méthodologie complète de conception appelée ISPME (Integrated
Specification and Performance Modeling Environment). Cette méthodologie repose sur
l’association du modèle de "StateChart" pour couvrir les phases de spécification et conception
fonctionnelle et du modèle UVa pour la conception architecturale et l’évaluation des
performances. L’utilisation de modèles hybrides a pour but de faciliter la transition d’une phase
de conception à une autre.
Pour mieux répondre à la problématique du co-design et du partitionnement logiciel/
matériel, le modèle UVa a également été enrichi du concept de machine virtuelle
[KUMAR-92] [KUMAR-96] dont le principe est schématisé par la figure suivante.
-Figure 2.13- Principe de co-simulation avec le modèle UVa.
Pour modéliser l’exécution du logiciel sur un processeur, le modèle UVa a été enrichi de
noeuds de process représentant une transformation sur les données et de noeuds de
branchement conditionnels. Chaque bloc F utile pour modéliser l’aspect fonctionnel possède
une entrée/sortie supplémentaire pour l’asservir à un noeud de ressource.
La machine virtuelle représentant le processeur logiciel est composée d’un étage de
recherche et décodage d’instruction, d’une mémoire de stockage et d’un ensemble de branches
d’exécution. Le nombre de flots d’exécution représente le degré de parallélisme du processeur.
Une branche est un flot d’exécution composé de noeuds de ressource qui peuvent être actifs
F
F
N
N
F
F
TRUE FALSE
TRUE
FALSE
EL
E
ME
NT
S
DE
R
OUT
A
GE
MEMOIRE
FETCH
EXECUTE1
EXECUTEN
Modèle logiciel Modèle matériel
Delai
Machine Virtuelle
Chapitre 2
42 M.C.S.E
(noeud de service avec file d’attente) ou passifs (unité arithmétique et logique). La machine
virtuelle permet donc l’exécution simultanée de plusieurs tâches ou opérations logicielles.
Mais, les délais d’attente ne sont pas préemptibles et il n’y a pas d’ordonnanceur associé à la
machine virtuelle, ce qui réduit son intérêt pour les modélisations multi-tâches.
L’université de Virginie et Honeywell Technology Center ont travaillé en commun sur
l’évaluation des performances dans le cadre du projet RASSP. Un couplage entre les deux
modèles de performances a été réalisé: les blocs hybrides [KUMAR-97] permettent en effet de
relier le modèle UVa avec le modèle de performance de Honeywell Technology Center qui fait
partie de l’outil Cosmos de Omniview.
2.6.3 RDD 100
RDD100 est un outil de la société Ascent Logic Inc [ALFORD-91] [ALFORD-92]. Il
permet la saisie du cahier des charges, l’élaboration des spécifications, l’analyse fonctionnelle
et la décomposition physique des systèmes. L’outil a d’abord été développé pour décrire et
évaluer les spécifications d’un système dans le domaine de l’ingénierie système. Bien connu
dans ce domaine d’application, il a ensuite été enrichi pour couvrir la phase de conception
fonctionnelle (modèle interprété) et la phase de définition de la réalisation comportant la
définition de l’architecture matérielle et l’allocation des éléments fonctionnels sur cette
architecture. Basé sur différents formalismes, il a été développé en tenant compte de
recommandations et standards de principe d’ingénierie système tel que la norme IEEE1220.
Un des points caractéristiques de cet outil est son efficacité de gestion de la traçabilité
d’une exigence des spécifications jusqu’aux tests d’implantation [PENCOLE-96]. Cette
efficacité est due à la base de données de RDD100 construite sur le modèle
Entité-Relation-Attributs (ERA). Ce modèle de description permet de représenter l’application
en terme d’entités, leurs attributs et les relations (ou associations) entre ces entités. Une entité
est un objet conceptuel pour le système. Il peut s’agir d’un objet physique ou fonctionnel. Les
entités sont regroupées par type d’entités (catégorie). Chaque type d’entité possède ses propres
attributs (ou propriétés), qui permettent de différencier les entités entre elles.
-A- Analyse des exigences et Spécification
Le modèle ERA est bien adapté pour décrire les constituants d’un système. Pour faciliter la
description du comportement du système vis à vis de son environnement, le modèle ERA de la
base de données a été enrichi avec les concepts de l’approche objet, tel que:
- l’agrégation (démarche ascendante)/décomposition (démarche descendante) qui permet
éventuellement de définir des structures récursives,
- la généralisation/spécialisation derrière laquelle se trouve la notion d’héritage.
Les entités peuvent être représentées selon plusieurs vues (saisie graphique et textuelle). La
cohérence entre les différentes vues est gérée par l’outil de manière transparente pour
l’utilisateur. Le formalisme utilisé est proche de celui de la méthode OMT ou plutôt de la
méthode unifiée puisque lors de l’analyse fonctionnelle on retrouve également un concept
proche de celui du concept de scénario (ou Use Cases au sens de Jackobson) qui permet
d’associer un comportement ("Behavior Diagram") aux entités (ou objets).
-B- Analyse fonctionnelle
Pour réaliser une analyse fonctionnelle, 3 points de vue sont à considérer: le point de vue
structurel (topologie du système), le point de vue des données (flot de donnée) et le point de
Méthodologie de co-design et estimation des performances
M.C.S.E 43
vue comportement (évolution temporelle ou flot de contrôle). RDD100 permet de représenter
simultanément ces trois points de vue en un seul diagramme appelé "Behavior Diagram". Un
"Behavior Diagram" est constitué d’un ensemble de fonctions. Les fonctions consomment et
produisent des données. Elles peuvent s’exécuter en séquence ou en parallèle. Les
constructions de type itération, boucle, sélection, réplication, décomposition, agrégation sont
autorisées.
Parmi les données échangées, on trouve les messages et les variables d’état. Les messages
permettent de contraindre l’activation d’une fonction et donc de contrôler son comportement.
Les variables d’état permettent de mémoriser l’état d’une fonction.
Le figure 2.14 représente un exemple simple de modélisation. Sur cette figure deux
fonctions commencent leur exécution simultanément. La fonction A envoie un message M. La
fonction B en attente du message M commence alors son exécution. Une file d’attente est
associée aux messages d’entrée d’une fonction. La taille de cette file d’attente peut varier de 0
(Rendez-vous) à l’infini. Ce modèle de comportement est relativement proche de celui du
modèle MCSE où l’on retrouve les concepts de fonctions et de port de communication.
-Figure 2.14- Exemple de modélisation sur RDD100.
-C- Analyse architecturale
La description de l’architecture matérielle permet de déclarer les ressources (mémoire,
processeur...) puis l’allocation des fonctions de manière à identifier les interfaces et donc les
supports physiques de transmission pour les messages.
-D- Evaluation des performances
Pour faire une évaluation des performances, l’utilisateur peut affecter des temps de
traitements aux fonctions. Une ressource active est caractérisée par sa puissance qui intervient
comme un facteur multiplicatif de la durée de traitement d’une opération et son degré de
concurrence. Un support de communication est caractérisé par sa capacité et chaque message
par sa taille.
La simulation des modèles saisis repose sur la génération et l’exécution d’un programme
Smalltalk. L’outil permet de présenter les résultats sous la forme d’un déroulement temporel
&
Function A Function B
M
&
ProcProd ProcCons
CC1
a) Diagramme de comportement
Partition et
Allocation
b) Architecture matérielle
Evolution
Temporelle
Flot de données
Chapitre 2
44 M.C.S.E
ou "TimeLine" qui permet de visualiser l’état des fonctions et la trace des messages. On peut
également visualiser l’évolution temporelle du taux d’occupation d’une ressource.
Le nombre réduit d’attributs associés à une ressource active limite l’intérêt de ce modèle
pour l’évaluation d’un partitionnement matériel/logiciel et la co-simulation: il n’est pas
possible de définir la politique d’ordonnancement car une ressource active est non préemptible,
le temps de commutation de tâches est nulle, etc. Après allocation, le concepteur doit aussi
redessiner un modèle pour faire apparaître explicitement les fonctions d’interfaces matériel/
logiciel.
L’outil RDD100 est l’outil central d’un ensemble d’outils intégrés pour l’ingénierie des
systèmes utilisé dans le projet RASSP [FRY96]. Il est complété par l’outil Price System pour
l’analyse de coûts et les outils RAM-ILS (Reliability, Availability, Maintainability, Integrated
Logistic Support) pour l’analyse de la sûreté de fonctionnement, la fiabililité et la
maintenabilité d’un système. Actuellement, cette intégration d’outils permet de couvrir toutes
les phases de développement d’un système et de faire du suivi de projet (gestion des ressources
humaines, analyse des risques, des coûts et des délais) [ALFORD-93].
2.6.4 COSMOS
L’outil COSMOS de la société Omniview exploite une modèle de représentation d’un
système composé de deux vues [OMNIVIEW-97]:
- une vue matérielle qui correspond à une version simplifiée du modèle exécutif ou
architectural de MCSE,
- une vue logicielle qui correspond à une association simplifiée de la vue fonctionnelle et
la vue comportementale de MCSE. L’outil COSMOS n’est en effet pas capable de
modéliser le comportement d’une fonction implantée en matériel puisque la vue
logicielle ne permet de décrire que le comportement de tâches logicielles.
La figure ci-dessous montre différentes vues de l’outil Cosmos.
-Figure 2.15- Exemple de modélisation sous Cosmos.
-A- Représentation de la vue matérielle
La saisie du modèle d’architecture matérielle graphique et hiérarchique repose sur
l’interconnexion de blocs et l’utilisation d’une librairie VHDL (modèle de performance de
Honeywell Technology Center) dont les composants sont paramétrables. Cette librairie
contient les modèles de performances de 4 types d’éléments: les processeurs, les mémoires, les
a) Modèle logiciel b) Modèle matériel
File d’attente
Tache
Periodique
Matrice d’interconnection
Bloc raffiné
Méthodologie de co-design et estimation des performances
M.C.S.E 45
éléments de communication et les éléments d’Entrée/Sortie [ROSE-95]. Les blocs
décomposables peuvent avoir plusieurs raffinement possibles.
L’élément clef, c’est à dire le processeur, est défini par son jeu d’instructions. Un
ordonnanceur est associé à chaque processeur et permet de modéliser du multi-tâches
[ROSE-96]. Chaque instruction est définie par le nombre de cycles et le nombre d’accès
mémoire nécessaires à son exécution. L’instruction simple ou multiple peut être définie
préemptive et dans ce cas il faut aussi définir les temps de préemption et de réallocation. Les
accès à la mémoire inclut le chargement de l’instruction (fetch) et les accès en lecture et/ou
écriture de l’instruction. Chaque instruction peut utiliser jusqu’à 3 bancs mémoires différents.
Ces bancs mémoires sont caractérisés par leur temps d’accès et l’utilisation ou non d’un cache.
Chaque cache est défini par un temps d’accès et son taux nominal d’utilisation utile pour
déterminer si un accès mémoire se fera avec ou sans cache (tirage aléatoire ou valeur
moyenne). Pour accélérer la simulation du modèle logiciel, l’outil calcule le temps total
nécessaire à l’exécution d’une instruction. Il commence par calculer le nombre de cycles
nécessaires aux accès mémoire en tenant compte de l’utilisation éventuelle d’un cache et
additionne ce résultat aux cycles de l’instruction. Le modèle ne modélise pas un étage de
pipeline d’instructions. Mais un étage de pipeline d’instructions a moins d’influence sur les
performances du processeur que la modélisation d’un cache mémoire et la prise en compte des
interruptions: "Caches affect CPU performance even more than pipelining within the execution
unit. Interrupt latency, the time required for the CPU to execute the first instruction of a
interrupt handler after an interrupt is raised can significantly affect performance."
[WOLF-94].
La communication entre les différents éléments (blocs et composants) d’une architecture
matérielle se fait par transition d’un jeton. Le concept de jeton est ici très proche du jeton du
modèle UVa puisqu’il s’agit d’une donnée non interprétée caractérisée par un certain nombre
d’attributs tels que priorité, taille, source, destination, date de création, etc.
Pour pouvoir analyser le modèle d’architecture seule, il faut injecter des jetons dans
l’architecture matérielle. C’est le rôle des sources de jetons ("InputDevice") qui définissent le
destinataire du jeton, sa taille et son débit. La taille et le débit peuvent être fixes ou tirés
aléatoirement selon des distributions uniformes, gaussiennes, de poisson, etc. Par dualité, il
existe aussi des consommateurs de jetons ("OutputDevice") et des réflecteurs de jetons. Les
réflecteurs (disques, mémoire, pipeline, file d’attente) de jetons retournent un jeton après un
certain délai. Enfin, comme pour le modèle UVa, des opérateurs de contrôle du flot de jetons
tel que les divergences ("split"), les convergences ("join") et les matrices d’interconnexions
("crossbar") sont disponibles. Les producteurs et consommateurs de jetons sont très utiles pour
modéliser l’environnement du système à étudier.
-B- Représentation de la vue logicielle
Il s’agit d’un modèle de process communicants. Les process qui ne sont pas raffinés sont
décrits sous la forme d’une tâche. Il y a 2 types de tâches: les tâches périodiques et les tâches
apériodiques en attente de l’occurrence d’un message.
La communication entre tâches se fait par transfert de messages qui englobent un jeton et
via une file d’attente. La file d’attente chargée de gérer l’ordre et la priorité des messages est
caractérisée par sa taille et sa politique de gestion des messages (ordre d’arrivée, taille du
message, priorité fixe, date de création...). Le protocole d’envoi de message peut être du type
port à N places ("loosely coupled") ou du type rendez-vous ("highly coupled"). Pour une tâche
Chapitre 2
46 M.C.S.E
périodique, l’attente de message n’est pas strictement bloquante: La tâche périodique
recommence son cycle même si elle est en attente d’un message et qu’elle n’a pas reçu ce
message durant la période d’activation.
Les tâches ont un comportement purement séquentiel. Ce comportement est décrit sous la
forme d’un diagramme de flot ou sous le forme d’un programme VHDL saisi manuellement
par l’utilisateur (utilisation d’un ensemble de primitives prédéfinies). Le diagramme de flot est
plutôt un diagramme de flot de contrôle qu’un diagramme de flot de données. Le diagramme
de flot se compose en effet d’opérateurs de branchement conditionnel, d’itération, de point de
sortie et de blocs de code constitués d’une séquence d’instructions saisie avec un éditeur
orienté par la syntaxe. Graphiquement, on ne peut pas parler de flot de données puisque
l’attente et la génération de messages se font par des instructions de code saisies manuellement.
Un bloc de code est aussi constitué d’instructions du jeu d’instruction du processeur.
Tout comme pour l’architecture matérielle, on peut analyser la vue logicielle seule.
-C- Allocation
L’outil ne se contente pas d’aider le concepteur à optimiser les performances des parties
matérielle ou logicielle séparément. Il permet aussi d’allouer les tâches logicielles sur les
processeurs matériels et par une démarche itérative basée sur une évaluation des performances,
de trouver la meilleure répartition des tâches entre les différents processeurs.
Le modèle d’architecture permet de modéliser des processeurs matériels (ASIC et FPGA)
mais ne permet pas d’allouer des éléments du modèle logiciel sur ces processeurs. Ainsi, l’outil
ne permet pas d’explorer le domaine des solutions possibles d’un partitionnement logiciel/
matériel. Il permet uniquement de trouver la meilleure répartition des tâches logicielles entre
les différents processeurs logiciels.
-D- Analyse des résultats
L’outil permet d’animer les modèles
graphiques, ce qui permet d’avoir une vue
globale des ressources matérielles critiques. La
visualisation des résultats se fait sous la forme
d’histogrammes (temps de latence, débit, taux
d’utilisation) ou sous la forme d’un diagramme
temporel qui permet d’observer les temps
d’exécution des différents tâches d’un
processeur. Le diagramme de déroulement
temporel est assez limité car il ne représente que
l’état actif d’une tâche. On ne sait pas si la tâche
est bloquée en attente d’un message, prête à être
exécutée mais en attente du processeur ou bien
inactive. Il ne représente pas les émissions de
messages. Il ne permet pas de mesurer les temps
de réponse. Enfin, il ne facilite pas la
compréhension des dépendances d’activation
entre tâches et la recherche des éventuels
problèmes d’ordonnancement (non respect de
contrainte de temps, interblocage)
-Figure 2.16- Déroulement temporel.
Méthodologie de co-design et estimation des performances
M.C.S.E 47
2.6.5 Bilan
En conclusion de cette analyse de l’existant, on peut affirmer que la plupart des modèles de
performance ne sont pas complètement appropriés pour la problématique du co-design car les
modèles recensés ne distinguent pas précisément la vue fonctionnelle et la vue exécutive. Or
une séparation nette entre ces deux vues s’avère indispensable pour explorer facilement
l’espace des solutions possibles pour l’architecture exécutive et pour le partitionnement
matériel/logiciel. Avec le modèle de performance de MCSE qui nous présentons en détail dans
le chapitre 3, le concepteur n’a pas besoin de définir un modèle différent pour chaque
alternative du partitionnement. Il doit juste redéfinir l’allocation des éléments fonctionnels sur
les éléments de la structure exécutive (mapping).
Les modèles de performances existants (Ses/Workbench, UVa) ont surtout été developpés
pour faire l’analyse des performances de systèmes existants alors que le modèle de
performances de MCSE a été développé pour répondre à la problématique du partitionnement
matériel/logiciel. Il est en effet basé sur deux vues complémentaires et orthogonales: la vue
structurelle et la vue comportementale. Le modèle de la vue structurelle est utilisé pour
représenter l’architecture du système selon les 2 niveaux fonctionnel et exécutif (ou
architectural). Le modèle comportemental spécifie le séquencement temporel d’un ensemble
d’opérations et d’activités. Il s’agit d’un modèle graphique où l’axe vertical représente
l’évolution temporelle et l’axe horizontal le flot de données. Les deux modèles sont enrichis
avec des attributs pour spécifier les caractéristiques de chaque composant.
2.7 CONCLUSION
Actuellement, les efforts de la communauté du co-design concernent essentiellement le
développement d’une méthodologie de conception complète et de ses outils support. Par
exemple, le projet américain RASSP développe actuellement une méthodologie de co-design
en se basant sur l’utilisation d’un ensemble d’outils commerciaux et universitaires pour couvrir
toutes les phases de développement d’un projet et en utilisant le langage VHDL comme format
d’échange entre les différents outils [HEIN-95].
Comme l’activité de co-design concerne rarement un système complet, une approche
système est tout d’abord nécessaire pour déterminer la partie du système relevant de l’activité
co-design. Pour l’approche système, la méthodologie présentée dans ce chapitre repose sur
l’utilisation de la méthodologie MCSE. Durant l’étape de définition de la réalisation ou de
conception architecturale de la méthodologie MCSE, un partitionnement système identifie la
partie purement matérielle, la partie purement logicielle et la partie où une variation entre le
matériel et le logiciel est possible. La solution fonctionnelle de cette partie délicate sert alors
de spécification pour l’activité de co-design.
A ce stade le concepteur fait face à la problématique de partitionnement matériel/logiciel.
Il doit définir l’architecture matérielle cible et l’allocation des éléments de la solution
fonctionnelle sur cette architecture. Notre approche de partitionnement en 2 temps
(partitionnement système et partitionnement matériel/logiciel) évite les écueils du “défaut de
myopie” qui amènerait à trouver un optimum local pour une spécification donnée sans s’être
assuré que la spécification résulte elle aussi d’un optimum pour le niveau système: "a local
optimization made at the structural level of Design may have a detrimental effect on overall
system performance" [KUMAR-96].
Chapitre 2
48 M.C.S.E
Alors que la plupart des méthodes de partitionnement sont automatiques et ciblent vers une
architecture mono-processeur et multi-ASICs du type maître/esclave, nous considérons que
dans la réalité industrielle l’architecture cible est quelconque et notamment hétérogène et
distribuée. Nous pensons également qu’il est indispensable d’inclure le concepteur dans la
boucle de recherche d’un partitionnement optimum pour le responsabiliser et profiter de son
expérience. Le plus important est alors de fournir au concepteur des outils d’estimation rapides
des propriétés du partitionnement choisi. Comme de nombreux travaux ont déjà été effectués
sur les estimateurs analytiques (analyse des contraintes temporelles, technique de synthèse,
réseaux de Petri stochastiques et de files d’attente) nous avons opté pour une technique
différente et complémentaire: l’évaluation des performances dynamiques d’un partitionnement
par co-simulation.
L’évaluation des performances dynamiques d’un système par co-simulation n’est pas
limitée par la complexité du système et permet d’extraire un ensemble de résultats de
performances plus riche que les approches analytiques tels que le débit sur un bus, le taux
d’occupation d’une ressource (processeurs logiciels, disques, bus,...), le temps de latence d’un
message, la détection du non respect d’une contrainte temporelle, un temps de retard au
démarrage,... Cependant, la co-simulation souffre généralement d’un temps de simulation trop
long. Pour réduire les temps de simulation, il faut augmenter le niveau d’abstraction des
modèles. Notre technique de co-simulation repose donc sur la simulation d’un modèle de
performance mascroscopique et non interprété.
Contrairement à la plupart des modèles de performances existants qui ne distinguent pas
nettement la vue fonctionnelle et la vue exécutive d’un système, notre modèle de performance
est adapté à la problématique du partitionnement matériel/logiciel. Il est en effet composé du
modèle fonctionnel et du modèle exécutif préconisés par la méthodologie MCSE et d’un
modèle comportemental qui décrit le comportement de chaque fonction de la vue fonctionnelle
sous forme d’une composition d’activités dynamiques. Ce modèle de performance est décrit
dans le chapitre 3. L’unicité du modèle de description facilite la transition entre les phases de
conception, diminue les risques d’erreur liés à une transcription de modèle (pas de déformation
ou perte d’information) et améliore la traçabilité.
La technique de co-simulation retenue pour l’évaluation des performances dynamiques des
systèmes repose sur la transcription du modèle de performance en une description VHDL et
l’utilisation d’un simulateur du commerce. Pour transcrire le modèle de performance en un
code VHDL simulable, il faut tout d’abord définir les règles de transcription ce qui fait l’objet
du chapitre 4 et ensuite les implanter dans un générateur de code.
La technique de génération de code développée repose sur les concepts d’analyseur
syntaxique et de méta-structure avec lesquels on obtient une structure de données image d’un
texte source, le concept de template qui est un modèle générique du résultat attendu et le
langage de description des manipulations à effectuer sur les structures de données que nous
avons nommé Script. Un générateur est alors le résultat de l’écriture d’un script qui est
interprété ou transcrit en code JAVA par un programme nommé MetaGen et décrit dans le
chapitre 5.
Méthodologie de co-design et estimation des performances
M.C.S.E 49
Les points essentiels à retenir sont pour l’instant les suivants:
- notre méthodologie de co-design basée sur la méthodologie MCSE est caractérisée par
une approche système, une modélisation selon 3 vues (fonctionnelle, comportementale
et architecturale), une architecture cible hétérogène, une méthode de partitionnement
interactif basée sur une évaluation des performances dynamiques et une technique de
co-simulation macroscopique et non-interprétée.
- la technique de co-simulation a nécessité le développement d’un générateur de code
VHDL qui a été réalisé selon un principe générique de développement de générateurs
de code ou d’outils de transformation de textes. Ce principe a été implanté dans un outil
qui constitue un générateur de générateurs de code ou méta-générateur exploitable pour
tout type de générateur de code.
Chapitre 2
50 M.C.S.E

M.C.S.E 51
3
Le modèle de
performance de MCSE
Pour le demandeur, un système est caractérisé par des exigences fonctionnelles et des
exigences non-fonctionnelles. Les exigences fonctionnelles expriment le comportement voulu
du système en relation avec son environnement. Les exigences non-fonctionnelles décrivent un
ensemble de contraintes imposées qui concernent à la fois le produit et le procédé de
développement et de réalisation du produit. Pour le produit, ces exigences sont d’ordre
technique et d’ordre économique.
On s’intéresse ici tout particulièrement aux exigences techniques. Parmi celles-ci, les
exigences de performance quantifient le comportement du système vis-à-vis de critères
d’observation qui peuvent être externes au système (temps de réponse, débit, etc) ou internes
(taux d’utilisation de ressources, capacité d’un bus), etc [CALVEZ-98a].
Comme tout objectif premier d’un développement est de satisfaire les exigences du
demandeur, il est essentiel de pouvoir vérifier tout au long de la conception que la solution
retenue permet de satisfaire les performances attendues. Ainsi, l’évaluation des performances
concerne toutes les phases d’une méthodologie de conception. Durant l’étape de spécification,
elle est utile pour vérifier et valider les spécifications avec le client puis faire une rapide étude
de faisabilité du projet. L’analyse des performances qui s’effectue lors de l’étape de conception
fonctionnelle ou conception préliminaire aide au dimensionnement des éléments internes du
système (taille d’un port de communication par exemple). Lors de l’étape de conception
architecturale, l’estimation des performances dynamiques en résultat d’un partitionnement
matériel/logiciel permet par une démarche itérative de trouver la solution optimale vis-à-vis
des contraintes imposées. Enfin après synthèse de la solution, la rétro-annotation des résultats
de synthèse dans le modèle de performance utilisé permet d’évaluer le système sans utiliser
Chapitre 3
52 M.C.S.E
obligatoirement des techniques de prototypage ou de réalisation avec observation des
propriétés temps-réel de la solution.
L’évaluation de performances nécessite qu’un système (et ceci est particulièrement vrai
durant l’étape de conception car il n’existe pas) soit décrit par un modèle qui soumis à une
configuration de charge donnée permet d’extraire des informations quantitatives.
Le modèle MCSE, déjà bien adapté à la conception des systèmes temps réel [CALVEZ-
90] et des Asics [CALVEZ-93a], a donc été enrichi par un modèle de performance. Bien que
la plupart des concepts de ce modèle de performance ont un certain historique car les premiers
travaux datent de 1992 [CALVEZ-93b], la sélection des éléments de ce modèle a aussi été
influencée par d’autres modèles de performances tels que les "Behavior Diagrams" de
RDD100, le modèle de transactions de SES/Workbench, le modèle UVa, etc. Contrairement à
la plupart des modèles de performances existants, notre modèle distingue clairement la vue
fonctionnelle d’un système de sa vue architecturale. Cette distinction facilite l’exploration du
domaine des solutions possibles d’un partitionnement matériel/logiciel. Notre modèle est en
effet basé sur l’emploi du modèle fonctionnel et du modèle exécutif préconisés par la
méthodologie MCSE et d’un modèle de comportement des fonctions. La méthodologie MCSE
possédait déjà un modèle de comportement reposant sur la composition d’opérations
élémentaires statiques. Jugé beaucoup trop restrictif pour l’évaluation des performances
dynamiques d’un système, le modèle de comportement des fonctions a été modifié pour
devenir un modèle de composition d’activités dynamiques. Des attributs ont aussi été associés
aux éléments de la dimension structurelle (vues fonctionnelle et exécutive) et de la dimension
comportementale.
Ce chapitre a pour objectif de décrire formellement le modèle de performance de MCSE.
Nous commençons par préciser la signification du terme performance dans le contexte
considéré. Nous définissons aussi une liste de critères de qualité d’un modèle de performance
utile pour juger la pertinence de notre modèle. Comme ce modèle est composé entre autres du
modèle fonctionnel et du modèle exécutif de MCSE, nous décrivons ensuite ces deux modèles
dont l’association constitue la vue structurelle ou dimension organisationnelle du système. La
vue structurelle décrit les éléments actifs (fonction, processeur) d’un système et leurs
interconnexions. Le modèle de performance comporte également une vue comportementale qui
est complémentaire et orthogonale à la vue structurelle. Aussi, nous présentons le modèle de
comportement qui spécifie le séquencement temporel d’un ensemble d’activités. Les deux vues
sont enrichies avec des attributs pour spécifier les caractéristiques de chaque élément. Nous
décrivons donc le rôle des principaux attributs. Un exemple d’application du modèle de
performance est donné en fin du chapitre.
3.1 LES PERFORMANCES
3.1.1 Définition
Le terme performance est très souvent utilisé sans que la signification soit claire. Il est par
exemple usuel de l’employer pour décrire la qualité d’un système à satisfaire un objectif
demandé.
Le modèle de performance de MCSE
M.C.S.E 53
Nous définissons le terme performance comme une quantification d’un système vis à vis de
critères d’observation externes ou internes. Ainsi par performance d’un système, nous
entendons ici des performances globales telles que la capacité de traitement, le taux
d’utilisation de ressources, le rendement, etc., mais aussi des performances locales ainsi que
des contraintes temporelles impératives en particulier pour les systèmes temps réel: temps
maximum de réaction à des événements, fréquence d’activation d’une tâche par exemple.
Les contraintes de performances sont obligatoirement des grandeurs quantitatives et
mesurables déterminées par des valeurs numériques. Ces valeurs quantifient la qualité d’un
aspect particulier du système placé dans un contexte donné d’exploitation.
3.1.2 Classification des performances
Une première approche consiste à classer les performances en 2 catégories:
- les performances statiques qui sont des exigences indépendantes du temps. Citons
comme exemples: La capacité mémoire nécessaire, la consommation maximale, le
poids, l’encombrement, le coût, etc.
- les performances dynamiques qui spécifient les caractéristiques d’évolution temporelle
du système dans son environnement (contraintes de temps, de débit, etc), ainsi que les
caractéristiques internes (taux d’utilisation de ressources internes, disponibilité d’un
bus, etc).
Les performances statiques peuvent se déterminer à l’aide d’estimateurs (calcul analytique
et/ou heuristique). Par contre l’estimation des performances dynamiques nécessite l’utilisation
de modèles analytiques, d’un prototype ou d’un modèle de simulation. La complexité actuelle
des systèmes sort souvent du domaine d’application stricte des modèles analytiques. Le
prototypage est aussi trop cher et/ou trop long à mettre en oeuvre. De plus, il ne peut intervenir
que tard dans le cycle de développement. Pour estimer les performances dynamiques d’un
système, le concepteur a donc recours de plus en plus à la simulation.
Par la suite, nous nous intéressons principalement aux performances dynamiques d’un
système qui peuvent aussi se structurer selon 2 catégories:
- les performances externes au système telles que:
• débit en entrée du système,
• débit en sortie du système,
• temps de réponse ou de réaction sortie(s) par rapport à entrée(s), temps de
latence,
• contraintes d’interactivité,
• précisions et erreurs tolérées,
• capacité globale du système.
- les performances internes au système telles que:
• taux d’utilisation des ressources internes: processeur, ligne de
communication, bus, etc.
• précisions et erreurs tolérées.
Chapitre 3
54 M.C.S.E
Les spécifications externes correspondent à une appréciation externe du comportement du
système considéré comme une "boite noire", basée sur l’évolution temporelle ou fréquentielle
des entrées et des sorties. Ces performances sont de type contraintes de temps ou contraintes
de capacité ou de débit.
Les spécifications internes, qui peuvent surprendre car faisant référence à des éléments de
la conception, servent à fixer des contraintes d’utilisation de la structure ou d’un élément de
celle-ci.
3.2 CRITERES DE QUALITE D’UN MODELE DE PERFORMANCE
Un modèle est construit par l’assemblage de concepts de modélisation. Un modèle efficace
doit posséder un ensemble de concepts de modélisation restreint mais suffisant pour décrire
facilement n’importe quel système. Le modèle doit aussi faciliter la transition entre les
différentes phases de conception et la traçabilité des informations. Nous considérons qu’un
modèle est de qualité s’il répond aux différents critères ci-dessous qui sont donnés sans
classification d’importance. Qu’il soit de qualité ou non, un modèle seul n'est pas suffisant. Il
doit toujours être accompagné d’une démarche favorisant l’élaboration de solutions. Notre
modèle de performance est donc intégré à la méthodologie de conception MCSE.
-A- Efficacité de modélisation
Ce premier critère essentiel concerne la facilité et la puissance de représentation du modèle
de description pour exprimer les concepts à modéliser. Il s'agit de disposer d'un moyen
permettant de décrire d'une manière succincte et efficace, la structure et le comportement du
système avec une souplesse de modification. L'évaluation pour un tel critère n'est pas simple
car il s'agit d'une perception relativement subjective et qui en plus dépend des concepteurs.
-B- Efficacité de déduction
Pour disposer d'une continuité des spécifications jusqu'au produit final, ce critère spécifie
l’aptitude du modèle à représenter la solution à divers niveaux ainsi qu’à permettre des
transformations de niveaux. La traçabilité entre modèles de différents niveaux doit être gérée.
-C- Efficacité d'évaluation
Comme l'objectif est de déduire rapidement les propriétés utiles de la solution décrite, il
faut pouvoir disposer d'un moyen efficace et fiable d'extraction des données objectives
essentielles. Pour cela, le modèle doit être paramétrable (données ou attributs associés aux
constituants et aux relations). Une méthode efficace d'évaluation basée sur la simulation pour
les propriétés dynamiques doit également lui être associée de manière à avoir un faible temps
d'analyse-correction.
-D- Efficacité de compréhension
Durant le développement, un modèle sert d'intermédiaire entre plusieurs stades de
conception. Aussi, il est utilisé par les concepteurs pour dériver ou induire un modèle plus
détaillé. Les critères de lisibilité et de compréhensibilité sont donc importants. Cette lisibilité
doit aussi se retrouver pour les descriptions produites par les outils associés au modèle. En
particulier les programmes générés doivent être simples, lisibles, compréhensibles car leurs
mises au point nécessitent généralement une interprétation et compréhension détaillée par le
concepteur.
Le modèle de performance de MCSE
M.C.S.E 55
Pour satisfaire les critères ci-dessus, le modèle de performance doit au minimum avoir les
propriétés suivantes:
• Modèle hiérarchique. Cette propriété permet de modéliser des systèmes complexes en
les décomposant en parties plus simples. Les techniques de raffinement,
d’encapsulation (ou abstraction) et de réutilisation de modèles existants sont ici
essentielles.
• Modèle d’interdépendance. Un système est souvent la composition de composants
fonctionnels et/ou physiques. Ces composants sont concourants et inter-agissent entre
eux par des liens de connexion. Le modèle au niveau système doit permettre d’exprimer
ce parallélisme et les dépendances temporelles avec des mécanismes de synchronisation
et de communication.
• Modèle graphique. La compréhension est facilitée si l’on utilise un modèle graphique
qui permet une représentation à au moins deux dimensions. Au besoin, il est possible de
représenter et interpréter sur le même graphique la description structurelle d’un système
(dimension organisationnelle) et l’évolution temporelle de ses composants (dimension
temporelle).
• Modèle paramétrable. l’évaluation des performances est facilitée si plusieurs
paramètres permettent de configurer le modèle. Pour cela, il est utile d’exprimer les
propriétés locales d’un modèle par des attributs associés aux éléments du modèle.
• Traçabilité. La continuité du modèle doit faciliter la transition d’une phase de
conception à l’autre et ainsi améliorer la traçabilité.
3.3 LES CONCEPTS DU MODELE DE PERFORMANCE DE MCSE
Pour disposer d’une démarche de développement intégrant au mieux la maîtrise des
performances simultanément à la maîtrise des fonctionnalités, une bonne solution est de
disposer d’un modèle unique permettant de dériver par transformations et enrichissements
successifs, à partir des spécifications, une solution de conception puis une solution
d'implantation et simultanément de décrire et d’évaluer les propriétés de performances à
chaque stade.
Analysons tout d'abord le modèle préconisé dans la méthodologie MCSE pour la
spécification et pour la conception fonctionnelle de manière à déduire ses limitations et
manques. Cette analyse, décomposée en une analyse de la composante structurelle puis de la
composante comportementale, servira de base pour décrire les concepts complémentaires pour
disposer d’un modèle approprié et efficace pour les 2 rôles indiqués ci-dessus.
3.3.1 Analyse du modèle structurel
Le modèle structurel permet de décrire les constituants internes d’un système et les
interconnexions entre ces constituants. Il est utilisé pour l’étape de conception fonctionnelle et
celle de conception architecturale de la méthodologie MCSE. En effet, en donnant des
significations différentes aux symboles, on peut à la fois décrire une structure fonctionnelle et
une structure d'exécution. Comme le montre la figure 3.1, la différence entre les 2 structures
Chapitre 3
56 M.C.S.E
réside simplement dans la représentation et la signification des constituants. La signification
du modèle fonctionnel peut aussi être élargie en considérant des significations différentes aux
éléments du modèle. Sa signification peut au moins s’étendre à la description des architectures
système, à la modélisation des ateliers, etc.
-A- Le Modèle fonctionnel
Le modèle fonctionnel représente une application selon un ensemble de fonctions qui interagissent
à l’aide de trois types de relations. Les relations inter-fonctions représentent trois types
d’échanges :
- larelation de partage de variables (par variable d’état) permet à plusieurs fonctions
de partager une donnée ou une ressource sans aucune relation d’ordre. La seule
contrainte imposée concerne l’accès à la donnée de façon à conserver l’intégrité de
l’information.
- larelation de synchronisation (par événement) représente une relation de précédence
d’exécution de deux fonctions: la fonction réceptrice ne peut s’exécuter que si
l’événement d’activation a été émis.
- la relation de transfert d’informations (par un port de communication) permet
d’échanger de l’information sous forme de messages. Elle introduit une relation du type
producteur/consommateur entre les fonctions. Ainsi, une fonction consommatrice ne
devient active que lorsqu’il y a au moins un message dans le port auquel elle accède.
Hiérarchique et graphique, le modèle fonctionnel facilite la recherche progressive d’une
solution par transformations de comportements en structures. En effet, une fonction décrite
sous forme comportementale peut aussi par raffinement se décrire par une organisation interne.
Les éléments de relation possèdent chacun un comportement précis. Il en résulte que toutes les
propriétés temporelles du modèle fonctionnel découlent essentiellement des propriétés du
modèle comportemental des fonctions.
-B- Le modèle exécutif
Le modèle exécutif est utilisé pour décrire la partie matérielle d’une application. Ce modèle
est similaire, en terme de structure, au modèle fonctionnel mais avec une spécification
différente des éléments (voir figure 3.1). Il est basé sur quatre éléments : le processeur, le signal
inter-processeurs, la mémoire commune et le noeud de communication qui permet aux
processeurs d’échanger des informations sous forme de messages.
-C- La configuration
Les modèles fonctionnel et exécutif considérés séparément ne sont pas suffisants pour
décrire la solution d’un système. Il est nécessaire de définir l’allocation (ou mapping) des
éléments fonctionnels sur les éléments exécutifs. Cette phase de configuration correspond à
l’étape de partitionnement et d’allocation en co-design.
Le modèle de performance de MCSE
M.C.S.E 57
-Figure 3.1- Modèle de description des solutions pour la méthodologie MCSE.
3.3.2 Analyse du modèle comportemental
Par modèle comportemental, nous entendons ici le modèle conseillé pour la spécification,
à savoir l’association du diagramme des activités et du StateChart. Le statechart peut aussi être
remplacé par un algorithme séquentiel.
Le diagramme des activités favorise la structuration du comportement global de l’élément
considéré (système, fonction) en comportements partiels et décrit clairement les interactions
entre parties. Le StateChart décrit très précisément un déroulement temporel de chaque activité
sous la forme d’un ensemble d’états, de conditions et d’actions. Mais toutes les actions du
StateChart sont considérées exécutées en temps nul (hypothèse synchrone), ce qui implique
A1
A2 A3
A5 A4
V1
V2
E2
E1
M1
P1 P3
P2 P4
M1
S1 M2 M1
N1
Signification des symboles
VARIABLE PARTAGEE
EVENEMENT
ACTION
PORT
MEMOIRE
SIGNAL
PROCESSEUR
NOEUD DE COMMUNICATION
Structure fonctionnelle Structure d’exécution
A2 A4
A1 et A5
A3
Composante
fonctionnelle
Composante
exécutive
CONFIGURATION
Composante
comportementale OP0
OP0
OP0
Chapitre 3
58 M.C.S.E
que les dépendances temporelles sont exclusivement liées à l’évolution de l’environnement
(comportement réactif). Rien ne permet de modéliser des caractéristiques temporelles internes
sinon l’emploi de variables Temps. En effet, en spécification, la durée d’un état ne représente
pas un temps d’exécution mais un temps d’attente d’une condition de fin de l’état.
Le diagramme d’activités de la figure 3.2, représente le résultat de l’étape de spécification
sur l’exemple du serveur vidéo temps-réel présenté dans le chapitre 7. Durant cette étape, le
concepteur détermine la liste des fonctions du système et le comportement du système
(StateChart, FSM ou algorithme séquentiel) pour ces fonctions. Les fonctions de service du
système pour son environnement sont pour l’exemple considéré: la lecture d’une séquence
vidéo, l’enregistrement de séquence et la gestion du serveur. Le diagramme d’activités fait
clairement apparaître la multiplicité des activités de contrôle du système et l’importance de la
grandeur Séquences. C’est autour de cette grandeur qui modélise l’ensemble des disques du
système que la solution fonctionnelle a ensuite été organisée lors de l’étape de conception
fonctionnelle. Les doubles flèches sur les grandeurs internes en entrées et sorties signifient
qu’il s’agit de données permanentes.
-Figure 3.2- Exemple de diagramme d’activités.
3.3.3 Les concepts complémentaires pour les performances
La modélisation de performances nécessite d’ajouter la notion de temps d’exécution des
opérations ou des actions pour pouvoir extraire des propriétés temporelles globales d’un
système (vues par ses entrées et sorties) à partir des propriétés temporelles locales. Les
concepts suivants servent, d’une part à exprimer ces propriétés, d’autre part à disposer d’un
modèle facilitant la transition progressive des spécifications en une solution interne détaillée.
-A- Association du modèle de structure et du modèle de comportement
Le premier aspect intéressant est de constater qu’il est possible d’exploiter simultanément
le modèle de structure fonctionnelle et le modèle comportemental rappelés ci-dessus. En effet,
le modèle résultant va de cette manière servir comme modèle intermédiaire entre une
spécification fonctionnelle pour laquelle la structure fonctionnelle n’existe pas encore et la
CmdUsager[1:k]
SéquenceOut[1:n]
Comportement du
système vis-à-vis
d’un usager
Contrôle Usager
RepUsager[1:k]
SéquenceIn[1:n]
CmdCanalLec[1:n]
RepCanal[1:k]
Séquences
CmdCanalEnr[1:n]
CanauxLibresLec
CanauxLibresEnr
FragmentsLibre
Comportement
Contrôle Lecture
du système pour
chaque lecture
Comportement
Contrôle Enregistrement
du système pour
chaque enregistrement
Le modèle de performance de MCSE
M.C.S.E 59
description fonctionnelle résultat de la conception fonctionnelle et qui elle, utilise une
description une description structurelle. Ainsi, par itérations successives durant la conception,
le parallélisme exprimé dans la spécification de départ est transformé en un parallélisme de
fonctions.
-B- Extension du modèle fonctionnel
Chaque fonction du modèle fonctionnel est une unité d’encapsulation. Pour l’analyse des
performances, une fonction est considérée comme une ressource d’exécution servant de
support pour les activités et opérations qu’elle inclut. Ainsi une fonction sera définie par des
attributs représentatifs de son rôle. Indiquons par exemple la possibilité de limiter le degré de
parallélisme des opérations internes et dans ce cas, il faut alors définir la politique
d’ordonnancement des opérations.
Les éléments de relation que sont les événements, les variables d’état, les ports sont aussi
caractérisables par des spécifications temporelles que sont par exemple les temps de lecture et
d’écriture, le degré d’accès simultanés.
-C- Extension du modèle comportemental
Le modèle comportemental préconisé pour les spécifications est uniquement statique pour
les activités, c’est-à-dire que toutes les activités du diagramme des activités existent à tout
instant, chacune étant dans un état dépendant de son comportement propre et de son
environnement. Le terme action est généralement limité à une intervention ponctuelle
considérée comme instantanée. En fait, en évoluant vers la description détaillée de la solution
interne, la différence entre action et activité tend à se réduire: une action nécessite du temps
pour son exécution, une activité exprime une intervention temporaire dans le système.
Ainsi, il est tout d’abord aisé d’ajouter la propriété temporelle de temps d’exécution pour
une action et pour une activité. Lorsqu’une activité est considérée comme élémentaire, elle sera
appelée opération.
Ensuite, il est intéressant de lever la restriction du caractère statique du diagramme
d’activités. De cette manière, il sera possible de représenter des comportements internes plus
complexes en exploitant la possibilité d’instanciation dynamique d’activités.
-D- Modèle générique et paramétrable
Pour dimensionner une architecture durant la conception, le concepteur doit pouvoir définir
et modifier des paramètres dans le modèle. Ces paramètres concernent aussi bien la vue
structurelle que comportementale. Pour le modèle structurel, nous considérons important de
pouvoir disposer du concept de composants génériques. Ceci veut dire, l’emploi de vecteurs de
composants. La taille du vecteur est alors un paramètre générique mais obligatoirement
statique. Pour le modèle comportemental, les activités et opérations sont au contraire
dynamiques et définissables aussi sous forme de vecteurs.
Tous les paramètres du modèle sont appelés des attributs. Certains doivent pouvoir se
définir et se modifier par l’utilisateur. De cette manière, il pourra étudier leur influence sur les
propriétés du système.
Il est aussi intéressant d’avoir la notion de modèle d’activité et de fonction, ce qui veut dire
la réutilisation possible d’un modèle provenant d’un autre projet. Un modèle peut posséder des
paramètres génériques qui définissent son emploi à l’instant de l’instanciation.
Chapitre 3
60 M.C.S.E
3.4 PRESENTATION GENERALE DU MODELE
Pour illustrer les principaux concepts introduits dans les paragraphes précédents, la figure
3.3 représente un exemple de modèle de performance.
-Figure 3.3- Principaux concepts du modèle de performance.
Le modèle structurel (partie gauche de la figure 3.3) est composé des fonctions
Environnement, F1 et F2 et des éléments de relation Mesures et M[1:n] pour le premier niveau
de description. F1 est raffinée par une structure comprenant F10, F11[1:n] et clk. n est un
paramètre générique de la structure. Le modèle de comportement (partie droite de la figure 3.3)
explique l’évolution temporelle de la fonction F2. Dans cette description, A1[1:m] est un
vecteur d’activités dont la taille est définie par le paramètre générique m. A1 est supposée être
raffinée. A[1:m] et A2 sont des activités concurrentes liées par la donnée permanente V3.
Comme le montre la figure 3.3, le modèle de performance est surtout graphique et basé sur
deux vues complémentaires: la vue structurelle (dimension organisationnelle) et la vue
comportementale (dimension temporelle).
- Lavue structurelle permet de décrire les éléments actifs (fonction et même processeur)
d’un système et leurs interconnexions. Les composants sont couplés entre eux par
l’intermédiaire d’éléments de relation. Ils sont de 3 types pour la structure fonctionnelle
(Evénement, Variable partagée, Port) et de 3 types pour la structure d’exécution (Signal,
Mémoire commune, Noeud de communication). Le modèle structurel est hiérarchique
(un élément actif peut être raffiné) et permet la réplication (instance d’un modèle).
- Lavue comportementale permet de décrire le comportement des fonctions. Le modèle
de comportement est un modèle non-interprété qui repose sur des activités
décomposables par raffinement ou élémentaires (temps d’exécution) et des opérateurs
de composition d’activités (séquence, parallélisme, alternative, répétition et attente
conditionnelle).
M[1:n]
&
Fonction F2
V3 Ev
Op0‘Time = 1 ms;
A2‘Time = 5 ms minimum;
A2
Op0
100 ms maximum;
dimension
F11
F10
clk
Mesures
Environnement
F11[1:n]
Raffinement
de A1
A1[1:m]
A1
dimension spatiale
F1
V3‘Write =20 ms;
V3‘Read =20 ms;
‘Concurrency=2; ‘Power=1; M[]‘Read =1000 ms;
temporelle
Le modèle de performance de MCSE
M.C.S.E 61
Tous les éléments du modèle sont définis avec des attributs spécifiques, par exemple, le
temps d’exécution (attribut ‘Time) d’une activité élémentaire, le temps de lecture (attribut
‘Read) et d’écriture (attribut ‘Write) pour une variable partagée, la capacité d’un port (attribut
‘Capacity), le degré de concurrence d’un processeur (attribut ‘Concurrency), etc...
La figure 3.3 montre le modèle de comportement de la fonction F2 selon 2 axes: l’axe
temporel du haut vers le bas qui représente le séquencement (expression du contrôle), l’axe
spatial de la gauche vers la droite qui représente les échanges, les transactions, le flot de
données, en un mot les interdépendances (expression du flux). La fonction F2 est décrite
comme l’exécution de l’opération Op0 à partir de l’instant initial puis l’exécution simultanée
des activités A1 et A2. Lorsque ces 2 activités sont achevées, la fonction F2 devient inopérante
sans pour cela disparaître. Ainsi, il est possible de représenter des comportements plus
généraux que le modèle cyclique et séquentiel d’une fonction du modèle fonctionnel initial de
MCSE. Les activités A1 et A2 sont couplées entre elles par la donnée permanente V3 (notation
du modèle de spécification) et sont aussi liées à l’environnement de la fonction par M et Ev.
Les activités sont détaillées par le même type de modèle (raffinement) car le modèle est
hiérarchique. Chaque opération (rectangle) est caractérisée par son temps d’exécution (attribut
‘Time). Chaque activité est caractérisée par: son comportement interne, son temps d’exécution.
Il ne faut pas confondre activité (et opération) et état, ce qui justifie la notation légèrement
différente. Le temps d’intervention d’une activité est essentiellement défini par les temps
d’exécution internes. Une activité ou une opération implique l’utilisation d’une ressource
d’exécution pour son intervention. Un état représente généralement une situation d’attente, ce
qui veut dire absence d’utilisation de ressource d’exécution. La durée d’un état est définie par
les conditions de passage dans d’autres états. Lorsque la durée d’un état est définie par un
temps, ceci peut correspondre à une confusion entre état et opération.
Une activité peut se décrire par un diagramme d’activités ou par un diagramme d’états. Un
état ne peut se décrire que par un diagramme d’états plus élémentaire (raffinement du
statechart).
3.5 LA COMPOSANTE STRUCTURELLE DU MODELE DE PERFORMANCE
Pour décrire les extensions du modèle structurel nécessaire pour l’évaluation des
performances, un exemple d’illustration qui concerne un système de communication permet
tout d’abord de montrer la représentation graphique pour la solution fonctionnelle et pour
l’architecture matérielle. On montre aussi que les 2 structures peuvent être combinées en une
seule pour décrire une solution complète avec son implantation. La figure 3.4-a représente une
structure fonctionnelle et une structure d'exécution.
L’exemple considéré ici est un système simplifié de communication permettant le transfert
de messages entre des producteurs Prod[1:m] et des consommateurs Cons[1:n]. La fonction
Emission envoie un message reçu du port L_req vers la fonction Reception via le port P_send.
Pour garantir un transfert correct, chaque message doit être acquitté via le port P_ack. Emission
utilise une fonction de chien de garde pour limiter le temps d’attente de l’acquittement.
Chapitre 3
62 M.C.S.E
La structure d’exécution est composée de 2 processeurs P1 et P2 reliés entre eux par le
noeud de communication appelé Bus.
-Figure 3.4- Modèle structurel pour la modélisation des performances.
La structure représentée par la figure 3.4-b, appelée structure mixte ou architecturale,
regroupe les 2 points de vue fonctionnel et exécutif. La figure du haut représente les
processeurs comme unités d’encapsulation. Elle ne représente pas le lien inter-processeur Bus
qui doit supporter les 2 liens fonctionnels P_send et P_ack car il s’agit d’un modèle simplifié.
La différence de signification entre les relations du modèle fonctionnel et celle du modèle
exécutif nécessite normalement de faire apparaître des interfaces qui sont des fonctions
particulières pour assurer les couplages entre liens de modèles différents. On constate bien ici
(figure 3.4-c) que le modèle exécutif sert de support. Ainsi un port tel que P_send ou P_ack est
scindé en 2 parties: Port_X_in, Port_X_out. Puis on y ajoute 2 interfaces et un lien pour la
communication.
Dans la suite, on ne fera pas obligatoirement de distinction entre les constituants du modèle
fonctionnel et ceux du modèle exécutif. La distinction est intéressante à faire uniquement
lorsqu’il s’agit de faire apparaître les interfaces entre le fonctionnel et l’exécutif.
Le modèle structurel, qu’il soit fonctionnel ou exécutif ou mixte, explicite les constituants
et leur signification par leur nom et leur rôle, les échanges possibles entre constituants
(signification et structure des données) mais n'indique rien quant au comportement du modèle
car le comportement des fonctions et processeurs n’est pas défini.
D'autre part, des instanciations multiples de fonctions ou d'éléments de relation sont
possibles. On détaille dans la suite ces 2 aspects.
Reception
L_ind[1:n]
Emission
L_req
Start
Time_out
P_send
P_ack
ComSystem
P2
Bus
structure exécutive
a) Structure functionnelle et exécutive
P1
Prod Cons
ALLOCATION
Prod[1:m]
Cons[1:n]
D
Watchdog
structure fonctionnelle
Reception
L_ind[1:n]
Emission
L_req
Start
Time_out
P_send
P_ack
ComSystem
Prod Cons
Prod[1:m] Cons[1:n]
D
Watchdog
P1 P2
b) Structure mixte
‘Concurrency and ‘Power
P_send_out
P_ack_in
P_send_in
P_ack_out
Interfaces
Int Int
P1 P2
Bus
c) Interfaces matérielles/logicielles
ComPart
Répartition géographique
Le modèle de performance de MCSE
M.C.S.E 63
3.5.1 Généricité et instanciations multiples
Un constituant actif ou de relation peut être instancié plusieurs fois, ceci pour représenter
facilement une organisation exploitant de multiples objets d'un même type (replication). Il
s’agit alors de vecteurs de fonctions, de ports, de variables partagées, d’événements, de noeuds.
Un constituant actif multiple est représenté par son symbole avec son ombre. Sa multiplicité
est décrite comme un vecteur défini par l’indice de début et l’indice de fin. Un élément du
vecteur est désigné par son nom et son indice. Ces indices peuvent être des constantes ou des
variables (paramètre générique expliqué plus loin). Le mot générique veut dire qu’un indice est
défini par un nom symbolique et la valeur est fixée par un objet englobant. Ceci permet de
disposer de la notion de modèle générique pour l’instanciation. La même définition est utilisée
pour les vecteurs de constituants de relation.
Se pose le problème des règles d'interconnexion entre composants actifs et éléments de
relation. Les cas suivants représentés par la figure 3.5 sont à considérer: N ->1, 1 -> N, N -> N,
N -> M.
-Figure 3.5- Les différents cas de l’instanciation multiple.
-A- Cas N -> 1
La valeur N ou 1 peut concerner aussi bien un objet actif qu'un objet de relation. Le premier
cas ci-dessus indique la correspondance F1[i] -> Pt[i] avec i allant de 1 à n, puis la visibilité de
tous les Pt[1:N] par F2. Le deuxième cas en dessous signifie que toutes les fonctions F1[i]
exploitent en écriture un seul port Pt en respectant son degré de partage.
Cette signification est similaire pour les relations par synchronisation et pour les éléments
partagés.
-B- Cas 1 -> N
Il s’agit ici de la relation de distribution de 1 vers N. Le premier cas spécifie que F1 peut
utiliser l'un quelconque des ports du vecteur Pt[1:N] en le désignant par son indice. Le
deuxième cas en dessous indique que toutes les fonctions F2[i] peuvent faire un retrait de Pt.
-C- Cas M -> N
Il s’agit ici de la relation de distribution de M vers N qui permet une interconnexion
complète. Le premier cas spécifie toujours que F1 peut utiliser l'un quelconque des ports du
vecteur Pt[1:K] en le désignant par son indice, mais chaque F2[i] peut accéder à tous les
éléments du vecteur Pt[1:K] (signification du rond noir pour la relation multiple). Le deuxième
cas en dessous indique que chaque fonction F2[i] peut accéder à tous les éléments de Pt.
F2
Pt[1:N]
N ---> N ---> 1
N ---> 1 ---> 1
F1[1:N]
F2
Pt
F1[1:N]
a) Case N ---> 1
F1
Pt[1:N]
1 ---> N ---> N
1 ---> 1 ---> N
F1
Pt
b) Case 1 ---> N
Pt[1:K]
M ---> K ---> N
1 ---> K ---> N
F1[1:M]
c) Case M ---> N
F2[1:N]
F2[1:N] FF22[1[1:N:N] ]
Pt[1:K]
F1 FF22[1[1:N:N] ]
Chapitre 3
64 M.C.S.E
3.5.2 Comportement macroscopique de la structure
Il s'agit de spécifier le comportement directement et obligatoirement induit par la structure.
L’expression de ce comportement s’effectue simplement en ajoutant des attributs aux éléments
de la structure. Pour cela, on passe en revue ci-après les 4 types d’éléments. Les attributs décrits
ci-après existent obligatoirement; chacun possède une valeur par défaut (valeur donnée entre
parenthèses). D’autres attributs peuvent être ajoutés par l’utilisateur pour enrichir sa
description selon l’objectif qu’il vise.
-A- Constituant actif
Une fonction, un processeur, un système, c'est-à-dire un constituant structurel actif peut se
spécifier globalement par son comportement qui est alors macroscopique. Un premier
paramètre concerne sa vitesse d'exécution pour tous les constituants inclus qui correspond à sa
puissance exprimée par rapport à l’unité (puissance relative). Ensuite, le comportement du
constituant est défini par son degré de parallélisme pour l’ensemble de ses constituants
internes. Ce paramètre peut évoluer de 1 qui représente le fonctionnement séquentiel à l’infini
(*). Le séquentiel veut dire que, à tout instant, une seule fonction, opération, activité inclue est
active. L'évolution séquentielle permet par exemple de caractériser le déroulement d'un
ensemble de fonctions sur un processeur séquentiel.
Lorsque le nombre de constituants internes actifs est plus élevé que le degré de
parallélisme, il est alors nécessaire de spécifier la politique de déroulement. Parmi les
possibilités, citons:
- ordonnancement préemptif, non-préemptif, partage équitable ou time sharing (PS,
NPS, TS),
- ordonnancement par priorité, par date critique ou deadline (P, D) pour le préemptif et
le non-préemptif,
Ainsi, les attributs associés au constituant actif que nous avons retenus sont:
- ‘Power qui est une valeur de la puissance relative (nombre en flottant), (1 par défaut)
- ‘Concurrency, qui est un nombre entier positif, (0 pour la valeur infinie)
- ‘Policy: (PSP, PSD, NPS, TS), (PSP)
- ‘Overhead: un temps, (0)
- ‘Level: (Global, Local, Processor, Function, Activity, Operation), (Function)
- ‘Priority: un nombre entier croissant dans le sens de la priorité, (1)
- ‘Deadline: un temps, c’est-à-dire valeur et unité. (0)
Les 3 premiers concernent le constituant servant de support d’exécution pour la structure
correspondant à son raffinement. L’attribut ‘Power sert à faire varier simultanément les temps
d’exécution de tous les constituants actifs inclus dans le constituant selon un coefficient qui
représente la puissance en tant que ressource d’exécution. La valeur neutre est 1. L’attribut
‘Concurrency permet de contrôler le degré de parallélisme à l’exécution. On peut donc de cette
manière décrire l’effet d’un microprocesseur comme support exécutif pour un ensemble de
fonctions, activités, opérations, et étudier l’influence de sa vitesse d’horloge en agissant sur
‘Power. L’attribut ‘Overhead permet d’introduire le temps de commutation entre 2 tâches
(fonction ou activité) lors du partage de la ressource d’exécution. L’attribut ‘Level est
optionnel et permet d’indiquer le niveau ou la catégorie de l’élément dans la structure
complète. Les 2 derniers attributs concernent le constituant lorsqu’il n’est pas raffiné.
Le modèle de performance de MCSE
M.C.S.E 65
-B- Synchronisation (événement, signal)
Une synchronisation peut être du type booléen, du type compteur ou du type fugace. Dans
le deuxième cas, toutes les générations vont engendrer une évolution (ceci se traduit par une
liste pour son implantation). Pour le type fugace, il n’y a pas mémorisation de l’événement si
un constituant actif destinataire n’est pas en attente. Ce dernier cas permet de modéliser le
comportement des fonctions sur une entrée servant non pas d’activation mais de condition
d’évolution.
Une synchronisation est aussi caractérisable par les temps de génération de l’événement,
d'activation des correspondants et par son degré de partage pour l’accès.
Les attributs intéressants sont les suivants:
- ‘Policy: (Boolean, Counter, fugitive), (Boolean)
- ‘Concurrency: un entier positif, (1)
- ‘Write: un temps, (0)
- ‘Read: un temps. (0)
-C- Elément partagé (Donnée ou ressource commune)
Une donnée ou ressource commune est caractérisée par son degré de partage et sa capacité
en nombre de bits ou de mots (grandeur statique ou dynamique). 2 temps sont à considérer pour
son utilisation: allocation ou écriture/modification, libération ou lecture. Pour enrichir la
signification, il est souhaitable de différencier: Données et Ressources. Pour la donnée qui a
une signification au niveau fonctionnel, le degré de partage concerne les accès simultanés en
lecture et modification. Pour une ressource qui a plus une signification au niveau exécutif, le
degré de partage concerne l’intervalle entre allocation et libération.
De plus, il est intéressant d’ajouter 2 types de politiques en cas de concurrence d’accès:
selon la priorité ou selon l’ordre des demandes et donc Fifo.
Les attributs retenus sont les suivants:
- ‘Policy: (DataFifo, DataPriority, ResourceFifo, ResourcePriority), (DataFifo)
- ‘Concurrency: un entier positif, (1)
- ‘Capacity: un entier positif, (1)
- ‘Write: un temps, (0)
- ‘Read: un temps, (0)
- ‘Use: un temps (0).
Le comportement pour une donnée permet de modéliser l’exploitation d’une donnée
complexe, y compris sa lecture et écriture sur un support de masse. Le temps ‘Use représente
alors le temps d’écriture ou d’accès pour la lecture, tandis que les temps ‘Write et ‘Read
représentent les temps d’échange avec le contrôleur du support de masse (exploitation d’un
cache par exemple). Pour une ressource, il s’agit de sa période d’utilisation, le temps ‘Use est
non-significatif.
‘Write ‘Use
Write
‘Read ‘Use
Read
‘Write ‘Use
Alloc
‘Read
Release
Resource
Data
Chapitre 3
66 M.C.S.E
-D- Transfert d'information ou d'objet, communications
L'objet de couplage est assimilable à un tampon caractérisé par sa capacité qui peut varier
de 0 (rendez-vous) à l'infini (*) et peut aussi être du type fugace. Le type fugace veut dire qu’un
message n’est pas mémorisé si aucune fonction n’est en attente. Par défaut, la capacité est
infinie. 2 temps sont aussi à considérer pour son utilisation ceci dans le cas de place disponible
pour le dépôt, ou information disponible pour le retrait. Il faut y ajouter son degré de partage
pour des accès multiples. Le service assuré par le port, c’est-à-dire l’ordre de rangement des
messages, sera aussi définissable selon une politique Fifo ou selon la priorité des producteurs.
Dans le cas d'un lien physique de communication ou de transfert, qui lui peut être
bidirectionnel ou unidirectionnel, le degré de partage permet de différencier entre liens fullduplex
ou half-duplex.
Les attributs retenus sont les suivants:
- ‘Policy: (Fifo, Priority), (Fifo)
- ‘Concurrency: un entier positif, (1)
- ‘Capacity: un entier positif ou nul ou * ou fugitive, (*)
- ‘Write: un temps, (0)
- ‘Read: un temps. (0)
-E- Attributs pour les liens de connexion
Des attributs peuvent aussi être ajoutés sur les liens liant les composants aux éléments de
relations. Pour cela, les attributs sont définis à l’intérieur du composant et ceci en utilisant le
nom de l’entrée, de la sortie ou de l’entrée/sortie.
Ces attributs peuvent être utilisés pour modifier (forme de surcharge) les attributs des
éléments de relation car ils sont alors considérés prioritaires. En effet, si l’attribut concerne par
exemple le temps d’écriture (‘Write), ce temps vient en remplacement du temps d’écriture de
l’élément connecté. Cette possibilité permet de modifier sélectivement les paramètres du
comportement du modèle de structure. Les 3 attributs particulièrement concernés sont donc
‘Write, ‘Use et ‘Read.
-F- Attributs libres
Pour permettre toute forme d’évaluation sur la structure, l’utilisateur peut ajouter les
attributs qu’il souhaite pour les éléments de la structure. Ceci se traduit pour chacun par
l’emploi d’un nom d’attribut, d’une valeur, d’une unité.
De tels attributs permettront de faire, en autres, des évaluations statiques de la solution, tels
que: la consommation, la surface, le coût, etc.
-G- Paramètres et vecteurs génériques
Une description peut comporter des paramètres génériques de manière à dimensionner
l’application pour plusieurs grandeurs. Ceci est intéressant pour des instances multiples de
fonctions, d’activités, d’éléments de relation. Par suite de ce caractère générique, il faut définir
la notation pour les vecteurs. [] veut dire l’élément dans le vecteur du même indice que l’objet
englobant. [:] veut dire tout le vecteur et ses bornes sont celles de sa définition.
3.5.3 Utilisation de modèles
La description d’un composant doit aussi pouvoir se faire à partir de composants déjà
décrits. Ceci doit favoriser la réutilisation en conception.
Le modèle de performance de MCSE
M.C.S.E 67
Pour ce faire, un composant est considéré comme un type (ou une classe, similaire à la
notion de symbole pour un éditeur de schémas). Un tel composant est défini par son nom de
type, ses entrées et sorties formelles, sa description interne. L’emploi du composant conduit à
créer une ou plusieurs instances chacune ayant un nom pour l’application.
La figure 3.6 montre 2 exemples de description avec l’emploi d’une fonction REGUL
comme modèle.
-Figure 3.6- Exemples de structures fonctionnelles utilisant un modèle.
Chaque composant servant de modèle est déclaré avec son nom de modèle (Regul), ses
entrées et sorties formelles (P, C, S), sa description interne. Les composants instanciés sont
déclarés avec un nom d’instance (RR[1:n], R1, R2) et le nom du modèle. Les noms utilisés pour
les entrées et sorties de l’instance correspondent aux connexions réelles dans la structure
englobante (Param, Cons[1:n], Sv[1:n] ou bien S1, S2, C1, C2).
Concernant les paramètres génériques, lorsque le modèle contient des vecteurs d’instances,
la taille d’un ou plusieurs vecteurs internes peut être dynamique. Dans ce cas, l’exploitation du
modèle nécessite de spécifier la taille de ces vecteurs. Ceci se fait par l’intermédiaire de
paramètres génériques déclarés à la fois pour le modèle et pour l’instance. De cette manière, il
est possible de définir une correspondance entre les noms donnés dans la description
englobante et les noms donnés dans le modèle.
Cette facilité sera aussi utilisée pour définir des attributs génériques qui seront fonction
d’un ou plusieurs paramètres généraux.
3.6 LA COMPOSANTE COMPORTEMENTALE DU MODELE DE PERFORMANCE
Le modèle de comportement définit les règles de construction que doit respecter toute
description comportementale d’un composant actif utilisé dans le modèle structurel. A noter
que pour le concepteur, tout constituant pourra posséder plusieurs descriptions aussi bien
structurelles que comportementales. Le point de vue du comportement d’un composant est une
vision orthogonale au point de vue structurel.
Lors de l’étape de spécification, un modèle de comportement est souvent basé sur un
diagramme d’activités, un StateChart ou un automate à états finis. Le diagramme des activités
favorise la structuration du comportement global de l’élément considéré (système, fonction) en
comportements partiels et décrit clairement les interactions entre parties. Le StateChart décrit
très précisément un déroulement temporel de chaque activité sous la forme d’un ensemble
d’états, de conditions et d’actions. Toutes les actions du StateChart sont considérées exécutées
en temps nul (hypothèse synchrone).
Regul
Regul
a) Structure fonctionnelle 1 b) Structure fonctionnelle 2
RR[1:n]
C1
Param
Cons[1:n]
Sv[1:n]
P
S
C
Regul
C1
P
S
C
P
S
C
Param
S1 S2
R1 R2
Chapitre 3
68 M.C.S.E
Durant le processus de conception qui consiste en une succession de transformations de la
spécification initiale en un modèle de plus en plus structurel, lorsqu’on s’approche de la
solution interne d’un système, la différence entre action et activité tend à se réduire: une action
demande du temps pour son exécution et une activité joue un rôle temporaire dans le système.
Par conséquent, la modélisation des performances durant la conception nécessite l’ajout du
concept de temps d’exécution pour les actions et les opérations afin d’extraire des propriétés
temporelles du système. A notre point de vue, le StateChart (et également le SpecChart) est un
modèle trop détaillé pour l’évaluation des performances.
Dans le modèle de comportement que nous avons retenu, nous avons éliminer le caractère
statique d’une activité d’un diagramme d’activité ou d’un flot de données. De cette façon, il est
plus facile de représenter le comportement interne des systèmes complexes en utilisant la
possibilité d’instanciation dynamique d’activités.
Dans la suite, nous présentons tout d’abord globalement le modèle comportemental par un
exemple. Les règles de description sont ensuite expliquées.
3.6.1 Un exemple de modèle comportemental
Comme pour le modèle structurel, le modèle comportemental comprend 2 parties:
- la description des éléments internes et les dépendances temporelles entre eux,
- la description des propriétés de tous les éléments, aussi appelées attributs.
La description du comportement est décrite sous une forme graphique représentant le
déroulement temporel selon l’axe vertical ceci pour faciliter la compréhension. Un
comportement est construit sur la base d’opérations (rectangles) et d’activités (rectangle à
coins arrondis). Les déroulements divergents ou simultanés apparaissent comme des branches
parallèles verticales. Les dépendances temporelles, c’est-à-dire les synchronisations, les
communications et les sorties, sont représentées horizontalement. Cette description est
hiérarchique car une activité peut se raffiner. Une activité élémentaire est appelée opération.
La figure 3.7 montre un exemple de représentation du comportement d’une fonction et
d’une activité.
La fonction F commence par une opération Op0 et se met ensuite en attente d’un message
sur l’un des ports du vecteur M. Ce vecteur de ports est noté M[:] lorsqu’il s’agit d’un vecteur
non contraint. L’opérateur avec la lettre S est un opérateur de sélection. Il y a ensuite activation
simultanée de 2 branches avec une synchronisation par Lt. Les 2 branches sont achevées
lorsque Op2 et Op3 sont achevées. On notera que la génération des sorties n’est pas associée
aux opérations mais après celles-ci.
A1 est une activité raffinée. Elle inclut une évolution selon 2 branches exclusives avec une
sélection aléatoire définie par une probabilité. L’une des branches inclut une boucle
représentant l’exécution multiple (ici N fois) de l’opération A11.
A cette représentation graphique correspond une description textuelle donnée sur la figure
3.7 et simple à interpréter. Le texte suit l’évolution temporelle. Des symboles spécifiques sont
exploiter pour représenter, d’une part l’enchaînement (structure de contrôle), d’autre part les
actions associées aux éléments de synchronisation ou de communication. La notation sera
expliquée dans les paragraphes suivants.
Le modèle de performance de MCSE
M.C.S.E 69
-Figure 3.7- Description comportementale d’une fonction et d’une activité.
Une description temporelle est la composition d’opérations ou d’activités (flux vertical)
conformément à 5 règles d’association:
- la séquence, (&)
- l’alternative, (|)
- la simultanéité, (||)
- la répétition, ({})
- l’activation conditionnelle multiple ([?-&- | ?-&-]).
Des règles d’interaction par les symboles ? et ! sont ajoutées pour exprimer les
interdépendances par échange de données ou d’informations (flux horizontal).
Le modèle qui en résulte est un modèle dit non-interprété car les valeurs des données et des
informations pour l’application n’interviennent pas dans la description. Ceci ne veut pas dire
que les variables d’état et les informations ne contiennent pas de données. Elles peuvent
contenir des valeurs d’attributs qui sont significatifs comme information abstraite pour la
modélisation de performance. Comparativement à l’utilisation du StateChart, il s’agit d’une
description plus macroscopique qui mixe l’expression temporelle en vertical avec le flot
d’information en horizontal. En associant des propriétés à chaque élément par des attributs, ce
modèle permet une extraction de propriétés de performances sans avoir à décrire le
comportement détaillé (c’est à dire algorithmique) de chaque opération.
F :: Op0&!$M[:]&((A1&!Lt&Op2)||(Op1&!Ev&?Lt&Op3))
M[1:n]
&
Fonction F
Op1
Lt
Ev
OR
Prob_erreur else
Activité A1
A12
A10
A1 :: A10&(<Prob_erreur>{A11}*N|A12)
*N
Op0
S
A1
Op2 Op3
A11
M[:]
Chapitre 3
70 M.C.S.E
3.6.2 Opération, activité élémentaire
L'opération est l'unité comportementale la plus élémentaire, donc non-décomposable. Une
activité non-décomposée est assimilée à une opération, tout en pouvant être très différente pour
sa signification en modélisation. Une opération ou une activité élémentaire est définie vis-à-vis
de son contexte englobant par une entrée en dessus et une sortie en dessous. Il ne s'agit pas ici
d'une entrée ou d'une sortie de donnée pour le couplage comme pour le modèle structurel mais
de l'indication de début d’évolution et de fin d'évolution. Les données utilisées par une
opération ne sont pas représentées car le modèle est du type flot de contrôle et non pas flot de
données.
Un temps d’évolution caractérise l'opération (attribut ‘Time). S’ajoute un autre attribut
(‘Kind) permettant de différencier une opération d’attente qui ne nécessite pas de ressource
d’exécution (passive) d’une opération d’exécution impliquant l’emploi d’une ressource
(active).
-Figure 3.8- Représentation et spécification d’une opération.
La durée de l'opération est un attribut qui peut se spécifier par toute expression
mathématique utilisant des constantes, variables, paramètres réglables, probabilités. La
particularité d'une opération est sa durée qui est finie et qui n'est pas conditionnelle à une
circonstance externe. Cette durée représente l’utilisation de ressources pour sa réalisation.
Il faut donc bien différencier une opération d'un état utilisé dans un modèle du type
diagramme à états finis. La durée dans un état d’un diagramme est souvent un temps d’attente
et est dépendant de conditions qui indiquent l'achèvement de l'état.
NOTA: Il n'y a pas de différence entre une opération et une activité non raffinée (même
symbole). Le symbole est choisi différent pour une activité raffinée ceci pour faciliter
l'interprétation du modèle graphique.
3.6.3 Composition d’opérations et d’activités
L’expression d’un comportement résulte de l'association d'opérations et d'activités en
respectant des règles de bonne structuration. Les opérateurs de composition usuels pour la
spécification du contrôle sont: séquence, simultanéité ou parallélisme, alternative, répétition et
attente conditionnelle. La figure 3.9 donne la représentation graphique et la notation syntaxique
pour chaque type de construction.
-Figure 3.9- Représentation des constructions pour exprimer un déroulement.
Op Op‘Time= 10 ms; Op‘Time= expression mathématique;
Op‘Kind = passive ou active;
Séquence Simultanéité Parallélisme multiple Alternative Répétition
& &
Op
Op1&Op2 Op1||Op2 Op[1:n] <0.5>Op1|<*>Op2
0.5 *
OR
Op
*N
{Op}*N
Op1 Op2 Op1 Op2
E1 E2
[?E1&Op1|?E2&Op2]
Op1 Op2
Op1
Op2
Attente Conditionnelle
Le modèle de performance de MCSE
M.C.S.E 71
Pour la séquence, la fin d’évolution de OP1 engendre le début d’évolution de OP2. Pour la
simultanéité, toutes les opérations sont actives simultanément, l'activité résultante s'achève
seulement lorsque toutes les opérations sont achevées. La notation d'instanciation multiple est
utilisable pour le parallélisme.
Pour l'alternative, une seule opération devient active. Il faut donc y ajouter un critère de
sélection qui peut être déterministe ou probabiliste. Pour cela, le pourcentage pour chaque
opération ou une condition logique est associé au lien entrant. Une probabilité peut être utilisée,
ainsi que toute expression mathématique comme pour la durée. Le total doit toujours être de 1;
pour cela il y aura toujours une branche "else" ou notée aussi *.
La répétition exprime l'exécution conditionnelle (Repeat until, While) et inconditionnelle
(For). La notation graphique est celle de SES/Workbench. La répétition doit être spécifiée. Elle
peut être infinie (*) ou exprimée par une expression mathématique quelconque (comme pour
les temps). Il peut s'agir d'une exécution N fois (*N) ou d’une exécution tous les N fois
(correspond à une division (/N)). La répétition peut aussi être spécifiée par une condition de fin
(until (=)).
Pour les applications qui nous concernent, il est indispensable de pouvoir modéliser
l'activation d'une opération ou d'une activité parmi un ensemble et ceci lorsque la condition
associée devient vraie. On dit alors qu’il s’agit d’une activation conditionnelle avec garde. Il
s'agit d'une divergence OU mais dont la branche activée n’est pas prédéterminée comme pour
la divergence OU mais est fonction de conditions sur des entrées. Pour éviter toute confusion
d'interprétation, le symbole OR de la divergence n'est pas utilisé et est remplacé par une barre.
Lorsque l’opération précédente est achevée, il y attente des conditions E1 et E2 (figure 3.9). La
première condition présente engendre l’exécution de l’activité correspondante. Si les 2
conditions sont présentes simultanément, il y a sélection non-déterministe. La notation
textuelle utilise des crochets pour exprimer l’exécution alternative et le symbole ? pour
exprimer l’attente.
Le symbole «Exit» (carré noir) peut aussi être utilisée (voir plus loin) de manière à indiquer
la fin de l'activité courante, ceci pour faciliter la représentation graphique. Ce symbole sera
aussi utilisé pour sortir de l’activité englobante par un achèvement forcé.
A noter que pour respecter des règles de bonne structuration, tout résultat de composition
possède un point d’entrée temporel en dessus et surtout une seule sortie en bas. Ceci doit être
le cas pour toute activité composée. Elle peut alors s’exprimer comme une opération possédant
un attribut de temps représentant une vue macroscopique de l’activité.
3.6.4 Conditions d’évolution et actions
Un modèle doit être capable de représenter des dépendances temporelles autres que la fin
d'une opération ou d’une activité. Pour cela, il faut exploiter les entrées de la fonction
considérée du modèle structurel et disposer d’une technique pour exprimer des interactions
internes à la fonction et de celle-ci avec son environnement.
Chapitre 3
72 M.C.S.E
-A- Activation conditionnelle
L'évolution d'une activité ou d’une opération doit pouvoir être conditionnelle à une entrée.
La notation retenue est la suivante.
-Figure 3.10- Représentation d’une évolution conditionnelle.
Cette notation (a) se veut explicite pour bien montrer que lorsque Op1 s'achève, il y a
attente de E pour poursuivre par A2. Op1 ne s'achève qu'après son temps d'exécution et non pas
dès la présence de E (comportement non-préemptif). Dans la notation textuelle, le symbole?
est utilisé pour décrire l’attente.
Ainsi, cette notation est différente de celle utilisée pour un diagramme d'états (b): l’état A1
est quitté dès la présence de E, l’état A1 ne peut pas être quitté sans E. Dans un SpecChart (c)
[GAJSKI-94], une différence est introduite entre TOC (Transition On Completion) qui veut
dire que l’état A1 est achevé mais n’est quitté que sur la condition E, de l'état TI (Transition
Immediately) qui correspond au diagramme à états finis ou au Statechart: sortie immédiate de
A1 sur la condition E.
-B- Construction d'une condition
Une condition d’évolution s'élabore à partir des entrées disponibles. Les opérateurs de
composition qui concernent des occurrences sont:
- & pour le ET séquentiel qui impose une relation d'ordre strict d'apparition,
- ^ pour le ET logique sans ordre d'apparition,
- OR pour le OU logique,
- S pour la sélection.
La figure 3.11 donne la représentation graphique et la notation textuelle pour ces 4
compositions. Pt[:] veut dire le vecteur complet. Le symbole ? est utilisé pour exprimer une
condition.
-Figure 3.11- Symboles pour la description d’une condition composée.
Rappelons que les 3 types de relation pour le modèle de structure sont:
- la synchronisation (événement),
- le transfert d'information,
Op1
E
A2
A1
A2
E
TOC
TI
Op1&?E&A2
a) b) c)
A1
E
E
A1
E1
E2
Op1&?(E1&E2)&A1
E1
E2
Op1&?(E1^E2)&A1
E1
E2
Op1&?(E1|E2)&A1 Op1&?$Pt[:]&A1
ET sans ordre
Pt[1:n]
Ordre strict L’un Sélection
& ^ OR S
‘Path
Le modèle de performance de MCSE
M.C.S.E 73
- la donnée ou ressource partagée.
Pour ce dernier cas (lien double flèche dans le modèle comportemental), il faut différencier
le cas de la donnée partagée du cas de la ressource commune. Pour la donnée partagée, il peut
s'agir d'une lecture (consultation) ou d'une évolution souhaitée après une modification faite par
une autre activité. Pour différencier les 2 cas, un attribut est associé au lien: ‘Read, ‘Change ou
‘Write.
Dans le cas d'une ressource partagée, il s'agit d'une demande d'allocation de la ressource.
Lorsque la ressource est libre la condition d’évolution est vraie et dans ce cas la ressource est
allouée. Pour plusieurs entrées de ressources, le OU conduit à l'obtention d'une ressource libre
parmi l'ensemble des ressources possibles, le ET sans ordre correspond au cas de la nécessité
de disposer de toutes les ressources, et le ET avec ordre impose l'ordre d'obtention des
ressources.
L’opérateur de sélection permet de spécifier l’entrée considérée. Celle-ci est indiquée par
un attribut particulier appelé ‘Path associé à l’opérateur. La sélection peut être fixe
(‘Path=Pt[5], ‘Path=me‘Index) ou dynamique en exploitant le contenu de messages ou de
transactions (‘Path=mess‘Id) transitant par le sélecteur. Ceci est décrit plus loin.
Cette notation est exploitable en mixant les 3 types d'entrée: synchronisation, transfert
d’information et donnée permanente. De plus, elle s'avère aussi utilisable pour des
instanciations multiples d'éléments de relation, en particulier avec la sélection.
-C- Actions
Les actions concernent la génération d'information ou d'événements vers les sorties de la
fonction ou vers d’autres activités internes. Pour un élément partagé, il s'agit de son
exploitation: écriture, modification pour une donnée partagée, libération pour une ressource.
Pour des raisons de lisibilité et de structuration, les actions ne sont pas effectuées durant
une opération mais après des opérations ou activités. La figure 3.12 donne la représentation
graphique et la notation textuelle correspondante. Le symbole ! est utilisé pour exprimer la
génération.
-Figure 3.12- Représentation pour la génération d’actions.
Une action vers des sorties peut concerner les 3 types de relation.
L'alternative conduit à ne générer qu'une seule sortie. Une règle doit être définie pour
discerner la sortie concernée: déterministe, probabiliste. Pour cela, à chaque lien de sortie est
affecté un pourcentage, l'un des liens possède le qualificatif "else", sachant que ce cas n’est pas
obligatoire, ce qui veut dire qu’il n’y a pas toujours génération d’une sortie.
S1
&
S2
Op&!(S1&S2)
S
Op&!$Pt[:]
Pt[1:n]
Op
Op&!S
Op
S
S1
OR
S2
Séquence
Alternative Sélection
Op&!(<0.5>S1|<*>S2)
^ pour Simultanéité
Op&!(S1^S2) ‘Path
0.5
*
Chapitre 3
74 M.C.S.E
Le symbole Séquence (&) fixe l'ordre de génération avec exclusion. Le symbole
Simultanéité (^) représente une génération commune qui ne s'achève que lorsque toutes les
générations ont été faites en tenant compte des temps d’écriture.
Le symbole Sélection permet de représenter l’aiguillage vers une sortie particulière. La
sortie concernée est désignée par l’attribut ‘Path associé à l’opérateur. Il peut s’agir d’une
désignation statique (‘Path=me‘Index) ou d’une désignation dynamique (‘Path=‘Id) ce qui
signifie l’aiguillage vers le destinataire désigné dans la transaction ou message. me‘Index
représente l’indice de l’activité courante.
3.6.5 Raffinement d’une activité et modèle réutilisable
Une activité peut se raffiner à l’aide des opérateurs décrits précédemment. Elle ne possède
obligatoirement qu’une entrée et une sortie temporelle pour représenter le début et la fin de
l’activité.
La figure 3.13 illustre la technique de raffinement. Plusieurs caractéristiques intéressantes
y sont représentées.
-Figure 3.13- Raffinement d’une activité et achèvement forcé.
L’activité A11 inclut 2 branches concurrentes ou simultanées mais qui ne sont pas
temporellement indépendantes. Le lien Lt sert à assurer une synchronisation (lien simple
flèche) entre la fin de A111 et le début de Op3. Lt est un élément du type information car il
possède un type; il se définit par des attributs similaires au port de communication. Cmd est un
lien du type événement; il possède les attributs d’un événement. Ainsi une activité raffinée peut
exploiter des liens de 3 types: information, événement, donnée partagée - chacun défini par les
attributs décrits pour les 3 types de relation du modèle structurel.
&
Op1
Lt:DefLt
Cmd
A1 :: A11/?Stop#
Op2 Op3
Stop
A1
A11
A11 :: (A111&!Lt&Op2)||
(Op1&!Cmd&?Lt&Op3)
A111
Le modèle de performance de MCSE
M.C.S.E 75
L’activité A1 montre un raffinement particulier puisque le symbole "Exit" est utilisé (carré
noir). A1 est simultanément en exécution de A11 et en attente de l’événement Stop. Lorsque
celui-ci apparaît, il y a achèvement immédiat de l’activité A1 et donc de toutes les activités
incluses (A11 en l’occurrence). De même lorsque A11 s’achève, le symbole Exit associé
engendre l’achèvement de A1 et donc la suppression de l’attente sur Stop. Le symbole Exit
permet donc une simplification de la représentation pour l’achèvement d’une activité. Mais il
permet aussi lorsqu’il est utilisé comme source pour une activité d’engendrer un achèvement
forcé ou inconditionnel de cette activité. Ceci est une forme de comportement préemptif. Les
règles de construction permettent seulement à une activité de ne supprimer que des activités
inclues (A11 est inclue dans A1). Le symbole "#" représente Exit dans la description textuelle
et le symbole "/" représente la préemption.
Pour certaines descriptions, la même activité doit être utilisée à des instants différents ou/
et dans des activités ou fonctions différentes ou doit être instanciée plusieurs fois.
Pour faciliter la modélisation, il faut pouvoir disposer de la notion de modèle d’activité,
tout comme la notion de modèle de fonction existe pour le modèle structurel. Aussi, une
activité peut se définir par un modèle possédant des paramètres qui définissent les liens
utilisables en entrée et en sortie pour le flot de données. Des valeurs génériques associées à
l’activité permettent aussi de disposer d’activités génériques de manière à créer au moment de
l’instanciation une activité avec des caractéristiques particulières.
3.6.6 Attributs et paramètres du modèle de comportement
Pour pouvoir extraire des résultats, il faut ajouter au modèle décrit précédemment tous les
paramètres ou attributs nécessaires. Ces attributs sont associés sous forme textuelle au
composant décrit.
On différencie une valeur d'une grandeur paramètre. Une valeur pour un attribut est
déterminée par son expression textuelle: constante, résultat d'un calcul, valeur probabiliste.
Un paramètre est une grandeur qui peut varier dans un domaine de définition donné. Par
exemple, la taille d'un message, la puissance d'un processeur, le facteur N d'instanciation
multiple peuvent être des paramètres d'une modélisation qui servent à étudier son influence sur
les résultats. La valeur d’un paramètre peut être modifiée entre 2 simulations ou peut même
varier durant une simulation (incrémentation par exemple).
Un paramètre est utilisable dans toute expression. Durant une évaluation, un seul paramètre
au maximum doit être considéré comme variable. Si plusieurs existent, une valeur doit être
fixée pour tous les autres.
Les attributs servent à définir des valeurs aux constituants du modèle. Les attributs
considérés ici ne concernent que le modèle comportemental car les attributs pour le modèle
structurel ont été vus précédemment. Il s'agit ici des attributs de temps (‘Time), de taille de
données ou d'information (‘Size), de sélection de chemin (‘Path), de condition (‘Cond),
d'identification (‘Id).
-A- Attributs ‘Time, ‘Write, ‘Read
L’attribut ‘Time sert à définir le temps nécessaire pour une opération ou une activité et les
attributs ‘Write et ‘Read pour une interaction avec l'environnement: lecture d'une donnée,
dépôt d'un message, etc.
Chapitre 3
76 M.C.S.E
A1‘Time = 5 ms;
Op‘Time = exp (10) s;
T_Req‘Write = (K + 0,5 x T_Req‘Size) ms;
T_Req étant ici un port, l'attribut ‘Size du message ou de tout autre message est utilisable
dans une expression temporelle. K est ici considéré comme un paramètre. "exp" est une
fonction probabiliste selon une loi exponentielle.
Un temps est obligatoirement associé aux éléments de relation (voir les attributs du modèle
structurel). Toutefois, il est aussi possible d'ajouter dans le modèle comportemental un temps
‘Write ou ‘Read aux liens d'accès pour surcharger celui de l’élément de relation.
-B- Attribut ‘Size
L’attribut ‘Size sert à définir la taille d'une donnée échangée ou d'un objet de transaction
(un message émis par exemple).
T_Req‘Size = Uniform(5, 160) bits;
P_send‘Size = (L_Req‘Size + 64) bits;
Les unités à utiliser dépendent de l'application modélisée (bits pour un système de
communication, mots pour une variable partagée, poids pour une pièce, etc). Ainsi, les unités
sont définies par l’utilisateur (les plus courantes étant définies par défaut). Les expressions
doivent rester cohérentes pour les unités.
Lorsque la taille concerne un objet de transaction, l'attribut est associé au lien, sinon elle est
associée à l'élément de relation et est dans ce cas utilisé par défaut.
-C- Attribut ‘Id
Cet attribut est défini pour identifier une information ou un objet dans le cas d'un transfert.
Sa valeur est un nombre entier qui peut être:
- une suite croissante,
- un tirage aléatoire dans un intervalle,
- l'indice de l'élément englobant (me‘Index).
me‘Index veut dire l’indice de l’élément courant dans le cas d’une instance multiple.
-D- Attribut ‘Path
L’attribut ‘Path sert à définir le chemin qui sera choisi dans le cas d'une sélection. Il est
possible d’utiliser une désignation fixe ou d’exploiter l'identité (‘Id) du contenu dans le cas
d'une information. Ce dernier cas permet de modéliser un comportement conditionnel au flot
d’information.
La méthode d’aiguillage par la sélection est différente de la divergence OU. Pour la
divergence, une expression fixe la probabilité pour chaque branche. La somme de toutes les
branches doit donner 1 au maximum. Ainsi, l'une des branches peut prendre la valeur "else".
Si aucune valeur n'est fixée, il s'agit d'une sélection équiprobable, donc sélection à tour de rôle.
-E- Attribut ‘Cond
Cet attribut est utilisé pour l’opérateur Répétition. Il peut s'agir:
- d'une exécution N fois (*N),
- d'une exécution une fois tous les N (/N),
- d'une exécution jusqu'à une condition (=expression).
Le modèle de performance de MCSE
M.C.S.E 77
Une expression mathématique quelconque est utilisée pour spécifier N ou la condition. La
valeur N est calculée à l'entrée dans le symbole. Par contre la condition est évaluée à chaque
sortie possible.
Pour l'exécution N fois, si N n'est pas spécifiée, il s'agit d'une exécution infinie.
-F- Attributs sur les liens
Des attributs sur les liens sont parfois nécessaires pour fixer d’une manière plus fine le
comportement souhaité. Ces attributs sont associés aux informations en transit pour les
attributs Id et Size, ou sont associés aux entrées et sorties de la fonction ou de l’activité décrite.
Les attributs ‘Read et ‘Write sont aussi utilisables.
-G- Attributs utilisateur
Tout autre attribut peut être ajouté par l’utilisateur sur son modèle, en particulier lorsqu’il
s’agit de spécifier un contenu de variable partagée ou d’un message. Ces attributs se traduisent
alors par des champs de données supplémentaires exploitables par toute fonction, activité ou
opération pouvant y accéder.
-H- Paramètres génériques
Toute valeur d’attribut peut se définir par une expression mathématique. Pour étudier
l’influence d’un ou plusieurs paramètres, ceux-ci sont utilisés dans l’expression de calcul de
l’attribut et déclaré comme paramètre générique pour le composant.
3.7 EXEMPLE DE MODELISATION
L’exemple que nous décrivons dans ce paragraphe permet de voir l’application et l’intérêt
du modèle de performance de MCSE sur un système simple mais intéressant. Il s’agit d’une
version très simplifiée du serveur vidéo temps-réel extrait du problème global posé par le
CCETT de Rennes et présenté dans le chapitre 7.
Le rôle d’un tel serveur est de transmettre en temps-réel à chaque utilisateur sur son
téléviseur le film vidéo qu’il sélectionne. Le système est imaginé capable de servir N
utilisateurs simultanément. L’objectif de la modélisation de performances est de permettre de
dimensionner l’architecture de la solution: nombre de disques nécessaires, nombre de
processeurs ou puissance du processeur pour un nombre N d’accès simultanés, taille mémoire
interne nécessaire, etc. L’exemple et les résultats obtenus ont été présentés dans [CALVEZ-
95a] [CALVEZ-96d].
3.7.1 Modèle de performance pour le serveur
Nous ne détaillons pas ici la spécification du système. Le lecteur trouvera ces informations
dans le chapitre 7. Nous donnons directement la solution fonctionnelle permettant une
estimation de performances. La figure 3.14 représente la description fonctionnelle retenue pour
le serveur et les 3 entités de son environnement. Il s’agit d’un modèle générique et très abstrait
car: les disques contenant les films sont modélisés par une variable partagée, les lignes de
transmission et les interfaces nécessaires sont modélisées par des ports de communication.
Chapitre 3
78 M.C.S.E
-Figure 3.14- Solution fonctionnelle pour l’application Serveur vidéo.
Un utilisateur (User[i]) sélectionne un film en produisant un ordre Cmd. La fonction
Supervision vérifie la demande et si elle correcte et que l’usager est autorisé, une demande de
lecture OrderRead[i] ou d’enregistrement OrderRec est transmis. La fonction Recording se
charge de l’enregistrement d’un film sur les disques du serveur à partir de l’entité Source. Les
films sont enregistrés sous la forme d’un ensemble de blocs successifs, chaque bloc étant de
taille fixe. Une fonction ReadMovie est associée à chaque usager. Une telle fonction débute par
la lecture de A (figure 3.16-c) blocs sur disques puis assure la transmission des blocs un par un
vers le téléviseur correspondant tout en poursuivant la lecture des blocs suivants. Le paramètre
A est à déterminer pour éviter toute rupture de séquence. La période de transmission des blocs
est définie par le débit pour le film (déterminé par la qualité et le codage en compression).
Sur la figure 3.14, on voit que toutes les fonctions ReadMovie sont considérées implantées
sur un même processeur P. Ceci va permettre d’étudier l’influence de cette ressource comme
contrainte d’exécution. Son degré de concurrence ‘Concurrency est M et sa puissance ‘Power
est supposée de 1 par défaut. L’ensemble des disques est modélisé par une variable partagée
possédant les attributs ‘Concurrency décrivant le nombre de disques à accès simultanés, ‘Read
et ‘Write comme temps de lecture et d’écriture d’un bloc au contrôleur d’un disque, ‘Use
comme temps d’utilisation du disque.
Cmd
BlockIn
BlockOut[1:n]
Disks
OrderRead[1:n]
Recording ReadMovie
Supervision
Processor P
OrderRec
P‘Concurrency=M;
Source
User[1:n]
Avions
TV set[1:n]
Disks‘Concurrency = ND;
Disks‘Write = 1 ms;
Disks‘Read = 1 ms;
Disks‘Use = 20 ms;
‘Capacity = 0; ‘Capacity = 0;
‘Capacity = *;
P‘Power=1;
Le modèle de performance de MCSE
M.C.S.E 79
Le comportement de chacune des 3 entités de l’environnement est décrit par la figure 3.15.
-Figure 3.15- Comportement des entités de l’environnement.
L’entité User génère après un temps aléatoire entre 1 et 5 secondes un ordre Cmd
comprenant les attributs: ‘Id qui est l’identité de l’usager, ‘Size représentant la taille en nombre
de blocs de 32 ko, ‘Speed qui définit la vitesse de transmission en lecture ou en enregistrement
(valeur aléatoire ici). Cette entité permet ainsi de définir complètement la charge du système
(workload).
Un téléviseur est modélisé comme un récepteur attendant les blocs successifs sur sa ligne
de réception modélisé par BlockOut[] séparés apr une attente égale à la période entre 2 blocs
consécutifs. Ce temps est défini par le débit contenu comme attribut du message. La rupture
de séquence en lecture se détecte par le non-respect de la contrainte de temps T qui correspond
à la période.
La source est modélisée comme un générateur idéal de blocs. Les ports BlockOut[:] et
BlockIn sont du type rendez-vous (‘Capacity=0).
Le comportement de chacune des 3 fonctions de la solution interne fonctionnelle est décrit
par la figure 3.16.
-Figure 3.16- Comportement des fonctions internes du serveur.
Blockout[]
*
Tcons
Tcons‘Time = k/BlockOut[]‘Speed ms;
*
Cmd
‘Size=random(50, NbFmax);
‘Speed=random(0, 4) Mb/s;
‘Id=Me;
User
WaitEnd‘Time=30 s;
TV Set[]
WaitUser‘Time=random(1, 5) s;
WaitUser
WaitEnd
*
BlockIn
Source
Wait‘Time=0 s;
Wait
Contrainte
T<=Tcons‘Time
OrderRead[]
ReadMovie
OpWrB
Disks
OpWrB
Buffer: Block;
*A
&
c)
*OrderRead[]‘Size
Disks‘Use=20 ms;
OpWrB‘Time=1 ms;
Buffer‘Read=2 ms;
Buffer‘Write=2 ms;
BlockOut‘Write=5 ms;
Cmd
*
OpRec OpRead
Else
‘Path=‘Id;
‘Proba
OR
S
OrderRec OrderRead[:]
‘Size=Cmd‘Size; ‘Size=Cmd‘Size;
OpRead‘Time = 1 ms;
OpRec‘Time = 1 ms;
‘Speed=Cmd‘Speed;
‘Speed=Cmd‘Speed;
‘Id=Cmd‘Id;
Recording
a)
Supervision
b)
SendBlocks
k est une constante
BlockOut[]
ReadMovie‘Priority=OrderRead[]‘Speed;
Buffer
OrderRec
OpWr
* OrderRec‘Size
BlockIn
Disks
OpWr‘Time=1 ms;
‘Read=
w/OrderRec[]‘Speed - 3
Chapitre 3
80 M.C.S.E
La fonction Supervision attend les demandes des usagers par l’entrée Cmd. Si la demande
est correcte, un tirage aléatoire (Proba) permet d’orienter l’ordre vers la fonction
d’enregistrement Recording par OrderRec ou vers une fonction de lecture ReadMovie associée
au téléviseur du même indice par OrderRead[‘Id]. Les attributs ‘Size et ‘Speed de Cmd sont
transmis par OrderRec ou OrderRead[].
La fonction Recording assure la lecture auprès de la source de Size blocs et leur copie sur
les disques. Le temps de lecture est défini par la vitesse de transmission qui dépend de l’attribut
‘Speed reçu.
La fonction ReadMovie assure la lecture des blocs successifs sur les disques et leur transfert
vers le téléviseur. Pour éviter un défaut de séquence au début par suite de la latence des disques,
cette fonction se charge de lire A blocs en anticipation et les stocke dans Buffer. Ensuite,
chaque bloc de Buffer est transmis et un nouveau bloc est lu sur disques. Buffer est une fifo de
capacité supposée infinie. La priorité d’exécution de ReadMovie dans le cas d’un processeur
restreignant le degré de concurrence est définie en rapport avec la vitesse de transmisssion
défini par l’attribut ‘Speed reçu.
3.7.2 Description textuelle du serveur vidéo
Le modèle graphique ci-dessus est transcriptible en une notation textuelle. La description
suivante donne l’écriture textuelle pour l’ensemble de l’application Serveur Vidéo. Ce texte
sert de point d’entrée au générateur de code VHDL présenté dans le chapitre 6.
<RelationTypes>
DefCmd;
DefBlockIn;
DefBlockOut;
DefOrderRec;
DefOrderRead;
DefSequences;
Block;
<EndRelationTypes>
<GenericParameters>
n,INTEGER,"nonbre de canaux haut debit",10;
nd,INTEGER,"nombre de disques",10;
A,INTEGER,"taille des fifo",4;
<EndGenericParameters>
<FunctionalStructure>
<Component> ServeurVideoSimple Generic n,nd,A
();
<Structure> StructureServeurVideoSimple;
<Port> Cmd : DefCmd;
<Port> BlockIn : DefBlockIn;
<Attributes>
`Capacity=0;
<EndAttributes>
<Port> [1:n] BlockOut : DefBlockOut;
<Attributes>
`Capacity=0;
<EndAttributes>
<Component> [1:n] User
(Out Mess Cmd : DefCmd;);
<Attributes>
Cmd`Id = me;
Cmd`Size = UniformInt(50,120);
Cmd`Speed = UniformInt(100,4000);
WaitUser`Time = UniformTime(1000,5000,ms);
Le modèle de performance de MCSE
M.C.S.E 81
WaitEnd`Time = 30 sec;
<EndAttributes>
<Behavior> BehaviorUser;
User::{WaitUser&!Cmd&WaitEnd}*;
<EndBehavior>
<EndComponent>
<Component> Source
(Out Mess BlockIn:DefBlockIn;);
<Attributes>
Wait`Time=NullTime;
<EndAttributes>
<Behavior> BehaviorSource;
Source::{Wait&!BlockIn}*;
<EndBehavior>
<EndComponent>
<Component> [1:n] TVset
(In Mess BlockOut[]:DefBlockOut;);
<Attributes>
Tcons`Time=(262136/BlockOut[]`Speed) * 1 ms;
<EndAttributes>
<Behavior> BehaviorTVSet;
TVset::{?BlockOut[]&Tcons}*;
<EndBehavior>
<EndComponent>
<Component> ServeurVideo
(In Mess Cmd:DefCmd;
In Mess BlockIn:DefBlockIn;
Out Mess BlockOut[1:n] : DefBlockOut;);
<Structure> StructureServeurvideo;
<Var> Disks : DefSequences;
<Attributes>
`Concurrency=nd;
`Use=20 ms;
`Write=1 ms;
`Read=1 ms;
<EndAttributes>
<Port> OrderRec : DefOrderRec;
<Port> [1:n] OrderRead : DefOrderRead;
<Component> Supervision
(In Mess Cmd:DefCmd;
Out Mess OrderRec:DefOrderRec;
Out Mess OrderRead[:]:DefOrderRead;);
<Attributes>
OrderRec`Size=Cmd`Size;
OrderRec`Speed=Cmd`Speed;
OrderRead[:]`Path=`Id;
OrderRead[]`Id=Cmd`Id;
OrderRead[]`Size=Cmd`Size;
OrderRead[]`Speed=Cmd`Speed;
OpRec`Time=1 ms;
OpRead`Time=1 ms;
<EndAttributes>
<Behavior> BehaviorSupervision;
Supervision::{?Cmd&(<0.00001>(OpRec&!$OrderRec)
<*>(OpRead&!$OrderRead[:]))}*;
<EndBehavior>
<EndComponent>
<Component> Recording
(In Mess BlockIn:DefBlockIn;
In Mess OrderRec:DefOrderRec;
InOut Var Disks:DefSequences;);
<Attributes>
Chapitre 3
82 M.C.S.E
BlocIn`Read=(262136/OrderRec[]`Speed) * 1 ms;
OpWr`Time=1 ms;
<EndAttributes>
<Behavior> BehaviorRecording;
Recording::{?OrderRec&({?BlockIn&OpWr&!Disks}*OrderRec`Size)}*;
<EndBehavior>
<EndComponent>
<Component> [1:n] ReadMovie
(In Mess OrderRead[]:DefOrderRead;
In Var Disks:DefSequences;
Out Mess BlockOut[]:DefBlockOut;);
<Attributes>
BlockOut`Write=5 ms;
Buf`Read=2 ms;
Buf`Write=2 ms;
OpWrB`Time=1 ms;
<EndAttributes>
<Behavior> BehaviorReadMovie;
<InfoLink> Buf:Block;
<Attributes>
`Capacity = A;
<EndAttributes>
<EndInfoLink>
ReadMovie::{?OrderRead[]&({?Disks&OpWrB&!Buf}*A)&SendBlocks}*;
SendBlocks::{(?Disks&OpWrB&!Buf) ||
SendBlock{`Priority=me+1;}:(?Buf&!BlockOut[])}*OrderRead[]`Size;
<EndBehavior>
<EndComponent>
<EndStructure>
<EndComponent>
<EndStructure>
<EndComponent>
<EndFunctionalStructure>
3.8 CONCLUSION
Ce chapitre a permis de formaliser et d’illustrer le modèle de performance de MCSE. Pour
cela, les caractéristiques d'un tel modèle ont tout d'abord été présentées, ainsi qu'une analyse
des concepts essentiels avec leurs propriétés. Le modèle de performance a ensuite été décrit en
présentant successivement les 2 vues que sont la vue structurelle et la vue comportementale.
Le modèle retenu satisfait les critères présentés dans le paragraphe 3.2. Les critères de
lisibilité et de compréhensibilité sont satisfaits grâce à l’emploi d’une notation essentiellement
graphique. L’efficacité de déduction provient de l’intégration complète du modèle de
performance à la méthodologie de conception système MCSE. La continuité du modèle par
transformation d’un comportement en un modèle structurel facilite la transition d’une phase de
conception à la suivante et assure la traçabilité. L’efficacité d’évaluation résulte du modèle
(généricité et réutilisabilité) et de la technique de simulation associée. La technique de
simulation associée au modèle repose sur la transcription de la représentation textuelle du
modèle en un langage exécutable ou simulable. Comme nous le verrons dans le chapitre
suivant, nous avons retenu et expérimenté l’utilisation du couple VHDL/Simulateur VHDL.
Basé sur l’association de la vue structurelle et de la vue comportementale, le modèle de
performance de MCSE est:
- évolutif. Le concept d’attribut pour définir des propriétés aux constituants permet
d’enrichir le modèle à volonté.
Le modèle de performance de MCSE
M.C.S.E 83
- macroscopique. Le système n’a pas besoin d’être entièrement détaillé. Pour une
évaluation des performances, les opérations sont caractérisées par un temps d’exécution
et non par un algorithme particulier de traitement. Une évaluation des performances
peut donc se faire à un niveau quelconque d’abstraction et éventuellement très tôt dans
le cycle de développement.
- non-interprété. Le terme non-interprété signifie que seul le comportement ou les
dépendances temporelles entre les sorties et les entrées sont observées. Les valeurs en
entrée et celles des données internes ne sont pas prises en compte. Les entrées et les
données internes influencent le comportement du système uniquement par
l’intermédiaire d’attributs. Par exemple, les attributs ‘Size (taille) et ‘Id (destinataire)
d’un message remplacent le contenu du message.
- générique et paramétrable. L’utilisation de paramètres génériques associés aux
attributs des éléments du modèle de performance permet de parcourir un espace assez
vaste des solutions possibles d’un partitionnement sans nécessiter de mise à jour du
modèle de performance.
Un modèle seul n'est pas suffisant. Un modèle doit toujours être accompagné d’une
démarche favorisant l’élaboration de solutions. Rappelons que la modélisation de
performances a pour objectif de spécifier quantitativement les propriétés temporelles d’une
solution. Une solution est une représentation de la vision du concepteur tout au long du
processus de développement. Elle évolue depuis la spécification jusqu’au système réalisé. La
démarche de modélisation des performances d’un système doit permettre d’élaborer une
représentation des propriétés du système à différents stades du développement. Ainsi plusieurs
modèles de performances sont développés, tout d’abord un modèle macroscopique pour
représenter les spécifications de performances, ensuite des modèles de plus en plus détaillés
faisant apparaître la structure interne retenue pour le système comme résultat d’une phase de
conception. Cette démarche a été expliquée dans le chapitre 2.
Notre modèle est très utile pour la problématique du CoDesign qui correspond à l’étape de
définition de la réalisation de la méthodologie MCSE. Pour une solution faisant intervenir du
matériel et du logiciel, lorsque plusieurs fonctions s’exécutent sur un même processeur
séquentiel, notre modèle permet de représenter et de simuler l’exécution d’un ensemble de
fonctions sur un processeur. Ainsi, il est possible d’observer l’influence de la politique
d’ordonnancement (attribut ‘Policy) et de la puissance du processeur (attribut ‘Power). Notre
modèle autorise aussi la co-simulation macroscopique et non-interprétée des fonctions
logicielles et des composants matériels, ce qui permet alors au concepteur de trouver par une
démarche itérative le partitionnement et l’allocation optimale vis à vis des critères de coûts et
de performances qui lui sont imposés. En remplaçant ensuite, les opérations élémentaires par
du code interprété, le concepteur peut également faire une vérification fonctionnelle de sa
solution.
Le modèle de performance présenté ici ne limite pas son champ d’application à l’analyse
des systèmes électroniques. En donnant une signification différente à ces concepts, il peut aussi
être utilisé par exemple pour l’analyse de tout type d’architecture, des réseaux de
communication, la gestion de production et des stocks, voir même la gestion des ressources
humaines.
Chapitre 3
84 M.C.S.E

M.C.S.E 85
4
Transcription du modèle de
performance en VHDL
Le modèle de performance de MCSE décrit dans le chapitre 4 représente un investissement
de plus de 5 ans de la part de l’équipe MCSE. L’objectif de l’équipe était d’aboutir à un modèle
de performance intégré à la méthodologie de conception complète MCSE et à une technique
d’évaluation de ce modèle pour analyser des architectures de systèmes tout au long du cycle de
développement. Pour l’évaluation du modèle de performance, plusieurs approches ont été
envisagées: une évaluation analytique, le développement d’un simulateur spécifique et la
transcription du modèle en un langage simulable. L’évaluation analytique qui nécessite la
transcription du modèle en un modèle analytique (réseaux de Petri stochastiques ou de files
d’attentes par exemple) n’a pas été retenue car nous pensons qu’elle est mal adaptée à la
complexité des systèmes considérés dans cette étude. La seconde solution est également en
cours d’expérimentation. Elle repose sur la transcription du modèle de performance en un
programme multi-tâches C++ et sur l’utilisation du noyau multi-tâches de Windows95/NT
pour son exécution. La solution basée sur l’emploi d’un langage simulable est celle décrite dans
ce chapitre. Le langage de simulation retenu ici est VHDL.
Aussi, l’objectif précis de ce chapitre est de détailler les règles de traduction développées
pour aboutir à un modèle VHDL simulable capable de produire les résultats de performances
souhaités. Le résultat de ce chapitre est important car il sert ensuite de base pour l’intégration
des règles de traduction dans l’outil de génération VHDL présenté dans le chapitre 6. Nous
commençons par décrire la technique retenue pour l’évaluation de performances. Nous
justifions ensuite le choix du langage VHDL. Certaines propriétés intrinsèques du langage
VHDL (parallélisme inhérent, instanciation multiple, paramètres génériques, etc.) facilitent la
transcription et la simulation de notre modèle de performance. Mais, le langage VHDL pour la
Chapitre 4
86 M.C.S.E
simulation de notre modèle de performance souffre également de quelques restrictions. Ces
restrictions et notamment l’absence de mécanisme de suspension de process, nous ont amenés
à définir un modèle de simulation qui modélise un processeur logiciel sous la forme d’un
composant ordonnanceur chargé de gérer les différentes tâches (fonctions) allouées au
processeur.
La description des règles de transcription se poursuit avec la définition des règles
concernant la transcription de la composante structurelle du modèle de performance. Un
composant actif (fonction, processeur) est transcrit sous la forme d’une entité ou d’un block,
ce qui permet de préserver la hiérarchie du modèle MCSE source, la trace des entrées/sorties
d’un composant actif (port map) et la généricité (generic map). Un élément de relation est
transcrit par une entité générique qui est instanciée sous la forme d’un composant. Le couplage
entre un composant actif et un élément de relation est effectué avec un protocole de
communication en 4 phases. Ce protocole est implanté sous la forme d’un signal bidirectionnel
et d’une fonction de résolution.
Pour la transcription de la composante comportementale du modèle de performance, le
comportement de chaque fonction est modélisé comme un ensemble de process synchronisés
et coopérants. Nous décrivons alors le mécanisme de synchronisation de process concurrents
et les principes de transcription de toutes les autres constructions du modèle de comportement:
la séquence, l’alternative, la répétition, l’activation conditionnelle, l’achèvement forcé
d’activités, les conditions d’activations et les actions. La construction la plus complexe à
traduire est l’achèvement forcé d’activité qui est à rapprocher des EI Arcs (Exit Immediately)
d’un SpecChart [GAJSKI-93].
Parmi les restrictions du langage VHDL pour la simulation de notre modèle de
performance, la plus contraignante est le manque de généricité pour la déclaration des types.
Cette restriction a deux implications:
- sur la déclaration des primitives d’accès aux éléments de relation. Il faut regrouper tous
les types des éléments de relation en un seul type (record) ou définir autant de primitives
d’accès qu’il y a de types différents (surcharge de procédure),
- sur la déclaration des signaux connectant l’entité ou le block d’un élément actif au
composant d’un élément de relation. Un lien de connexion entre un composant actif et
un élément de relation est traduit sous la forme d’un vecteur uni-dimensionnel ou
bi-dimensionnel dont il faut gérer les indices et la répartition (utilisation alias).
Lors de la simulation du programme VHDL, des informations pertinentes doivent être
extraites pour analyser les résultats de performance. La technique d’extraction d’informations
retenue repose sur l’utilisation d’une librairie de composants de monitoring qui génèrent des
fichiers exploitables par le logiciel GnuPlot ou sur la génération d’une trace d’événements qui
est utilisée par l’outil d’analyse des performances développé par l’équipe MCSE
[CALVEZ-95c] [CALVEZ-98a]. L’utilisateur peut également rajouter au code VHDL généré
des instructions de captures spécifiques et utiliser les possibilités d’observations offertes par le
simulateur VHDL utilisé.
Les règles de transcription ont été validées en autres sur l’exemple simplifié du serveur
vidéo dont le modèle de performance a été présenté dans le chapitre 3. Nous présentons donc
dans ce chapitre à titre d’illustration les résultats de performance obtenus pour l’exemple. Le
Transcription du modèle de performance en VHDL
M.C.S.E 87
chapitre 7 détaille aussi 2 autres exemples qui ont permis de valider et d’enrichir les concepts
du modèle de performance et la technique d’évaluation associée.
4.1 TECHNIQUE POUR L’EVALUATION DE PERFORMANCE
Après avoir défini le modèle de performance, la phase suivante porte sur le développement
d’une méthode permettant l’évaluation des performances souhaitées par le concepteur. En
effet, rappelons que la procédure itérative à suivre par les concepteurs se décompose en 3
phases:
- modélisation incrémentale du système ou de l'application,
- évaluation des performances souhaitées,
- visualisation des résultats, interprétations et prise de décision.
La troisième phase conduit généralement à un retour sur la première phase pour modifier,
améliorer, poursuivre la décomposition du modèle, ou à un retour sur la deuxième phase pour
modifier la sélection des résultats demandés ou des paramètres de l'évaluation.
A noter que la deuxième phase se doit d'être la plus transparente et la plus efficace possible
pour l’utilisateur, l’objectif de ce dernier étant de permettre d’itérer rapidement entre les phases
3 et 1.
Le choix d'une méthode spécifique pour l’évaluation passe par une analyse des possibilités.
D'une manière générale, l'observation des propriétés d'un système peut résulter de 3 techniques
différentes:
- l'évaluation analytique (ou mathématique),
- la simulation,
- l'observation et la mesure.
L'évaluation analytique est appropriée pour un modèle dont tous les éléments sont décrits
d'une manière analytique, et si en plus il existe une méthode globale directe ou itérative
permettant de déduire les propriétés globales du modèle à partir de ses constituants. Nous
pensons que le modèle de performance retenu est beaucoup trop structurel et dynamique pour
que cette méthode puisse être appliquée.
L'observation et la mesure ne s'appliquent que sur un système réel que l'on place en
fonctionnement. Ceci suppose que toute la conception soit achevée et qu'un prototype existe.
La simulation est une technique appropriée pour un modèle dynamique. Ainsi, nous
pensons que seule cette technique est utilisable durant la spécification et la conception des
systèmes matériels/logiciels. Deux techniques de simulation sont possibles: l’utilisation d’un
simulateur spécifique pour le modèle ou la transcription du modèle en un langage pour lequel
un simulateur existe. Les deux techniques sont simultanément envisagées par l’équipe: emploi
du langage VHDL et un simulateur, emploi du langage C++ et exécution du programme dans
un environnement multi-tâches. Cette étude concerne par la solution par simulation VHDL.
Chapitre 4
88 M.C.S.E
La technique en développement est représentée par la figure 4.1.
-Figure 4.1- Démarche et outil pour l’évaluation des performances.
Le modèle du système à simuler est saisi par un outil graphique. Les attributs sont aussi
ajoutés. Cette description sauvée sous forme textuelle est ensuite transcrite en un programme
VHDL conformément à des règles de traduction que nous détaillons dans ce chapitre. Le
programme VHDL est instrumenté puis simulé pour obtenir les observations souhaitées.
La transcription du modèle concerne le modèle de structure (fonctionnel et exécutif) et le
modèle de comportement. La partie délicate concerne la prise en compte de l’élément
processeur qui conduit à restreindre le degré de parallélisme des fonctions qu’il supporte, mais
c’est cette particularité qui permet la co-simulation. Pour la compréhension de la méthode
globale, nous commençons par indiquer le modèle de simulation retenu pour la transcription
d’un constituant actif à degré de parallélisme limité. Au préalable, nous justifions le choix du
langage VHDL.
4.2 CHOIX DU LANGAGE VHDL
A première vue, le choix du langage VHDL conduit à disposer d’une excellente plate-forme
pour l’évaluation des performances aussi bien pour la simulation que pour l’extraction et
l’analyse des résultats.
Pour la simulation, les propriétés et certaines constructions du langage VHDL autorisent ou
facilitent la simulation de notre modèle de performance, à savoir:
- Parallélisme inhérent. La notion de process permet de simuler des tâches concurrentes
dont le comportement de chacune est purement séquentiel. VHDL possède donc une
propriété qui est aussi intéressante pour le co-design [ECKER-93]. En effet, une
simulation VHDL peut très bien permettre d’étudier un partitionnement logiciel/
matériel donné. Les descriptions concurrentes représentent alors les différents
processeurs matériels et logiciels et pour chaque processeur logiciel la partie logicielle
est représentée par une description séquentielle. Pour la description logicielle, il existe
dans le domaine public des outils de conversion de VHDL vers C et réciproquement.
Evidemment, cette conversion ne concerne que certaines constructions des "sequential
statements" du langage VHDL.
- Instanciation multiple (instruction Generate) qui permet la création multiple
(uniquement statique) de composants, de blocs ou de process.
Pour l’extraction de résultats, on peut facilement définir une librairie de composants
permettant d’extraire par exemple le taux d’occupation d’une ressource ou le débit sur un port
de communication. L’utilisation des possibilités de "debugging" et d’analyse du simulateur
Définition des attributs
Modèle
système
Saisie
Règles de transcription
Transcription
en VHDL
Paramètres, workload
Simulation
en VHDL
Interprétation
des résultats
Programme
VHDL
simulable
Modèle
graphique
Méthode en développement
graphique
du modèle
Transcription du modèle de performance en VHDL
M.C.S.E 89
utilisé (sortie sous forme de chronogrammes) permet aussi de visualiser en détail des résultats
de simulation.
L’analyse faite dans le chapitre 2 a montré qu’il existe un certain nombre d’outils
commerciaux ou universitaires pour l’analyse des performances d’un système. Certains tels
que Adept de l’université de Virginie (modèle UVa) et Cosmos de Omniview utilisent VHDL
pour simuler leurs modèles et extraire des informations. Les autres parmi lesquelles on peut
citer en autres SES/WorkBench, RDD100 et BOnes ont un formalisme, un simulateur et des
possibilités d’analyse des résultats qui leur sont propres. Par rapport à cette seconde catégorie
d’outils spécifiques, l’emploi de VHDL offre un certain nombre d’avantages tels que:
- laportabilité. C’est un langage standard et normalement indépendant de tout vendeur.
Les modèles générés en VHDL peuvent s’échanger plus facilement entre différents
groupes de travail. L’emploi d’un langage unique élimine aussi tout risque d’erreurs ou
d’approximations de transcription.
- la lisibilité et la compréhensibilité. L’emploi de VHDL pour l’évaluation des
performances est intéressant pour avoir un meilleur impact sur la communauté des
concepteurs d’architectures matérielles habitués à utiliser VHDL. A cet égard, il est
indispensable que le code VHDL généré automatiquement à partir du modèle de
performance soit le plus lisible et compréhensible possible.
- lacomplétude. La vérification de la complétude et de la consistance du modèle généré
est assuré automatiquement par le compilateur/simulateur VHDL utilisé.
- la traçabilité. VHDL permet de décrire plusieurs niveaux d’abstraction du système,
plusieurs architectures pour un même composant et peut être utilisé durant tout le cycle
de développement d’un système.
- la disponibilité des outils. Il y a aujourd’hui de nombreux outils basés sur VHDL
disponibles sur la marché. L’utilisation conjointe de ces différents outils permet de
couvrir la plupart des phases de conception de la spécification à la réalisation. Sous
certaines conditions, des outils de synthèse haut-niveau (Behavioral Compiler de
Synopsys, SpecSyn de l’UCI, AMICAL de l’équipe Tima, GAUT du Lasti-Lester, etc.)
permettent même de transformer une description VHDL comportementale en une
description VHDL au niveau RTL. Cette description résultante est ensuite transformée
par synthèse logique en une netlist de portes et de bistables pour une implantation dans
un circuit.
Les propriétés intrinsèques du langage VHDL satisfont aussi certains critères de qualité
d’un modèle énoncés dans le chapitre 3:
- modèle hiérarchique. Les notions d’entité, de block et de composant permettent de
décomposer la description du système. On peut également définir plusieurs solutions
d’architecture pour une même entité et choisir l’architecture retenue uniquement au
moment de son instanciation (mécanisme de configuration). La notion de composant est
très importante car elle permet la réutilisation de modèle.
- modèle paramétrable. VHDL permet l’utilisation de paramètres génériques.
- modèle d’interdépendance. Très proche syntaxiquement du langage ADA, VHDL se
distingue des langages de programmation par le concept de signal.
Chapitre 4
90 M.C.S.E
Mais, l’utilisation de VHDL pour la simulation de notre modèle de performance souffre de
quelques restrictions:
- manque de généricité pour la déclaration des types. Par exemple, il n’est pas possible
de déclarer un type non contraint d’un type non-contraint ou de déclarer un type non
contraint dans un record.
- pas d’instanciation dynamique possible (uniquement statique).
- pas de mécanismes de suspension de process.
- l’utilisation d’un simulateur VHDL nécessite aussi des ressources de simulation
importantes (puissance de calcul, mémoire). Les temps de simulation relativement
importants même pour un modèle macroscopique et non interprété ne permettent pas de
parcourir très rapidement l’espace des solutions possibles.
Dans le projet RASSP, la modélisation de performance repose également sur l’utilisation
du langage VHDL et regroupe principalement l’Université de Virginie (modèle UVa/Adept),
Honeywell Technology Center, Lockheed Martin Advanced Technology Laboratories
[HEIN-95] et Omniview. L’outil Cosmos est par exemple le fruit de cette association et de ce
travail de recherche.
4.3 MODELE DE SIMULATION RETENU POUR L’EMPLOI DE VHDL
La transcription du modèle de performance en VHDL repose tout d’abord sur un bon choix
de solution d’implantation. La solution à retenir ici est très dépendante à la fois du modèle à
traduire et du langage cible. En effet VHDL possède un certain nombre de propriétés
intéressantes en particulier le parallélisme inhérent au langage qui permet aisément la
description et la simulation de systèmes décrits par du parallélisme.
Les particularités essentielles du modèle de performance qui ont servies au choix du modèle
de simulation sont les suivantes:
- instanciations multiples de fonctions, d’activités, d’opérations, d’éléments de relation,
- degré de parallélisme de chaque fonction (ou processeur) définissable, ce qui implique
une limitation du degré de partage d’une ressource,
- création dynamique d’activités,
- paramétrage complet du modèle par des attributs: attributs prédéfinis, attributs définis
par l’utilisateur.
Pour satisfaire ces exigences, le modèle de simulation retenu pour le modèle de structure
est représenté par la figure 4.2.
La partie supérieure (au dessus du pointillé) montre un exemple de structure fonctionnelle
représentant la décomposition de la fonction F en les fonctions F1 et F2[1:m] et la relation par
V[1:m]. Chaque fonction est définie par les attributs: ‘Concurrency, ‘Power, ‘Policy, ‘Priority,
‘Deadline. Les attributs des 3 types de relations EV, Port et V[1:m] sont aussi rappelés sur la
figure. Les temps ‘Write, ‘Read, ‘Use sur les liens peuvent venir surcharger les attributs de
l’objet de relation.
Transcription du modèle de performance en VHDL
M.C.S.E 91
-Figure 4.2- Modèle de simulation retenu pour la transcription en VHDL.
Pour la fonction F, le problème important à résoudre consiste à obtenir une exécution de
toutes ses fonctions internes avec les échanges par relations conformément à ses attributs.
L’attribut ‘Power de la fonction F implique simplement la modification des temps d’exécution
de tous les constituants internes en utilisant Power comme facteur multiplicatif (<1 implique
un ralentissement, > 1 implique une accélération).
L’attribut ‘Concurrency de F est le plus spécifique. S’il est à une valeur infinie (0 choisie
comme valeur représentative), il n’y a pas de particularité. Si sa valeur est inférieure au nombre
de fonctions internes à évolution potentiellement parallèle (incluant toute la décomposition
interne jusqu’aux opérations), il faut assurer un ordonnancement des fonctions selon une
politique (‘Policy) et avec l’attribut approprié (‘Priority ou ‘Deadline). Il s’agit là d’un moyen
pour simuler l’influence d’un support exécutif représenté par F avec un degré d’exécution
limité. Ceci implique la possibilité de préemption du processeur ou de la ressource d’exécution
pour une fonction ou une activité interne. Ce point précis est une difficulté en VHDL car il est
impossible de suspendre et ensuite de relancer un process de l’extérieur.
La solution retenue pour la simulation est l’ajout de la partie basse de la figure 4.2. Chaque
unité de comportement, c’est-à-dire fonction, activité ou opération, est transcrite comme une
tâche. Une variable State est associée à chaque tâche. Cette variable va être modifiée par
l’ordonnanceur Scheduler pour indiquer les états actifs et suspendus de la tâche.
V[1:m]
States(F1) States(F2[1:m])
Scheduler
‘Concurrency
‘Power
F1
Cons
F2[1:m]
Port
‘Capacity
‘Write
‘Read
‘Write
‘Concurrency
F
States(F)
EV
‘Write ‘Read
‘Concurrency
‘Write
‘Read
‘Capacity
‘Concurrency
‘Power
‘Policy
‘Priority
‘Deadline
‘Policy
‘Priority
‘Deadline
‘Policy
‘Use
‘Concurrency
‘Write
‘Read
‘Policy
‘Read
TYPE DefUState IS RECORD
TaskState : DefTaskState
priority : NATURAL;
deadline : TIME;
power : REAL;
END RECORD;
state state
state
’OverHead
‘OverHead
Chapitre 4
92 M.C.S.E
Ce modèle de solution satisfait la condition de description hiérarchique. En effet, chaque
fonction possède la variable State en entrée. Ceci est le cas pour F mais aussi pour F1 et F2.
Chaque fonction est donc dépendante de sa fonction englobante.
3 procédures sont à la disposition des fonctions pour gérer la ressource d’exécution, ce qui
se traduit par la modification de sa variable State (qui correspond à States[i] à l’extérieur):
- InactiveTask(state: DefState); qui rend la tâche inactive avec libération de la ressource
d’exécution,
- BlockingTask(state: DefState); qui indique une mise en attente sur une condition
d’activation avec libération de la ressource d’exécution,
- WaitingTask(state:DefState); qui assure une demande de la ressource, en sortie de la
procédure la ressource a été obtenue.
4.4 IMPLANTATION DE LA FONCTION D’ORDONNANCEMENT
La limitation du parallélisme de la ressource d’exécution est assurée par une fonction
Scheduler ajoutée en interne de chaque fonction. Scheduler est transcrite comme un composant
(entité) VHDL. Comme entrées/sorties, il utilise d’une part sa variable State par laquelle son
environnement (le niveau hiérarchique supérieur) lui indique la disponibilité de la ressource
d’exécution, d’autre part la variable States qui regroupe l’état de toutes les fonctions internes
à exécuter.
Une variable States(i) pour la fonction i comprend:
- la variable TaskState représentant l’état de la fonction avec les états: Inactive,
Blocked, Waiting, Active,
- la variable Power transmettant ainsi le paramètre à la fonction i pour la modification
des temps d’exécution,
- les variables Priority et Deadline définissant son urgence pour l’ordonnancement
(une seule utilisée à la fois par le scheduler compte-tenu de son attribut ‘Policy),
Les états d’une fonction et les transitions entre eux sont représentés par la figure 4.3.
-Figure 4.3- Etats d’une fonction et conditions de transition.
L’état Waiting est spécifique de l’emploi d’une ressource limitée. Pour que tous les temps
d’exécution n’évoluent que durant l’état Active, ils sont tous simulés par une procédure
DELAY qui permet ainsi de gérer un point de préemption par la ressource d’exécution. Bien
entendu, pour cela on interdit l’emploi de l’instruction VHDL "Wait for Time". Le
comportement de la procédure DELAY est décrit ci-dessous.
Condition satisfaite
Début exécution
Inactive Wait
Ressource allouée
Waiting
Ressource préemptée
attente condition Fin exécution
Blocked eAncdtive
(WaitingTask) (BlockingTask)
(InactiveTask)
(WaitingTask)
par le scheduler
(BlockingTask)
Transcription du modèle de performance en VHDL
M.C.S.E 93
PROCEDURE Delay( CONSTANT WaitTime : IN TIME;
SIGNAL TaskState : IN DefState) IS
VARIABLE GlobalTime,RemainTime: TIME := NullTime;
BEGIN
GlobalTime:=now;
IF (TaskState.power/=0.0) THEN
RemainTime:=WaitTime/TaskState.power;
ELSE RemainTime:=WaitTime;
END IF;
LOOP
WAIT UNTIL (TaskState.state/=Active) FOR RemainTime;
IF (TaskState.state=Active) THEN exit;
ELSE
RemainTime:=RemainTime-(now-GlobalTime);
WAIT UNTIL (TaskState.state=Active);
GlobalTime:=now;
END IF;
END LOOP;
END Delay;
On constate bien que l’évolution du temps est bloquée lorsque la fonction utilisant la
procédure DELAY n’est plus active. L’attribut ‘Power dans l’argument TaskState est utilisé
pour modifier le temps d’exécution fourni comme argument.
La description VHDL de la fonction Scheduler est donnée ci-après. Son comportement se
rapproche de celui d’un ordonnanceur d’exécutif temps-réel. Seule la politique
d’ordonnancement selon la priorité est actuellement implantée. Il est évident que d’autres
politiques sont aisément implantables par extension algorithmique en utilisant la valeur de
l’attribut ‘Policy. La fonction est décrite sous la forme d’une entité générique. Elle exploite une
fonction de résolution strictement nécessaire pour gérer la variable partagée state.
-- ###########################################################
-- # Types et fonction de resolution pour l'etat d'une tache #
-- ###########################################################
TYPE DefTaskState IS (Nodriver,Inactive,Blocked,Waiting,Active);
TYPE DefTaskStateTable IS ARRAY(DefTaskState,DefTaskState) OF DefTaskState;
CONSTANT ResolutionTaskState : DefTaskStateTable :=(
--|-----------|----------|-----------|---------|--------|
--| Nodriver | Inactive | Blocked | Waiting | Active |
--|-----------|----------|-----------|---------|--------|---------------|
( Nodriver, Inactive, Blocked, Waiting, Active), --| Nodriver |
( Inactive, Inactive, Inactive, Waiting, Inactive), --| Inactive |
( Blocked, Inactive, Blocked, Waiting, Blocked), --| Blocked |
( Waiting, Waiting, Waiting, Waiting, Active), --| Waiting |
( Active, Inactive, Blocked, Active, Active) --| Active |
);
TYPE DefUState IS RECORD
state : DefTaskState;
priority : NATURAL;
deadline : TIME;
power : REAL;
END RECORD;
TYPE DefUStateVector IS ARRAY (NATURAL RANGE <>) OF DefUState;
FUNCTION ResolState (Input : DefUStateVector) RETURN DefUState;
SUBTYPE DefState IS ResolState DefUState;
TYPE DefStateVector IS ARRAY (NATURAL RANGE <>) OF DefState;
...
ENTITY Processor IS
GENERIC ( Concurrency : NATURAL := 1;
Power : REAL := 1.0;
OverHead : TIME := NullTime;);
PORT (SIGNAL StateVector : INOUT DefStateVector;
SIGNAL ProcessorState : INOUT NATURAL);
END Processor;
ARCHITECTURE behavioral OF Processor IS
BEGIN
Scheduling : PROCESS
Chapitre 4
94 M.C.S.E
VARIABLE CurrentConcurrency,i,
highestWaitingFunction, lowestActiveFunction : NATURAL;
VARIABLE TaskIsWaiting : BOOLEAN;
BEGIN
InactiveTask(ProcessorState);
InitStates(StateVector, power*ProcessorState.power);
LOOP
WaitingTask(ProcessorState);
LOOP
WAIT UNTIL StateVector’EVENT oR ProcessorState’EVENT;
CASE ProcessorState IS
WHEN Inactive =>
TaskIsWaiting:=FALSE;
FOR i IN StateVector’RANGE LOOP
IF StateVector(i).state=waiting THEN
TaskIsWaiting:=TRUE;
EXIT;
END IF;
IF TaskIsWaiting THEN WaitingTask(ProcessorState);
END IF;
WHEN Active=>
-- Scheduling according to a static priority
InfoFunctions(StateVector,CurrentConcurrency,
lowestActiveFunction,highestWaitingFunction);
IF ((CurrentConcurrency<Concurrency) AND
(highestWaitingFunction/=0)) THEN
ActiveFunction(StateVector,highestWaitingFunction,
OverHeadProcessor,ProcessorState);
ELSIF ((highestWaitingFunction/=0) AND
(lowestActiveFunction/=0) AND
(StateVector(lowestActiveFunction).priority<
StateVector(highestWaitingFunction).priority)) THEN
-- processor preemption
Preemption(StateVector,lowestActiveFunction,
highestWaitingFunction,
OverHeadProcessor,ProcessorState);
ELSIF (CurrentConcurrency=0) THEN
-- pas de fonction active ou en attente
InactiveTask(ProcessorState);
END IF;
WHEN OTHERS=> -- Blocked, Waiting, ExitNow, NoDriver
FOR i IN StateVector’RANGE LOOP
IF StateVector(i).state=Active THEN
StateVector(i).state<=waiting;
END IF;
END LOOP;
WaitingTask(ProcessorState);
END CASE;
END LOOP;
END LOOP;
END PROCESS Scheduling;
END behavioral;
L’ordonnanceur ne peut rendre actif une fonction qu’il contrôle que lorsqu’il est lui-même
dans l’état actif.
Les primitives ActiveFunction et Préemption tiennent compte de l’attribut ‘Overhead
(temps de commutation) et de l’état du processeur (possibilité d’une suspension de processeur).
Le fonction Scheduler se charge aussi de mettre à disposition de chaque fonction qu’elle
gère la puissance d’exécution à exploiter (Power d’une fonction = ‘Power de cette fonction *
Power de la fonction englobante).
Transcription du modèle de performance en VHDL
M.C.S.E 95
4.5 TRANSCRIPTION DU MODELE STRUCTUREL
Le modèle structurel permet de représenter la solution d’une application selon un ensemble
de fonctions et de relations entre celles-ci. Les relations entre fonctions sont de 3 types:
- relation de synchronisation pour exprimer une dépendance temporelle,
- relation de partage de données ou de ressources,
- relation de transfert d’information et de communication ce qui sous-entend une
dépendance temporelle avec échange.
Dans la suite, on s’intéresse successivement à la transcription d’une fonction, d’un port,
d’un événement et d’une variable partagée. Il faut garder à l’esprit que toute fonction, activité
ou opération reste implantée conformément au modèle précédent. Ceci n’est bien sûr à faire
que lorsqu’il y a limitation de la ressource d’exécution.
4.5.1 Transcription d’une fonction
Dans le cas général, une fonction sera transcrite sous la forme d’une entité. Ceci permet:
- de garder la hiérarchie du modèle,
- de garder la trace des entrées/sorties d’une fonction (port map),
- d’exploiter la généricité (generic map),
- d’exploiter la réplication et la notion de modèle de fonctions (une entité peut être
instanciée sous forme de composant ou même directement avec VHDL’93),
- d’utiliser l’instanciation multiple,
- d’associer plusieurs modèles à une même entité (plusieurs descriptions
d’architectures, l’une choisie par configuration).
Lorsque certaines propriétés de l’entité n’ont pas à être exploitées, particulièrement l’intérêt
de plusieurs modèles, il est possible d’utiliser une notion relativement proche: le block. Si le
block ne permet pas de traduire la notion de réplication/modèle de fonctions, il offre,
contrairement aux entités, la possibilité d’accéder à des variables globales (Shared variable de
VHDL‘93), ce qui est très utile dans certains cas.
Il faut noter que pour un block la partie Generic Map et Port Map est optionnelle et
purement déclarative: un oubli d’une entrée/sortie ou d’un paramètre générique n’entraînera
pas forcément d’erreur de compilation (passage par effet de bord). Aussi il faut faire très
attention pour préserver la lisibilité du programme.
L’exemple ci-dessous montre la possibilité d’exploiter simultanément les concepts d’entité
et de block. Les fonctions décrites ci-après ne possèdent pas la variable State en entrée car nous
avons supposé qu’il n’y a pas de limitation de ressource d’exécution. Pour la compréhension,
l’entité modélise l’environnement de l’exemple simplifié du serveur vidéo dont la structure
fonctionnelle est représentée par la figure 3.14 du chapitre 3.
ENTITY EnvironnementVideoServer IS
GENERIC (n : INTEGER := 1);
PORT (Cmd : INOUT DefPortInVector(1 TO n);
BlockIn : INOUT DefPortIn;
BlockOut : INOUT DefPortOutVector(1 TO n));
END EnvironnementVideoServer;
ARCHITECTURE behavioral OF EnvironnementVideoServer IS
-- variable partagee pour la generation de nombres aleatoires
SHARED VARIABLE rnd : REAL;
BEGIN
Chapitre 4
96 M.C.S.E
-- modelisation de l'environnement du systeme etudie
-- entite Users
Users : BLOCK
PORT (Cmd : INOUT DefPortInVector(1 TO n));
PORT MAP (Cmd=>Cmd);
BEGIN
MultipleInstanciation: FOR i IN 1 TO n generate
User : BLOCK
PORT (Cmd : INOUT DefPortIn);
PORT MAP (Cmd=>Cmd(i));
CONSTANT me : INTEGER := i;
BEGIN
UserBehavior : PROCESS
....;
END PROCESS UserBehavior;
END BLOCK User;
END GENERATE MultipleInstanciation;
END BLOCK Users;
-- entite source
source : BLOCK
PORT (BlockIn : INOUT DefPortIn);
PORT MAP (BlockIn=>BlockIn);
BEGIN
EmissionBehavior : PROCESS
....;
END PROCESS EmissionBehavior;
END BLOCK source;
-- entite TVSet
TVSet : BLOCK
PORT (BlockOut : INOUT DefPortOutVector(1 TO n));
PORT MAP (BlockOut=>BlockOut);
CONSTANT TconsTime : TIME := 10 us;
BEGIN
MultipleInstanciation: FOR i IN 1 TO n generate
TV : BLOCK
PORT (BlockOut : INOUT DefPortOut);
PORT MAP (BlockOut=>BlockOut(i));
BEGIN
ReceptionBehavior : PROCESS
....;
END PROCESS ReceptionBehavior;
END BLOCK TV;
END GENERATE MultipleInstanciation;
END BLOCK TVSet;
END behavioral;
La description sous forme d’entité ou de block permet de garder la hiérarchie du modèle
MCSE, la trace des entrées/sorties des composants actifs (port map) et la généricité (generic
map). Dans l’exemple, le paramètre générique n est utilisé pour dimensionner des éléments
internes (dimension des éléments de relation Cmd et BlockOut et des fonctions User et TVSet).
L’utilisation d’un block à la place d’un entité offre plusieurs avantages:
- un block est instanciable directement, ce qui en contre partie ne permet pas la
réplication (pas de déclaration de composant). La construction VHDL Generate est
utilisée pour l’instanciation multiple des fonctions User et TVSet. L’attribut me’Index
est alors traduit sous la forme d’une constante (constante me).
- un block permet d’accéder à des variables partagées (Shared Variable de VHDL’93)
telle que la variable rnd qui est utilisée par un générateur de nombre pseudo-aléatoire.
Transcription du modèle de performance en VHDL
M.C.S.E 97
4.5.2 Transcription d’un port
La transcription d’un port nécessite de tenir compte du comportement systématique de tout
port (c’est-à-dire la gestion des messages reçus et délivrés) et de tous les attributs qui
particularisent son comportement. Un protocole de communication est développé pour le
couplage d’un élément de relation avec une fonction. Notons que le principe de traduction
consiste à considérer que l’élément de relation est un élément passif.
-A- Caractéristiques et transcription d’un élément de transfert d’information
L'objet Port pour le couplage est assimilable à un tampon caractérisé par sa capacité en
nombre de messages (‘Capacity) et son degré de partage pour des accès multiples
(‘Concurrency). Deux grandeurs temporelles ‘Write et ‘Read sont aussi à considérer pour son
utilisation ceci dans le cas de place disponible pour le dépôt, ou d’une information disponible
pour le retrait.
Deux politiques d’ordonnancement des messages sont prévues: selon la date de dépôt et
donc Fifo, selon la priorité fixée par le demandeur.
Concernant le comportement du port, rappelons qu’un producteur doit se bloquer s’il n’y a
plus de place pour le dépôt et qu’un consommateur doit se bloquer en l’absence de messages
dans la file du port.
Le port est décrit comme une entité instanciée sous la forme de composant. Les attributs
associés au port sont les paramètres génériques de l’entité (attributs statiques) et/ou font partie
des entrées/sorties de l’entité (attributs dynamiques).
-B- Protocole de communication multi-points
De nombreux modèles ne permettent que la communication point à point, ce qui réduit
considérablement les possibilités de topologie d’un système. La relation considérée dans le
modèle MCSE est générale. Il s’agit de coupler m producteurs et n consommateurs sur le même
port.
L’échange de donnée entre un port et un ou plusieurs producteurs nécessite un protocole de
communication: le producteur doit demander l’accès au port et doit maintenir cette demande
jusqu’à ce que le port soit prêt. Alors un retour (feedback) doit exister entre le port et le
producteur pour indiquer que le port a satisfait la requête de l’utilisateur et que la demande
d’accès peut être inhibée. Pour ce type de protocole, deux signaux de contrôle sont
habituellement utilisés (request, acknowledge), mais pour la transcription en VHDL, surtout
dans le cas de plusieurs producteurs pour un même port, il est préférable d’utiliser un signal
bidirectionnel (Status) associé à une fonction de résolution (ResolProtocol).
Le code VHDL correspondant à l’implantation du protocole de communication est le
suivant:
TYPE DefHandshake IS (InactiveAck,ActiveAck,InactiveReq,ActiveReq);
TYPE DefHandshakeTable IS ARRAY (DefHandshake,DefHandshake) OF DefHandshake;
CONSTANT ResolutionHandshake : DefHandshakeTable :=(
--|-------------|-------------|-------------|-----------|--------------|
--| InactiveAck | ActiveAck | InactiveReq | ActiveReq | TaskBlocked |
--|-------------|-------------|-------------|-----------|--------------|------------------|
( InactiveAck, ActiveAck, InactiveReq, ActiveReq, InactiveAck), --| InactiveAck |
( ActiveAck, ActiveAck, InactiveReq, ActiveAck, ActiveAck ), --| ActiveAck |
( InactiveReq, InactiveReq, InactiveReq, InactiveReq, InactiveReq), --| InactiveReq |
( ActiveReq, ActiveAck, InactiveReq, ActiveReq, TaskBlocked), --| ActiveReq |
( InactiveAck, ActiveAck, InactiveReq, TaskBlocked, TaskBlocked) --| TaskBlocked |);
TYPE DefProtocol IS RECORD
priority : NATURAL;
date : TIME;
status : DefHandshake;
Chapitre 4
98 M.C.S.E
END RECORD;
TYPE DefUPortIn IS RECORD
information : DefInformation;
WriteTime : TIME;
protocol : DefProtocol;
END RECORD;
TYPE DefUPortOut IS RECORD
information : DefInformation;
ReadTime : TIME;
protocol : DefProtocol;
END RECORD;
TYPE DefUPortInVector IS ARRAY (NATURAL RANGE <>) OF DefUPortIn;
TYPE DefUPortOutVector IS ARRAY (NATURAL RANGE <>) OF DefUPortOut;
FUNCTION ResolProtocol (Input: DefUPortInVector) return DefUPortIn;
FUNCTION ResolProtocol (Input: DefUPortOutVector) return DefUPortOut;
SUBTYPE DefPortIn IS ResolProtocol DefUPortIn;
SUBTYPE DefPortOut IS ResolProtocol DefUPortOut;
TYPE DefPortInVector IS ARRAY (NATURAL RANGE <>) OF DefPortIn;
TYPE DefPortOutVector IS ARRAY (NATURAL RANGE <>) OF DefPortOut;
Cette implantation est à rapprocher de celle du jeton du modèle UVa qui a également
inspirée le mécanisme de communication utilisé dans le modèle de performance du projet
RASSP (Cosmos).
Le protocole est tout d’abord expliqué pour le couplage d’un producteur avec le port. Le
signal Status permet le handshake entre un producteur et un port à l’aide des 4 valeurs
possibles: InactiveAck, ActiveAck, InactiveReq, ActiveReq.
1- Initialement, le producteur assigne la valeur InactiveAck au signal Status, pendant
que le port lui assigne la valeur InactiveAck. La fonction de résolution associée à ce
"multiplesignaldriven" lui donne la valeur InactiveAck.
2- Quand le producteur veut faire un accès au port, il assigne la valeur ActiveReq au
signal Status et se bloque ce qui libère sa ressource d’exécution et comme le port
continue à lui assigner la valeur InactiveAck, la fonction de résolution lui donne la
valeur provenant du producteur (ActiveReq est équivalent à demande d’allocation).
3- Le port voit maintenant la valeur ActiveReq assignée au signal Status. Dès qu’il
en est capable, il satisfait la requête du producteur et positionne le signal Status à
ActiveAck (la fonction copiant le signal Status provenant du port égal à ActiveAck).
4- En observant Status=ActiveAck, le producteur déduit que sa requête a été acceptée
par le port et par conséquent, il demande la ressource d’exécution par Waiting, puis
après un délai d’utilisation, il positionne avec la complicité de la fonction de
résolution le signal Status à InactiveReq (libération du port).
5- Quand le port voit Status=InactiveReq, le port se prépare à un nouvel accès en
positionnant Status à InactiveAck.
En plus du champ Status, l’élément de base de communication possède deux autres champs
Priority et Date. Lorsque le nombre d’accès simultanés dépasse le degré de partage (attribut
‘Concurrency) de l’élément de relation, deux politiques d’ordonnancement des accès ont été
prévues: selon la date de dépôt ou selon la priorité fixée par le demandeur. Par défaut, le champ
Date est fixé avec la date courante de simulation mais il peut être modifié pour appliquer par
exemple une politique d’ordonnancement au plus tard (voir exemple du serveur vidéo dans le
chapitre 7).
Le jeton utilisé comme élément de communication de base dans le modèle de performance
de Cosmos contient également un champ Size utile pour calculer le débit sur le port et les
champs StartTime et Destination utiles pour calculer le temps de latence des messages. Nous
ne sommes pas obligés de définir ces champs au niveau du record DefProtocol. La définition
Transcription du modèle de performance en VHDL
M.C.S.E 99
et l’exploitation de ces attributs peuvent être laissées au libre arbitre de l’utilisateur du modèle.
Si ils sont utilisés, ces attributs seront alors définis dans le message lui-même au niveau du
record DefInformation comme nous le verrons plus loin.
Le temps d’accès à l’élément de relation est simulé du coté producteur et non du coté port.
L’entité gérant le port est ainsi passive. Lors d’une exécution sur un processeur de degré de
concurrence limité, l’entité n’a pas besoin de tenir compte de l’état (active, inactive, bloquée
ou en attente) de la fonction (tâche) producteur. Cependant, le protocole de communication
indique à la tâche producteur qu’elle doit passer à l’état bloqué (Status égal à TaskBlocked) si
le port ne peut satisfaire le requête du producteur.
-C- Implantation
Le principe d’implantation d’un port est schématisé par la figure 4.4. La figure 4.4-a
représente la structure fonctionnelle constituée des fonctions Prod et Cons reliées par le port de
communication nommé Port. L’attribut ‘Write sur le lien entre Prod et Port surcharge l’attribut
‘Write de Port.
La structure de l’implantation en VHDL est décrite par la figure 4.4-b. Les fonctions Prod
et Cons sont implantées sous la forme d’une entité ou d’un block dont les entrées/sorties sont
composées du signal States (ressource d’exécution limitée) et du signal PortIn (respectivement
PortOut) pour le transfert de données. Le port de communication est modélisé par un
composant. Les paramètres génériques de ce composant sont les attributs associés
habituellement à un port de communication (‘Capacity, ‘Write, ‘Read, ‘Concurrency). La
description interne de l’entité associée au composant Port contient une fifo (buff) qui sert à
stocker et restituer (primitives Put et Get) les messages transmis.
L’implantation distingue le port du type rendez-vous (’Capacity=0) des ports à N places
(N>0) ou fugace.
Le comportement de l’entité Port est constitué de deux automates pour un port à N places
ou fugace (figure 4.4-c) et d’un seul automate pour un port du type Rendez-Vous (figure 4.4-d).
De plus, pour un port fugace, il n’y a mémorisation du message que s’il y a un consommateur
en attente.
Sur la figure 4.4-c, lorsqu’un producteur désire déposer un message, il fait appel à la
procédure Send (à gauche de la figure). Cette procédure signale son état actif au port par
ActiveReq. Si le port est en mesure de recevoir le message, il répond immédiatement par
ActiveAck. La condition d’acceptation d’un message comprend: la demande ActiveReq, la
disponibilité d’une place, le degré de concurrence non atteint (NbUse). Si le port n’est pas libre,
il y a alors libération de la ressource d’exécution par la procédure Blocking définissant
TaskState=blocked. Après acquittement du port de communication, la fonction passe alors le
temps d’écriture nécessaire réalisé par la procédure DELAY. Durant cette attente, le ressource
d’exécution peut être préemptée par une tâche plus prioritaire. Le protocole se termine ensuite
par InactiveReq puis l’état de repos InactiveAck qui sert aussi à la fin de la procédure Send.
Pour un consommateur la procédure Receive (à droite de la figure) est identique mais avec
l’indication d’une attente de message par ActiveReq.
Chapitre 4
100 M.C.S.E
-Figure 4.4- Solution pour l’implantation d’un transfert de messages par un port.
OutputActiveAck
Wait
OutAccess
end
Wait
Delay
Write
TaskBlocked
PortIn PortOut
Send
Wait
InAccess
(ActiveReq or
NbFreeSpace>0 and
ActiveAck
ActiveAck
InactiveReq
InactiveAck
InactiveReq
InactiveAck
PORT à N places pour une concurrence
Port
Prod[1:m] Cons[1:n]
DELAY
(writeTime)
/ActiveReq
end
wait
NbMess>0 and
OutValue
InactiveReq
InactiveAck
End DELAY
InactiveReq
ActiveAck
Wait
InactiveAck
‘Capacity
‘Write
‘Read
‘Write
Wait
ActiveAck
Send ( InValue, Port) utilisé dans Prod[i]
End DELAY
Receive (Port, OutValue) utilisé dans Cons[i]
PORT
‘Capacity
‘Write
‘Read
buff: fifo;
buff : fifo pour la mémorisation des messages
InStatus[1:m]
InValue[1:m]
OutStatus[1:n]
OutValue[1:n]
InactiveReq
InactiveAck
Wait
(ReadTime)
DELAY
a) b)
c)
‘Concurrency
‘Concurrency
InValue
NbUse < Concurrency
NbUse++;
NbUse--;
NbUse < Concurrency
NbUse++;
NbUse--;
/ ActiveReq
Receive
Wait
OutAccess
end
wait
Waiting Waiting
Prod[1:m]
Send
Cons[1:n]
Receive
States(Prod[1:m]) States(Cons[1:n])
Put(buff, InValue); Get(buff, OutValue);
NbUse:=0;NbFreeSpace:=Capacity;MnMess:=0;
Taskblocked
Wait
ActiveAck
Blocked
ActiveReq and
(NbMess=0 or
NbUse >= Concurrency)
TaskBlocked
ActiveReq and
(NbFreeSpace>0 or
NbUse >= Concurrency)
TaskBlocked
TaskBlocked) and
NbFreeSpace--;
NbMess++;
(ActiveReq or
TaskBlocked) and
NbMess--;
NbFreeSpace++;
TaskBlocked
ActiveAck
ActiveAck
Taskblocked
Wait
ActiveAck
Blocked
Wait
InputTaskBlocked
Wait
InputActiveAck
InputActiveAck
InputInactiveReq
InputInactiveAck
InputInactiveAck
PORT du type Rendez-Vous pour une concurrence
DELAY
(writeTime)
Input/ActiveReq
Rendez
OutValue
OutputInactiveAck
End DELAY
OutputInactiveReq
Wait
InactiveAck
Wait
ActiveAck
End DELAY
InactiveReq
OutputInactiveAck
Wait
(ReadTime)
DELAY
d)
NbUse < Concurrency
NbUse++;
NbUse--;
/OuputActiveReq
Waiting Waiting
NbUse:=0;
Taskblocked
Wait
ActiveAck
Blocked
ProdReady and
OutputTaskBlocked
OutputActiveAck
ActiveAck
Taskblocked
Wait
ActiveAck
Blocked
Wait
Vous
InputActiveReq and
NbUse >= Concurrency)
InputTaskBlocked
OutputActiveReq and
NbUse >= Concurrency)
OutputTaskBlocked
ConsReady and
OutputInactiveReq
ConsReady := OutputActiveReq or OutputTaskBlocked;
PropReady := InputActiveReq or InputTaskBlocked;
not(ConsReady) and not(ProdReady) and
Start
Rendez
Vous
InputInactiveReq
OutputInactiveReq
1
Blocked
Waiting
* astuce pour que le
consommateur ne soit
pas pris pour un autre
producteur
Transcription du modèle de performance en VHDL
M.C.S.E 101
Pour un port du type rendez-vous, il y a gestion de couples Producteur/Consommateur. Le
degré de concurrence (attribut ‘Concurrency) représente alors le nombre de couples simultanés
et non pas le nombre d’accès simultanés autorisés (Port à N places). Un consommateur en
attente est bloqué tant qu’un producteur n’a pas déposé de message et le producteur n’est libéré
que lorsque le consommateur a retiré le message. La durée de transfert d’un message est donc
au minimum la somme des temps des attributs ‘Write et ‘Read.
La fonction de résolution et sa table de transition (utilisation de l’état InactiveReq de poids
plus fort que ActiveReq) sont utilisées à profit pour marquer les éléments d’un couple.
Les primitives Send et Receive décrites en VHDL sont données ci-dessous.
PROCEDURE receive( SIGNAL message : INOUT DefPortOut;
information : OUT DefInformation;
LinkReadTime : IN TIME;
priority : IN NATURAL;
date : IN TIME;
--SIGNAL TaskState : INOUT DefState;
RendezVous : IN BOOLEAN) IS
VARIABLE TmpPortAccess : DefUPortOut;
BEGIN
IF ((TaskState.state/=ExitNow) AND
(message.protocol.status/=ActiveAck)) THEN
TmpPortAccess.protocol:=DefProtocol'(priority,date,ActiveReq);
message<=TmpPortAccess;
--IF RendezVous THEN BlockingTask(TaskState);
--END IF;
WAIT UNTIL (message.protocol.status=ActiveAck) OR
(TaskState.state=ExitNow) OR
(message.protocol.status=TaskBlocked);
IF ((message.protocol.status=TaskBlocked) AND
(TaskState.state/=ExitNow)) THEN
--IF NOT(RendezVous) THEN BlockingTask(TaskState);
--END IF;
WAIT UNTIL (message.protocol.status=ActiveAck) OR
(TaskState.state=ExitNow);
END IF;
END IF;
IF (message.protocol.status=ActiveAck) THEN
TmpPortAccess:=message;
IF (LinkReadTime/=NullTime) THEN
TmpPortAccess.ReadTime:=LinkReadTime;
END IF;
--WaitingTask(TaskState);
IF (TmpPortAccess.ReadTime/=NullTime) THEN
Delay(TmpPortAccess.ReadTime)--,TaskState);
END IF;
TmpPortAccess.protocol.status:=InactiveReq;
message<=TmpPortAccess;
WAIT UNTIL message.protocol.status=InactiveReq;
TmpPortAccess:=message;
TmpPortAccess.protocol.status:=InactiveAck;
message<=TmpPortAccess;
WAIT UNTIL message.protocol.status=InactiveAck;
TmpPortAccess:=message;
information:=TmpPortAccess.information;
ELSE
message.protocol.status<=InactiveAck;
END IF;
END receive;
--
PROCEDURE send(information : IN DefInformation;
SIGNAL message : INOUT DefPortIn;
LinkWriteTime : IN TIME;
priority : IN NATURAL;
date : IN TIME;
--SIGNAL TaskState : INOUT DefState;
Chapitre 4
102 M.C.S.E
RendezVous : IN BOOLEAN) IS
VARIABLE TmpPortAccess : DefUPortIn;
BEGIN
IF (TaskState.state/=ExitNow) THEN
TmpPortAccess.protocol:=DefProtocol'(priority,date,ActiveReq);
message<=TmpPortAccess;
WAIT UNTIL (message.protocol.status=ActiveAck) OR
(message.protocol.status=TaskBlocked) OR
(TaskState.state=ExitNow);
IF ((message.protocol.status=TaskBlocked) AND
(TaskState.state/=ExitNow)) THEN
--BlockingTask(TaskState);
WAIT UNTIL (message.protocol.status=ActiveAck) OR
(TaskState.state=ExitNow);
END IF;
IF (message.protocol.status=ActiveAck) THEN
TmpPortAccess:=message;
IF (LinkWriteTime/=NullTime) THEN
TmpPortAccess.WriteTime:=LinkWriteTime;
END IF;
--WaitingTask(TaskState);
IF (TmpPortAccess.WriteTime/=NullTime) THEN
Delay(TmpPortAccess.WriteTime)--,TaskState);
END IF;
TmpPortAccess.information:=information;
TmpPortAccess.protocol.status:=InactiveReq;
message<=TmpPortAccess;
WAIT UNTIL message.protocol.status=InactiveReq;
--IF RendezVous THEN BlockingTask(TaskState);
--END IF;
END IF;
message.protocol.status<=InactiveAck;
WAIT UNTIL message.protocol.status=InactiveAck;
--IF RendezVous THEN WaitingTask(TaskState);
--END IF;
END IF;
END send;
NOTA: les lignes indiquées en commentaires sont à considérer dans le cas du partage
d’une ressource limitée pour plusieurs fonctions.
-D- Utilisation
L’emploi des procédures Send et Receive diffère selon qu’il s’agit d’un accès 1->1, N->1
ou N-> M. Dans le premier cas, le signal assurant le protocole est utilisé comme nom du port.
Dans le deuxième cas, comme n producteurs ou consommateurs peuvent accéder au même
port, le signal assurant le protocole est un vecteur non contraint. L’appelant doit alors donner
son identité sous la forme de son indice dans le vecteur. La surcharge de procédure permet de
disposer que d’un seul nom de procédure Send ou Receive mais avec un nombre d’arguments
différent. Dans le troisième cas, comme les n producteurs peuvent accéder aux m éléments du
vecteur de port, le signal assurant le protocole est un vecteur de vecteur. L’appelant doit alors
donner son identité et l’indice du destinataire du message dans le vecteur de port. Comme
VHDL ne permet pas de définir un vecteur non contraint d’un vecteur non contraint et ne
permet pas de définir des paramètres génériques au niveau d’un package, la primitive d’accès
ne peut être défini qu’au niveau de l’entité. Ceci complique sérieusement la génération du
modèle VHDL et sa lisibilité.
En effet, la taille des vecteurs sera généralement définie avec un paramètre générique
permettant de modifier facilement la dimension et la topologie du système.
VHDL ne permet pas aussi de définir des types dynamiques ou record variant sur des
signaux. Pour contourner cette limitation, deux solutions sont possibles:
Transcription du modèle de performance en VHDL
M.C.S.E 103
- définir un type spécifique pour chaque type d’élément de communication (solution (a)
de la figure 4.5). Ceci oblige malheureusement à redéfinir les primitives d’accès et
l’entité gérant l’élément de relation pour chaque type d’élément de relation. Cette
solution a donc un impact négatif sur la complexité et le temps de génération du code.
- regrouper en un seul record (solution (b) de la figure 4.5) les informations nécessaires
(attributs) pour les transferts de tous les types de messages du système. Cette solution
facilite la génération de code mais a probablement un impact négatif sur la durée de
simulation.
Les deux solutions sont expliquées par la figure ci-après.
-Figure 4.5- Techniques de transfert d’information par les procédures Send et Receive.
TYPE DefInfo1 IS RECORD
Size : Integer;
Speed: Integer;
END RECORD;
TYPE DefInfo2 IS RECORD
Id : Integer;
Priority: Integer;
END RECORD;
TYPE DefUPortIn_Info1 IS RECORD
Information: DefInfo1;
WriteTime: TIME;
Protocol: DefProtocol;
END RECORD;
TYPE DefUPortOut_Info1 IS RECORD
Information: DefInfo1;
ReadTime: TIME;
Protocol: DefProtocol;
END RECORD;
PROCEDURE Send (Info1: IN DefInfo1;
SIGNAL LinkIn: INOUT DefPortIn_Info1;
LinkWriteTime: TIME);
PROCEDURE Receive (
SIGNAL LinkOut: INOUT DefPortOut_Info1;
Info1: OUT DefInfo1;
LinkReadTime: TIME);
PROCEDURE Send (Info2: IN DefInfo2;
SIGNAL LinkIn: INOUT DefPortIn_Info2;
LinkWriteTime: TIME);
PROCEDURE Receive (
SIGNAL LinkOut: INOUT DefPortOut_Info2;
Info2: OUT DefInfo2;
LinkReadTime: TIME);
TYPE DefUPortIn_Info2 IS RECORD
Information: DefInfo2;
WriteTime: TIME;
Protocol: DefProtocol;
END RECORD;
TYPE DefUPortOut_Info2 IS RECORD
Information: DefInfo2;
ReadTime: TIME;
Protocol: DefProtocol;
END RECORD;
Port1
Prod[1:m]
Info1
Port2[1:n]
Cons[1:n]
Info2
Exec
Send
Receive
Send
Receive
Type DefInformation IS RECORD
Size : Integer;
Speed: Integer;
Id : Integer;
Priority: Integer;
END RECORD;
Solution a
Solution b
TYPE DefUPortIn IS RECORD
Information: DefInformation;
WriteTime: TIME;
Protocol: DefProtocol;
END RECORD;
TYPE DefUPortOut IS RECORD
Information: DefInformation;
ReadTime: TIME;
Protocol: DefProtocol;
END RECORD;
PROCEDURE Send (Info: IN DefInformation;
SIGNAL LinkIn: INOUT DefPortIn;
LinkWriteTime: TIME);
PROCEDURE Receive (
SIGNAL LinkOut: INOUT DefPortOut;
Info: OUT DefInformation;
LinkReadTime: TIME);
Chapitre 4
104 M.C.S.E
Dans la solution a, un type est déclaré pour chaque type de messages transmis. Les types
associés aux informations transmises sont ensuite englobés dans la déclaration d’un record
regroupant le type de l’information, un champ utile pour surcharger les attributs temporels du
port et le signal utilisé pour le protocole de communication. La séparation des types nécessite
de déclarer une primitive d’accès pour chaque type d’information.
Dans la solution b, tous les types (attributs) associés aux ports de communication du
système sont regroupés dans un seul record (DefInformation). Ainsi, la déclaration des types
des signaux de connexion entre les éléments de relation et les composants actifs et celle des
primitives d’accès ne dépendent plus directement du type de l’information transmise et sont
uniques. Le générateur de code VHDL se contente alors simplement de mettre à jour le contenu
du record DefInformation.
4.5.3 Transcription d’un événement
Une relation de transfert d'information sous-entend une dépendance temporelle avec
échange de donnée. Comme une relation de synchronisation (événement, signal) exprime une
dépendance temporelle sans échange de donnée, la transcription d’une synchronisation est à
rapprocher de celle d’un transfert d’information mais sans le champ information.
L’attribut ‘Policy permet de choisir plusieurs modes de synchronisation: booléen et donc
avec mémorisation, comptage d’événement, fugitif et donc sans mémorisation.
Cependant contrairement au port, pour les fonctions en attente sur un événement, c’est le
principe de la diffusion (et non la gestion des accès selon une priorité) qui a été retenu. Ceci
signifie par exemple pour un événement du type Counter que la valeur du compteur correspond
au nombre d’activation des fonctions en attente et non pas au nombre de fonctions en attente
activables (l’événement du type Counter de MCSE n’a pas la même signification que la notion
de sémaphore rencontrée dans les exécutifs temps-réels). Pour un événement du type fugace,
il n’y a exploitation de l’événement que s’il y a au moins un récepteur de l’événement en
attente.
L’implantation en VHDL ne pose aucune difficulté et découle directement de ce qui a été
fait pour les ports. Le principe d’implantation d’un événement est schématisé par la figure 4.6.
La figure 4.6-a représente la structure fonctionnelle constituée des fonctions Prod et User
reliées par l’événement Ev. Les attributs ‘Write et ‘Read sur les liens entre les fonctions et
l’événement surchargent dynamiquement les attributs ‘Write et ‘Read de Ev.
La structure de l’implantation en VHDL est décrite par la figure 4.6-b. Les fonctions Prod
et User sont implantées sous la forme d’une entité dont les entrées/sorties sont composées du
signal States (ressource d’exécution limitée) et du signal EvIn (respectivement EvOut) pour la
synchronisation. Les signaux EvIn et EvOut ne sont composés que du champ Status utilisé pour
le protocole de communication en 4 phases. L’événement est modélisé par un composant. Les
paramètres génériques de ce composant sont les attributs associés habituellement à un
événement (‘Policy, ‘Write, ‘Read, ‘Concurrency).
Le comportement de l’entité Ev qui est passive par rapport à la ressource d’exécution est
décrit par deux automates (figure 4.6-c). Lorsqu’un producteur désire émettre un événement,
il fait appel à la procédure SignalEv (à gauche de la figure). Cette procédure signale son état
actif au port par ActiveReq. Si l’événement est en mesure de mémoriser l’occurrence d’un
événement (degré de concurrence non atteint), il répond immédiatement par ActiveAck, sinon
la fonction Prod (tâche) passe à l’état Blocked et la ressource d’exécution devient disponible
Transcription du modèle de performance en VHDL
M.C.S.E 105
pour une autre tâche (fonction ou activité). Après acquittement par l’événement, la fonction
passe alors le temps d’écriture nécessaire réalisé par la procédure DELAY. Durant cette attente,
la ressource d’exécution peut être préemptée par une tâche plus prioritaire. Le protocole se
termine ensuite par InactiveReq puis l’état de repos InactiveAck qui sert aussi à la fin de la
procédure SignalEv.
Pour un consommateur la procédure WaitEv (à droite de la figure) est identique mais avec
l’indication d’une attente d’événement par ActiveReq.
-Figure 4.6- Solution pour l’implantation d’une synchronisation par événement.
4.5.4 Transcription d’une variable partagée
La transcription d’une variable partagée nécessite de tenir compte du comportement
systématique de toute variable (c’est-à-dire la gestion cohérente des données) et de tous les
attributs qui particularisent son exploitation. Un protocole de communication est aussi utilisé
pour le couplage d’un élément de relation avec chaque fonction. Notons que le principe de
traduction consiste à nouveau à considérer que l’élément de relation est un élément passif.
-A- Caractéristiques et transcription d’un élément partagé
L'objet SharVar est une zone de mémorisation ou une ressource commune définie par
l’attribut ‘Policy, par un grandeur statique définissant sa taille (‘Capacity), son degré de partage
pour des accès multiples (‘Concurrency) et accessoirement par sa valeur (‘Value). Trois
grandeurs temporelles ‘Write, ‘Read et ‘Use sont aussi à considérer pour son utilisation.
*Add(Ev); *Sub(EV);
*Add(Ev); => si ‘Policy=Counter alors Ev:=Ev+1;
si ‘Policy=Boolean alors Ev:=1;
si ‘Policy=fugitive alors Ev:=1 si il existe
*Sub(Ev); => Ev:=Ev-1 si Users[i] est le dernier
des utilisateurs activés par l’événement
au moins un Users[i] en attente sur l’événement
Prod[1:m]
EvIn
User[1:n]
EvOut
EV
Prod[1:m] User[1:n]
InStatus[i]
OutStatus[i]
‘Policy
‘Write
‘Read
‘Write
SignalEv (Ev) utilisé dans Prod[i] WaitEv (Ev) utilisé dans User[i]
SignalEv
WaitEv
Ev
‘Policy
‘Write
‘Read
InStatus[1:m] OutStatus[1:n]
a) b)
c)
‘Concurrency
‘Concurrency
Ev
‘Read
States(Prod[1:m]) States(User[1:n])
/ActiveReq
TaskBlocked
Send
Wait
InAccess
(ActiveReq or
ActiveAck
ActiveAck
InactiveReq
InactiveAck
InactiveReq
InactiveAck
DELAY
(writeTime)
end
wait
OutValue
InactiveReq
InactiveAck
End DELAY
InactiveReq
ActiveAck
Wait
InactiveAck
Wait
ActiveAck
End DELAY
InactiveReq
InactiveAck
Wait
(ReadTime)
DELAY
NbUse < Concurrency
NbUse++;
NbUse--;
NbUse < Concurrency
NbUse++;
NbUse--;
/ ActiveReq
Receive
Wait
OutAccess
end
wait
Waiting Waiting
NbUse:=0;Ev=0;
Taskblocked
Wait
ActiveAck
Blocked
ActiveReq and
NbUse >= Concurrency
TaskBlocked
ActiveReq and
NbUse >= Concurrency
TaskBlocked
TaskBlocked) and
(ActiveReq or
TaskBlocked) and
TaskBlocked
ActiveAck
ActiveAck
Taskblocked
Wait
ActiveAck
Blocked
Wait
(Ev>0) and
(Ev = 0) and
Chapitre 4
106 M.C.S.E
L’élément partagé est transcrit en VHDL comme une entité instanciée sous la forme de
composant. Ses attributs associés sont les paramètres génériques de l’entité (attributs statiques)
et/ou font partie des entrées/sorties de l’entité (attributs dynamiques).
-B- Protocole de communication
La technique utilisée est similaire à celle employée pour le port.
-Figure 4.7- Solution pour l’implantation d’un échange par donnée partagée.
Le principe d’implantation d’une variable partagée est schématisé par la figure 4.7. La
figure 4.7-a représente la structure fonctionnelle constituée des fonctions Writer et Reader
reliées par la variable V. Les attributs ‘Write, ‘Read et ‘Use sur les liens entre les fonctions et
la variable surchargent les attributs ‘Write, ‘Read et ‘Use de V.
La structure de l’implantation en VHDL est décrite par la figure 4.7-b. La relation est
générale puisqu’il s’agit de coupler m écrivains et n lecteurs sur la même variable. Que ce soit
en entrée ou en sortie, le champ Status du signal Access implémente le protocole et le champ
Value est le support de la donnée. En effet, comme un lien d’accès à une variable partagée peut
être bidirectionnel, pour simplifier la description et l’implantation, un seul signal sous la forme
d’un vecteur est utilisé pour l’accès. La différenciation - lecture ou écriture - est faite par un
champ direction dans la définition de Access (champ direction).
Access
Reader[1:n]
Access
SharVar pour une concurrence
Writer[1:m] Reader[1:n]
/ActiveReq
Status[i] Status[j]
‘Capacity
‘Write
‘Read
‘Write
WriteSharVar ( Value, V) utilisé dans Writer[i] ReadSharVar (V, Value) utilisé dans Reader[j]
ReadSharVar
SharVar
‘Capacity
‘Write
‘Read
Status[1:m]
Value[1:m]
Status[1:n]
Value[1:n]
Reader[j] est la fonction lectrice de
a) b)
c)
‘Concurrency
‘Concurrency
Value
‘Policy
‘Use
‘Read
‘Use
‘Policy
V
V
Writer[i] est la fonction écrivain de plus forte urgence
plus forte urgence
States(Writer[1:m])
Writer[1:m]
WriteSharVar
States(Reader[1:n])
Value:=MValue;
TaskBlocked
Write
Wait
InAccess
(ActiveReq or
ActiveAck
ActiveAck
InactiveReq
InactiveAck
InactiveReq
InactiveAck
DELAY
(writeTime)
end
wait
Value
InactiveReq
InactiveAck
End DELAY
InactiveReq
ActiveAck
Wait
InactiveAck
Wait
ActiveAck
End DELAY
InactiveReq
InactiveAck
Wait
(ReadTime)
DELAY
NbUse < Concurrency
NbUse++;
NbUse < Concurrency
NbUse++;
NbUse--;
/ ActiveReq
Read
Wait
OutAccess
end
wait
Waiting Waiting
NbUse:=0;;
Taskblocked
Wait
ActiveAck
Blocked
ActiveReq and
NbUse >= Concurrency
TaskBlocked
ActiveReq and
NbUse >= Concurrency
TaskBlocked
TaskBlocked) and
(ActiveReq or
TaskBlocked) and
TaskBlocked
ActiveAck
ActiveAck
Taskblocked
Wait
ActiveAck
Blocked
Wait
t>=UseTime
t:=0
Wait
t>=UseTime
UseTime
t:=0;
(passive)
MValue:=Value;
Wait
(passive)
UseTime
NbUse--;
‘Use
Transcription du modèle de performance en VHDL
M.C.S.E 107
Très proche de ceux du port à N places ou de l’événement, l’automate modélisant le
comportement (figure 4.7-c) d’une variable partagée se distingue cependant par un état
supplémentaire WaitUseTime. Cet état représente un temps d’utilisation de la variable partagée
qui est passif par rapport à la ressource d’exécution des fonctions accédant à cette variable. Il
correspond par exemple aux temps d’accès d’un disque modélisé par une variable partagée.
Le protocole est modifié dans le cas d’une ressource. La figure suivante montre ce
protocole. Pour éviter la confusion, les noms des primitives s’appellent Alloc et Release. La
différence vient du fait que le temps ‘Use n’a pas de signification et que la ressource est
considérée occupée entre le Alloc et Release.
-Figure 4.8- Solution pour l’implantation d’une ressource commune.
-C- Implantation
La communication entre une fonction et une variable partagée ou une ressource est
implantée par un signal DefDataAccess regroupant Status et Value. Le signal est géré par une
fonction de résolution décrite ci-dessous.
TYPE DefDirection IS (read,write);
TYPE DefUDataAccess IS RECORD
data : DefBlock;
direction : DefDirection;
ReadTime : TIME;
WriteTime : TIME;
UseTime : TIME;
protocol : DefProtocol;
END RECORD;
TYPE DefUDataAccessVector IS ARRAY (NATURAL RANGE <>) OF DefUDataAccess;
FUNCTION ResolProtocol (Input: DefUDataAccessVector) return DefUDataAccess;
SUBTYPE DefDataAccess IS ResolProtocol DefUDataAccess;
TYPE DefDataAccessVector IS ARRAY (NATURAL RANGE <>) OF DefDataAccess;
TYPE DefDataPolicy IS (DataFifo,DataPriority,
ResourceFifo,ResourcePriority);
Alloc( V) c) Ressource pour une concurrence Release( V)
/ActiveReq
InValue
TaskBlocked
Wait
InAccess
(ActiveReq or
ActiveAck
ActiveAck
InactiveReq
InactiveAck
InactiveReq
InactiveAck
DELAY
(writeTime)
end
wait
OutValue
InactiveReq
InactiveAck
End DELAY
InactiveReq
ActiveAck
Wait
InactiveAck
Wait
ActiveAck
End DELAY
InactiveReq
InactiveAck
Wait
(ReadTime)
DELAY
NbUse < Concurrency
NbUse++;
NbUse < Concurrency
NbUse--;
/ ActiveReq
Wait
OutAccess
end
Waiting Waiting
NbUse:=0;;
Taskblocked
Wait
ActiveAck
Blocked
ActiveReq and
NbUse >= Concurrency
TaskBlocked
ActiveReq and
NbUse >= Concurrency
TaskBlocked
TaskBlocked) and
(ActiveReq or
TaskBlocked) and
TaskBlocked
ActiveAck
ActiveAck
Taskblocked
Wait
ActiveAck
Blocked
Wait
Alloc Release
wait
Chapitre 4
108 M.C.S.E
L’implantation VHDL pour une variable partagée pose le problème de la transcription des
temps UseTime (état WaitUseTime) et de la décrémentation de la variable NbUse après ce
temps. En effet, comme la concurrence peut-être multiple, il ne faut pas que l’attente sur
UseTime bloque le process (l’instruction Wait For est donc à proscrire). L’instruction After
n’est également pas utilisable puisqu’à chaque nouvelle affection toutes les modifications
ayant une date d’occurrence supérieure à celle de l’affectation en cours sont perdues. Nous
avons utilisé une fifo où l’on mémorise par ordre croissant la date de la prochaine
décrémentation de NbUse et le process est asservi sur une modification des protocoles des liens
sur la variable et sur la prochaine décrémentation de NbUse.
Comme les actions ne se font que sur transition au lieu d’utiliser une variable d’état pour
transcrire les automates, nous avons simplement utilisé l’instruction If...Else...End If en
réduisant les automates à deux états.
L’implantation VHDL d’une ressource commune est plus simple si l’on associe à chaque
lien sur la ressource un booléen pour savoir s’il y a déjà une allocation de la ressource avec ce
lien: ceci permet d’avoir une approche en ne considérant que les liens sur la ressource.
4.5.5 Bilan sur la transcription du modèle structurel
La partie délicate de la transcription a concerné la prise en compte d’un processeur logiciel
qui conduit à restreindre le degré de parallélisme des fonctions qu’il supporte. Comme VHDL
ne dispose pas de mécanisme de suspension de process, nous avons dû décrire explicitement
un composant ordonnanceur. Cet ordonnanceur est chargé de gérer les différentes tâches
(fonctions) allouées au processeur en fonction de la politique d’ordonnancement choisie
(attribut ‘Policy) et des priorités respectives de tâches (attribut ‘Priority). Le signal State
mémorisant l’état d’une tâche est modifié à la fois par la tâche et l’ordonnanceur. La valeur
courante de ce signal est donc gérée par une fonction de résolution basée sur une table de
transition. De plus, pour que tous les temps d’exécution n’évoluent que durant l’état "Active"
de la tâche concernée, ils sont tous simulés avec une procédure spécifique (procédure DELAY)
qui permet ainsi de gérer un point de préemption par la ressource d’exécution.
Une fonction est transcrite sous la forme d’une entité ou d’un block, ce qui permet de
respecter la hiérarchie du modèle MCSE et de garder la trace des entrées/sorties (port map) et
la généricité (generic map). Le block ne permet pas de traduire la notion de réplication/modèle
de fonctions, mais il offre, contrairement aux entités, la possibilité d’accéder à des variables
globales (Shared Variable de VHDL‘93) utiles par exemple pour le partage d’un générateur de
nombres aléatoires. Un élément de relation est transcrit par une entité dont les paramètres
génériques correspondent aux attributs de l’élément de relation. Cette entité est instanciée sous
la forme d’un composant et les attributs définis à ce stade sont statiques. L’entité gérant
l’élément de relation est passive par rapport à la ressource d’exécution car les temps d’accès à
l’élément de relation sont simulés du coté producteur/consommateur. Ainsi, elle n’a pas besoin
de tenir compte de l’état (active, inactive, bloquée ou en attente) de la fonction (tâche)
productrice ou consommatrice de l’information échangée.
Le couplage entre une fonction et un élément de relation est effectué avec un protocole de
communication en 4 phases implanté sous la forme d’un signal bidirectionnel et d’une fonction
de résolution. Ce protocole de communication permet de faire de la communication point à
point ou de la diffusion. Il ne limite donc pas les possibilités de topologie d’un système. Il
permet également de surcharger dynamiquement les attributs (temps d’accès en lecture et
Transcription du modèle de performance en VHDL
M.C.S.E 109
écriture) de l’élément de relation. Cette possibilité de surcharge est utilisée pour tenir compte
du coût de la communication inter-processeurs ou par exemple pour faire varier les temps
d’accès en fonction de la longueur des messages transmis. Du coté fonction, le protocole de
communication est implanté sous forme de procédures (primitives d’accès). Le manque de
généricité pour la déclaration des types VHDL est alors une limitation sérieuse. Pour faciliter
la génération du modèle VHDL et sa lisibilité, nous avons décidé de regrouper tous les types
d’éléments de relation dans un seul record. Une autre solution consistait à définir tous les types
séparément et à déclarer autant de primitives d’accès aux éléments de relation (surcharge de
procédures).
4.6 TRANSCRIPTION DU MODELE COMPORTEMENTAL
Le comportement de chaque fonction est modélisé comme un ensemble de process
synchronisés et coopérants. La simultanéité et les instances multiples sont possibles. Les règles
de transcription sont relativement similaires à celles utilisées pour la transcription du
SpecChart en VHDL [GAJSKI-93]. Quand une fonction ou une activité est séquentielle, il
s’agit d’une tâche pour la ressource d’exécution et ainsi elle se traduit en un process VHDL.
Dans le cas de la simultanéité, un process est associé pour chaque partie séquentielle. Des
éléments de synchronisation sont alors ajoutés. La transcription doit aussi satisfaire les
particularités de l’activation conditionnelle et de l’achèvement forcé. En plus, les conditions
d’activation peuvent être composées (Ordre strict, Et sans ordre, l’un, sélection). Il en est de
même pour les actions en sortie d’opérations et d’activités. Ce paragraphe décrit les solutions
de transcription retenues pour ces problèmes. Nous commençons tout d’abord par le cas du
modèle séquentiel.
Les paramètres et attributs de chaque fonction, activité, opération sont des paramètres
génériques des blocks et des entités. La procédure DELAY est à nouveau utilisée pour la
simulation de tous les temps d’exécution.
4.6.1 Transcription d’un modèle de comportement séquentiel
La transcription d’un modèle de comportement séquentiel ne pose pas de problème
particulier. Un process est utilisé pour cela. Si ce modèle est la description d’une fonction, alors
le process est encapsulé dans une entité ou dans un block.
La figure 4.9 donne un exemple de transcription sous la forme d’un block. Le choix du
block se justifie par l’emploi de la variable partagée rnd au niveau du tirage aléatoire de
l’alternative. Chaque opération est remplacée par la procédure DELAY qui simule le temps
d’exécution. Cette procédure prend en compte la grandeur State (ici SupervisionState) pour
connaître l’état actif de la ressource d’exécution (champ TaskState) et la puissance de cette
ressource (champ Power) (voir le modèle de simulation présenté dans le paragraphe 4.3).
Cette transcription répond aux cas de constructions: séquence, alternative, répétition. On
remarque aussi sur l’exemple la condition d’évolution sur la réception de Cmd ce qui se traduit
par l’appel de la procédure Receive, et les actions de transmission des messages OrderRec et
OrderRead[:] traduites par la procédure Send. Pour le dernier cas, la fonction de sélection du
destinataire est implantée très simplement par un argument de plus dans l’appel de Send et qui
indique l’indice du port concerné (ici CmdUser.Id). Ceci se justifie par le fait qu’en VHDL, on
ne peut pas écrire Send(CmdUser, OrderRead(CmdUser.Id), SupervisionState) car l’indice
d’un vecteur lors d’un appel procédural doit être une expression statique.
Chapitre 4
110 M.C.S.E
-Figure 4.9- Ecriture d’un modèle comportemental séquentiel.
4.6.2 Transcription pour un parallélisme
Il s’agit de transcrire les 2 situations représentées par la figure 4.10. La transcription
systématique consiste à considérer que le modèle active 2 ou plus de 2 process sur la divergence
ET et se met en attente d’achèvement de tous ces process pour assurer la convergence ET. La
divergence ET est un Fork, la convergence ET est un Join. Un protocole basé sur une variable
à trois états est utilisé pour les synchronisations. Il est implanté par une fonction de résolution
et les procédures Fork, WaitFork, Join et WaitJoin.
Cmd
*
OpRec OpRead
Else
‘Path=‘Id;
‘Proba
OR
S
OrderRec OrderRead[:]
‘Size=Cmd‘Size;
‘Size=Cmd‘Size;
OpRead‘Time = 1 ms;
OpRec‘Time = 1 ms;
‘Speed=Cmd‘Speed;
‘Speed=Cmd‘Speed;
‘Id=Cmd‘Id;
Supervision
Supervision : BLOCK
PORT (Cmd : INOUT DefPortOut;
OrderRec : INOUT DefPortIn;
OrderRead : INOUT DefPortInVector(1 TO n);
SupervisionState : INOUT DefState);
PORT MAP (Cmd=>Cmd,
OrderRec=>SupervisionOrderRec,
OrderRead=>SupervisionOrderRead,
SupervisionState=>SupervisionState);
BEGIN
SupervisionBehavior : PROCESS
VARIABLE j : INTEGER;
VARIABLE CmdUser : DefCmdUser;
BEGIN
LOOP
receive(Cmd,CmdUser,SupervisionState);
Uniform(rnd);
IF rnd <= Proba THEN
Delay(OpRecTime,SupervisionState);
send(CmdUser,OrderRec,SupervisionState);
ELSE
Delay(OpReadTime,SupervisionState);
send(CmdUser,OrderRead,CmdUser.Id,SupervisionState);
END IF;
END LOOP;
END PROCESS SupervisionBehavior;
END BLOCK Supervision;
Transcription du modèle de performance en VHDL
M.C.S.E 111
La description est donnée pour l’exemple de gauche.
-Figure 4.10- Représentation pour un parallélisme et transcription.
Sur l’exemple de gauche, le processus père OP indique le début de l’activité parallèle par
la primitive Fork et libère la ressource d’exécution (BlockingTask). Tous les process (Op1 et
Op2) associés aux branches parallèles qui étaient en attente de la synchronisation (WaitFork)
se mettent alors en attente du processeur (WaitingTask). Le plus prioritaire s’exécute puis
indique sa complétude par les primitives InactiveTask et Join. Lorsque toutes les branches
parallèles ont été exécutées, le processus père reprend la main (primitive WaitJoin et
WaitingTask).
Pour l’exemple de droite, tous les process OP[i] sont instanciés par une boucle (instruction
Generate) avec mise en attente sur le signal OpStatus. Fork active tous les process et WaitJoin
attend que tous les process soient achevés.
L’implantation du protocole est donné ci-après.
FUNCTION ResolForkJoin (Input : STD_ULOGIC_VECTOR) RETURN STD_ULOGIC;
SUBTYPE DefForkJoinStatus IS ResolForkJoin STD_ULOGIC;
TYPE DefForkJoinStatusVector IS ARRAY (NATURAL RANGE <>) OF
DefForkJoinStatus;
-- fonction de resolution pour l'implantation d'un Fork ou d'un Join
FUNCTION ResolForkJoin (Input : STD_ULOGIC_VECTOR) RETURN STD_ULOGIC IS
VARIABLE i : INTEGER;
VARIABLE result : STD_ULOGIC;
BEGIN
-- pour un fork il y a synchronisation des activations de toutes les
branches
-- pour un Join toutes les branches doivent indiquer leur fin d'execution
result := Input(input'LOW);
IF (Input'LENGTH>1) THEN
FOR i IN Input'LOW+1 TO Input'HIGH LOOP
IF result/=Input(i) THEN
-- tous les elements du vecteur ne sont pas identiques
result:='Z';
EXIT;
END IF;
END LOOP;
END IF;
RETURN result;
END ResolForkJoin;
&
&
Op
Op1||Op2 Op[1:n]
Simultanéité
Parallélisme multiple
Op1 Op2
OP: PROCESS
........;
..........
Fork(OpStatus);
BlockingTask(OpState);
WaitJoin(OpStatus);
WaitingTask(OpState)
..........;
END PROCESS Op;
Op1: PROCESS
........;
BEGIN
InactiveTask(Op1State);
LOOP
WaitFork(OpStatus);
WaitingTask(Op1State);
........;
InactiveTask(Op1State);
Join(OpStatus);
END LOOP;
END PROCESS Op1;
Chapitre 4
112 M.C.S.E
FUNCTION InitForkJoinStatus RETURN DefForkJoinStatus IS
BEGIN
RETURN '0';
END;
--
PROCEDURE Fork(SIGNAL ForkStatus : INOUT DefForkJoinStatus) IS
BEGIN
ForkStatus<='1';
WAIT UNTIL ForkStatus='1';
END Fork;
--
PROCEDURE WaitFork(SIGNAL ForkStatus : INOUT DefForkJoinStatus) IS
BEGIN
ForkStatus<='1';
WAIT UNTIL ForkStatus='1';
END WaitFork;
--
PROCEDURE Join(SIGNAL JoinStatus : INOUT DefForkJoinStatus) IS
BEGIN
JoinStatus<='0';
WAIT UNTIL JoinStatus='0';
END Join;
--
PROCEDURE WaitJoin(SIGNAL JoinStatus : INOUT DefForkJoinStatus) IS
BEGIN
JoinStatus<='0';
WAIT UNTIL JoinStatus='0';
END WaitJoin;
4.6.3 Transcription d’une activité raffinée
Pour conserver la lisibilité, la transcription d’une activité raffinée se fera de la même
manière que pour le parallélisme. L’activité est décrite comme un process qui sera activé par
un Fork. Lorsqu’une activité est générique et donc déclarée comme une partie autonome
instanciable dans d’autres comportements, l’activité est alors décrite comme un block avec ses
arguments d’entrée et de sortie définissant son lien avec son environnement.
4.6.4 Transcription pour l’activation conditionnelle
Il s’agit de permettre l’exécution d’une séquence d’opérations ou activités parmi un
ensemble dépendante d’une condition d’activation. La figure ci-après donne une exemple
caractéristique.
-Figure 4.11- Représentation d’une évolution alternative.
Op
E1
A1
Op&[(?E1&A1)|(?E2&A2)]
E2
A2
ou
Op&[?E1&A1|?E2&A2]
ConditionalActivation
Transcription du modèle de performance en VHDL
M.C.S.E 113
Après l’opération Op, il y a mise en attente sur les 2 conditions E1 et E2. La première
satisfaite implique l’exécution de l’opération associée. L’attente doit alors être supprimée sur
l’autre branche.
La traduction utilise à nouveau le protocole en 4 phases pour l’attente sur un port, une
variable partagée ou un événement. Chaque attente est signalée par ActiveReq; c’est l’objectif
de la procédure InitConditionalActivation. Une fonction procédure WaitConditionalActivation
est utilisée pour l’attente multiple. L’argument de sortie BranchNumber sert à s’orienter vers
l’exécution de la branche rendue active. Les différentes séquences sont décrites comme
branches d’un case. Un reset est nécessaire pour annuler les demandes d’attente; c’est le rôle
de la procédure ResetConditionalActivation.
La description d’un exemple est donnée ci-après. Il faut noter une difficulté rencontrée avec
VHDL ou avec le simulateur ModelTech qui nous a contraint d’utiliser une instruction
d’assignation concurrente. En effet le simulateur n’est pas capable de faire correctement le lien
entre les paramètres formels et les signaux concernés lors d’un appel procédural si les signaux
concernés ont plusieurs niveaux d’imbrication de records. Sans cette difficulté, on aurait pu
regrouper les procédures InitConditionalActivation, WaitConditionalActivation et
ResetConditionalActivation en une seule procédure.
Le programme ci-dessous est la traduction de l’attente conditionnelle utilisée dans la
description du comportement de la fonction SupervisonUsager de l’exemple du serveur vidéo
présenté dans le chapitre 7. Pour la compréhension, le comportement est modélisé par la figure
7.3.
TYPE DefProtocol IS RECORD
priority : NATURAL;
date : TIME;
status : DefHandshake;
END RECORD;
TYPE DefProtocolVector IS ARRAY (NATURAL RANGE <>) OF DefProtocol;
------------------------------------------------------------------
SIGNAL ProtocolVector : DefProtocolVector(1 TO 2);
BEGIN
-- assignation concurrente pour l'attente conditionnelle
ProtocolVector<=CmdUsager.protocol&RepCanal.protocol;
SupervisionUsagerBhv : PROCESS
VARIABLE CmdUser : DefCmdUser;
VARIABLE rep : DefRepCanal;
VARIABLE BranchNumber : NATURAL;
BEGIN
WaitingTask(State);
LOOP
InitConditionalActivation(CmdUsager.protocol,1,now);
InitConditionalActivation(RepCanal.protocol,1,now);
WaitConditionalActivation(ProtocolVector,
BranchNumber,
state);
ResetConditionalActivation(CmdUsager.protocol);
ResetConditionalActivation(RepCanal.protocol);
CASE BranchNumber IS
WHEN 1 =>
Receive(CmdUsager,CmdUser,State);
.......;
WHEN 2 =>
Receive(RepCanal,rep,state);
.......;
WHEN OTHERS => REPORT "Chercher la bug" SEVERITY FAILURE;
END CASE;
END LOOP;
END PROCESS SupervisionUsagerBhv;
Chapitre 4
114 M.C.S.E
Les procédures sont décrites ci-après.
PROCEDURE InitConditionalActivation(SIGNAL protocol : INOUT DefProtocol;
priority : IN NATURAL;
date : IN TIME) IS
BEGIN
protocol<=DefProtocol'(priority,date,ActiveReq);
END InitConditionalActivation;
--
PROCEDURE WaitConditionalActivation(SIGNAL ProtocolVector:IN
DefProtocolVector;
BranchNumber : OUT NATURAL;
SIGNAL TaskState : INOUT DefState) IS
VARIABLE i : INTEGER;
VARIABLE activation,TaskBlocking : BOOLEAN := FALSE;
BEGIN
activation:=FALSE;
WHILE NOT(activation) AND (TaskState.state/=ExitNow) LOOP
TaskBlocking:=TRUE;
FOR i IN ProtocolVector'RANGE LOOP
activation:=activation OR
(ProtocolVector(i).status=ActiveAck);
TaskBlocking:=TaskBlocking AND
(ProtocolVector(i).status=TaskBlocked);
IF activation THEN
BranchNumber:=i;
EXIT;
END IF;
END LOOP;
IF NOT(activation) THEN
IF (TaskBlocking AND (TaskState.state/=Blocked)) THEN
BlockingTask(TaskState);--procedure blocante;
END IF;
WAIT UNTIL (ProtocolVector'EVENT) OR (TaskState.state=ExitNow);
END IF;
END LOOP;
END WaitConditionnalActivation;
PROCEDURE ResetConditionnalActivation(SIGNAL Protocol:INOUT DefProtocol)
IS
BEGIN
Protocol<=InitProtocol;
END ResetConditionnalActivation;
Les primitives d’accès aux éléments de relation doivent maintenant tenir compte du fait que
le protocole en 4 phases peut être déjà commencé avant l’appel procédural.
4.6.5 Achèvement forcé d’activités
L’achèvement forcé d’une activité ou opération permet de modéliser certaines
circonstances particulières telles que des durées maximale d’exécution, l’apparition
d’exceptions, etc.
Le problème de la transcription d’un achèvement forcé d’activités (symbol Exit) est à
rapprocher de celui de la transcription des EI Arcs (Exit Immediatly) d’un SpecChart: Il faut
avoir la possibilité de terminer l’exécution d’un process immédiatement. Pour cela, comme
l’instruction "goto" n’existe pas en VHDL, une solution consiste à englober le code dans une
boucle et on utilise la construction VHDL Exit pour sortir de cette boucle.
Transcription du modèle de performance en VHDL
M.C.S.E 115
La figure 4.12 représente un exemple d’achèvement forcé d’activité et son principe de
transcription.
-Figure 4.12- Raffinement d’une activité avec achèvement forcé, principe de transcription.
Par rapport au SpecChart, comme notre modèle est non-interprété, il n’est pas nécessaire
d’ajouter une boucle supplémentaire puisqu’en modifiant la procédure Delay, on peut terminer
l’exécution d’une activité en temps nul. La nouvelle procédure Delay est donc:
PROCEDURE Delay( CONSTANT WaitTime : IN TIME;
SIGNAL TaskState : IN DefState) IS
VARIABLE GlobalTime,RemainTime: TIME := NullTime;
BEGIN
GlobalTime:=now;
IF (TaskState.power/=0.0) THEN
RemainTime:=WaitTime/TaskState.power;
ELSE RemainTime:=WaitTime;
END IF;
LOOP
IF (TaskState.state=Active) THEN
WAIT UNTIL (TaskState.state/=Active) FOR RemainTime;
END IF;
IF ((TaskState.state=Active) OR
(TaskState.state=ExitNow)) THEN exit;
ELSE
RemainTime:=RemainTime-(now-GlobalTime);
WAIT UNTIL (TaskState.state=Active);
GlobalTime:=now;
END IF;
END LOOP;
END Delay;
Le fait d’avoir placé la gestion des temps concernant l’accès à un élément de relation au
niveau des primitives et non de l’entité gérant la relation est ici un avantage indiscutable.
&
Op3
Lt:DefLt
Cmd
Op4 Op5
Stop
A1
A11
A12
Process Process
A111State
A111 A112
Process A11
A1State
Process A1
Block A11
A1Status
A11Status
Op1
TaskKiller
A11State
A112State
Op2
A10
A111 A112
(A10)
a) Exemple d’activité b) solution d’implantation
Chapitre 4
116 M.C.S.E
Nous sommes aussi obligés de rajouter l’état ActivityState=ExitNow (et non pas utiliser
l’état ActivityState=Inactive) pour pouvoir sortir de l’état ActivityState=Waiting lors d’une fin
d’activité forcée.
-Figure 4.13- Etats d’une fonction et conditions de transition pour la condition Exit.
Les déclarations concernant l’état d’une activité sont donc modifiées de la manière
suivante:
TYPE DefUTaskState IS (Nodriver,Inactive,Blocked,Waiting,Active,ExitNow);
TYPE DefUTaskStateTable IS ARRAY(DefUTaskState,DefUTaskState) OF DefUTaskState;
CONSTANT ResolutionTaskState : DefUTaskStateTable :=(
--|-----------|----------|-----------|---------|---------|----------|
--| Nodriver | Inactive | Blocked | Waiting | Active | ExitNow |
--|-----------|----------|-----------|---------|---------|----------|
( Nodriver, Inactive, Blocked, Waiting, Active, ExitNow), --| Nodriver |
( Inactive, Inactive, Inactive, Waiting, Inactive, Inactive), --| Inactive |
( Blocked, Inactive, Blocked, Waiting, Blocked, ExitNow), --| Blocked |
( Waiting, Waiting, Waiting, Waiting, Active, ExitNow), --| Waiting |
( ExitNow, Inactive, ExitNow, ExitNow, ExitNow, ExitNow) --| ExitNow |
);
TYPE DefUState IS RECORD
state : DefUTaskState;
priority : NATURAL;
deadline : TIME;
power : REAL;
END RECORD;
TYPE DefUStateVector IS ARRAY (NATURAL RANGE <>) OF DefUState;
FUNCTION ResolState (Input : DefUStateVector) RETURN DefUState;
SUBTYPE DefState IS ResolState DefUState;
TYPE DefStateVector IS ARRAY (NATURAL RANGE <>) OF DefState;
TYPE DefUTaskStateVector IS ARRAY (NATURAL RANGE<>) OF DefUTaskState;
FUNCTION ResolTaskState (Input : DefUTaslStateVector) RETURN DefUTaskState;
SUBTYPE DefTaskState IS ResolTaskState DefUTaskState;
TYPE DefTaskStateVector IS ARRAY (NATURAL RANGE <>) OF DefTaskState;
Evidemment, si une activité est désactivée et que l’on continue l’exécution de son code
même en temps nul, il ne faut pas exécuter des actions sur les éléments de relations. Les
primitives gérant les éléments de relation devront donc être aussi modifiées pour tenir compte
de l’état ActivityState=ExitNow.
Condition satisfaite
Début exécution
Inactive Wait
Ressource allouée
Waiting
Ressource préemptée
attente condition Fin exécution
Blocked eAncdtive
ExitNow
Exit
Exit
Exit
Fin exécution
Transcription du modèle de performance en VHDL
M.C.S.E 117
Cependant, pour un élément de relation, si le protocole en 4 phases a déjà été commencé, il
est préférable de terminer l’accès à cet élément avant de terminer l’exécution du code de
l’activité pour ne pas perdre un degré de concurrence. Dans ce cas on générera une action mais
en temps nul.
En supposant dans l’exemple de la figure 4.12 que Cmd est un événement et que l’activité
A11 est implantée sur un processeur, la nouvelle primitive SignalEv est:
PROCEDURE SignalEv( SIGNAL eve : INOUT DefSignalIn;
LinkWriteTime : IN TIME;
priority : IN INTEGER;
date : IN TIME;
SIGNAL TaskState : INOUT DefState) IS
VARIABLE TmpEve : DefUSignalIn;
BEGIN
IF (TaskState.state/=ExitNow) THEN
eve<=DefUSignalIn'(NullTime,DefProtocol'(priority,date,ActiveReq));
WAIT UNTIL (eve.protocol.status=ActiveAck) OR
(TaskState.state=ExitNow) OR
(eve.protocol.status=TaskBlocked);
IF ((eve.protocol.status=TaskBlocked) AND
(TaskState.state/=ExitNow)) THEN
--BlockingTask(TaskState);
WAIT UNTIL (eve.protocol.status=ActiveAck) OR
(TaskState.state=ExitNow);
END IF;
IF (eve.protocol.status=ActiveAck) THEN
TmpEve:=eve;
IF (LinkWriteTime/=NullTime) THEN
TmpEve.WriteTime:=LinkWriteTime;
END IF;
--WaitingTask(TaskState);
IF (TmpEve.WriteTime/=NullTime) THEN
Delay(TmpEve.WriteTime);--,TaskState);
END IF;
TmpEve.protocol.status:=InactiveReq;
eve<=TmpEve;
WAIT UNTIL eve.protocol.status=InactiveReq;
END IF;
eve.protocol.status<=InactiveAck;
END IF;
END SignalEv;
Si l’activité est implantée sur un processeur, il nous faut enfin également modifier les
primitives BlockingTask et WaitingTask pour ne pas rester bloqué dans ces primitives lors
d’une fin d’exécution forcée. Les nouvelles procédures sont les suivantes:
PROCEDURE BlockingTask(SIGNAL TaskState : INOUT DefState) IS
VARIABLE TmpTaskState : DefUState;
BEGIN
IF (TaskState.state=Waiting) THEN
-- attente du C.P.U. ou d'une fin d'execution forcee
WAIT UNTIL (TaskState.state=Active) OR (TaskState.state=ExitNow);
END IF;
IF (TaskState.state=Active) OR
(TaskState.state=Nodriver) THEN
TmpTaskState:=TaskState;
IF TmpTaskState.priority=NATURAL'LOW THEN
TmpTaskState.priority:=1;
END IF;
TmpTaskState.state:=Blocked;
TaskState<=TmpTaskState;
WAIT UNTIL (TaskState.state=Blocked) OR (TaskState.state=ExitNow);
TmpTaskState:=TaskState;
IF TmpTaskState.priority=NATURAL'LOW THEN
TmpTaskState.priority:=1;
Chapitre 4
118 M.C.S.E
END IF;
TmpTaskState.state:=Nodriver;
TaskState<=TmpTaskState;
END IF;
END BlockingTask;
PROCEDURE WaitingTask(SIGNAL TaskState : INOUT DefState) IS
VARIABLE TmpTaskState : DefUState;
BEGIN
IF ((TaskState.state/=Active) AND
(TaskState.state/=ExitNow)) THEN
IF (TaskState.state/=Waiting) THEN
TmpTaskState:=TaskState;
TmpTaskState.state:=Waiting;
IF TmpTaskState.priority=NATURAL'LOW THEN
TmpTaskState.priority:=1;
END IF;
TaskState<=TmpTaskState;
WAIT UNTIL (TaskState.state=Waiting) OR
(TaskState.state=ExitNow);
TmpTaskState:=TaskState;
IF TmpTaskState.priority=NATURAL'LOW THEN
TmpTaskState.priority:=1;
END IF;
TmpTaskState.state:=Nodriver;
TaskState<=TmpTaskState;
END IF;
-- attente du C.P.U. ou d'une fin d'execution forcee
WAIT UNTIL (TaskState.state=Active) OR (TaskState.state=ExitNow);
END IF;
END WaitingTask;
Si l’activité A11 n’est pas implantée sur un processeur, alors la primitive Delay est:
PROCEDURE Delay (CONSTANT WaitTime : IN TIME;
SIGNAL TaskState : IN DefTaskState) IS
BEGIN
IF (TaskState/=ExitNow) THEN
WAIT UNTIL (TaskState=ExitNow) FOR WaitTime;
END IF;
END Delay;
Les règles de transcription précédentes permettent relativement aisément l’écriture du
modèle VHDL. La partie délicate est l’implantation du carré noir qui implique la fin immédiate
de l’activité. L’exemple se transcrit sous la forme de 2 blocks et de 5 process (figure 4.12-b).
Les variables State de chaque process sont utilisées pour, d’une part activer les process A1,
A11, A111, A112, d’autre part pour observer l’état de fin (Exit) correspondant à l’un des carrés
ce qui entraîne la fin de A1, l’arrêt de tous les process fils c’est-à-dire A11, A112 et A111
(s’obtient par State=ExitNow) et le retour en position initiale de tous les process pour la
prochaine activation. Les variables Status sont utilisées pour synchroniser les différentes
branches d’un parallélisme. Il est bon de noter qu’une condition d’achèvement se traduit
implicitement par un parallélisme où une branche est en attente de la condition d’arrêt et l’autre
branche exécute l’activité avec achèvement forcé.
La procédure concurrente TaskKiller a la charge de désactiver tous les process d’une
activité en fonction de l’état de l’activité mère.
PROCEDURE TaskKiller (SIGNAL MotherTaskState : INOUT DefState;
SIGNAL TaskStateVector : INOUT DefStateVector) IS
VARIABLE i : NATURAL;
BEGIN
LOOP
WAIT UNTIL MotherTaskState’EVENT;
IF (MotherTaskState.state=ExitNow) THEN
Transcription du modèle de performance en VHDL
M.C.S.E 119
FOR i IN TaskStateVector’RANGE LOOP
KillingTask(TaskStateVector(i));
END LOOP;
END IF;
END LOOP;
END TaskKiller;
Elle utilise pour cela la primitive KillingTask décrite ci-dessous.
PROCEDURE KillingTask (SIGNAL TaskState : INOUT DefState) IS
VARIABLE TmpState : DefUState;
BEGIN
TmpState:=TaskState;
TmpState.state:=ExitNow;
TaskState<=TmpState;
WAIT UNTIL (TaskState.state=ExitNow) OR (TaskState.state=Inactive);
TaskState.state<=NoDriver;
END KillingTask;
La transcription en VHDL de l’exemple est alors la suivante:
library VideoServerLibrary;
use VideoServerLibrary.VideoServerDeclaration.all;
ENTITY ProblemExit IS
END ProblemExit;
ARCHITECTURE behavioral OF ProblemExit IS
FOR all : EveObject
use entity VideoServerLibrary.EveObject(behavioral);
SIGNAL StopIn,CmdIn : DefSignalIn;
SIGNAL StopOut,CmdOut : DefSignalOut;
BEGIN
Stop : EveObject
GENERIC MAP (NbUsersInput=>1,NbUsersOutput=>1,
policy=>booleen,concurrency=>1,
InitValueSema=>0,WriteTime=>NullTime,
ReadTime=>NullTime)
PORT MAP (InputAccesses(1)=>StopIn,
OutputAccesses(1)=>StopOut);
Cmd : EveObject
GENERIC MAP (NbUsersInput=>1,NbUsersOutput=>1,
policy=>booleen,concurrency=>1,
InitValueSema=>0,WriteTime=>NullTime,
ReadTime=>NullTime)
PORT MAP (InputAccesses(1)=>CmdIn,
OutputAccesses(1)=>CmdOut);
source : BLOCK
PORT (Stop : INOUT DefSignalIn);
PORT MAP (Stop=>StopIn);
BEGIN
SourceBehavior : PROCESS
CONSTANT TSourceTime : TIME := 2 ms;
BEGIN
LOOP
Delay(TSourceTime);
SignalEv(Stop,NullTime);
END LOOP;
END PROCESS SourceBehavior;
END BLOCK source;
destination : BLOCK
PORT (Cmd : INOUT DefSignalOut);
PORT MAP (Cmd=>CmdOut);
BEGIN
DestinationBehavior : PROCESS
CONSTANT TDestinationTime : TIME := 2 ms;
BEGIN
LOOP
WaitEv(Cmd,NullTime);
Delay(TDestinationTime);
END LOOP;
Chapitre 4
120 M.C.S.E
END PROCESS DestinationBehavior;
END BLOCK destination;
ExitExample : BLOCK
PORT (Stop : INOUT DefSignalOut;
Cmd : INOUT DefSignalIn);
PORT MAP (Stop=>StopOut,
Cmd=>CmdIn);
Signal A1State : DefTaskState;
BEGIN
A1 : BLOCK
PORT(Stop : INOUT DefSignalOut;
A1State : INOUT DefTaskState);
PORT MAP(Stop=>Stop,
A1State=>A1State);
SIGNAL A1Status : DefForkJoinStatus := InitForkJoinStatus;
SIGNAL A11State : DefTaskState;
CONSTANT A111Time : TIME := 10 ms;
CONSTANT Op1Time : TIME :=1 ms;
CONSTANT Op2Time : TIME := 2 ms;
CONSTANT Op3Time : TIME := 3 ms;
CONSTANT Op4Time : TIME := 1 ms;
CONSTANT Op5Time : TIME := 2 ms;
BEGIN
-- procedure concurrente
ReleaseSignaldriver(TaskStateVector(1)=>A1State,
TaskStateVector(2)=>A11State);
A1Behavior : PROCESS
BEGIN
InactiveTask(A1State);
LOOP
WaitingTask(A1State);
Delay(Op1Time,A1State);
Fork(A1Status);
WaitEv(Stop,NullTime,A1State);
KillingTask(A1State);
KillingTask(A11State);
WaitJoin(A1Status);
InactiveTasK(A1State);
END LOOP;
END PROCESS A1Behavior;
A11 : BLOCK
PORT(Cmd : INOUT DefSignalIn;
A1Status : INOUT DefForkJoinStatus;
A11State : INOUT DefTaskState);
PORT MAP(Cmd=>Cmd,
A1Status=>A1Status,
A11State=>A11State);
SIGNAL A11Status : DefForkJoinStatus
:= InitForkJoinStatus;
SIGNAL LtIn : DefSignalIn;
SIGNAL LtOut : DefSignalOut;
SIGNAL A111State,A112State : DefTaskState;
BEGIN
ReleaseSignaldriver(TaskStateVector(1)=>A11State,
TaskStateVector(2)=>A111State
TaskStateVector(3)=>A112State);
TaskKiller(MotherTaskState=>A11State,
TaskStateVector(1)=>A111State,
TaskStateVector(2)=>A112State);
Lt : EveObject
GENERIC MAP (NbUsersInput=>1,NbUsersOutput=>1,
policy=>booleen,concurrency=>1,
InitValueSema=>0,WriteTime=>NullTime,
ReadTime=>NullTime)
PORT MAP (InputAccesses(1)=>LtIn,
OutputAccesses(1)=>LtOut);
A11Behavior : PROCESS
BEGIN
InactiveTask(A11State);
Transcription du modèle de performance en VHDL
M.C.S.E 121
LOOP
WaitFork(A1Status);
WaitingTask(A11State);
Delay(Op2Time,A11State);
IF (A11State/=ExitNow) THEN
Fork(A11Status);
WaitJoin(A11Status);
END IF;
InactiveTask(A11State);
Join(A1Status);
END LOOP;
END PROCESS A11Behavior;
A111Behavior: PROCESS
BEGIN
InactiveTask(A111State);
LOOP
WaitFork(A11Status);
WaitingTask(A111State);
Delay(A111Time,A111State);
SignalEv(LtIn,NullTime,A111State);
Delay(Op4Time,A111State);
InactiveTask(A111State);
Join(A11Status);
END LOOP;
END PROCESS A111Behavior;
A112Behavior: PROCESS
BEGIN
InactiveTask(A112State);
LOOP
WaitFork(A11Status);
WaitingTask(A112State);
Delay(Op3Time,A112State);
SignalEv(CmdIn,NullTime,A112State);
WaitEv(LtOut,NullTime,A112State);
Delay(Op5Time,A112State);
InactiveTask(A112State);
Join(A11Status);
END LOOP;
END PROCESS A112Behavior;
END BLOCK A11;
END BLOCK A1;
END BLOCK ExitExample;
END Behavioral;
4.6.6 Transcription des conditions d’activation
Des conditions composées ont été prévues dans le modèle de performance pour le contrôle
du comportement d’une fonction ou d’une activité.
La figure 4.14 rappelle les possibilités et indique les solutions de transcription retenues.
L’ordre strict est simple puisqu’il suffit de mettre en séquence les diverses attentes (figure
4.14-a). L’ordre ET implique une simultanéité d’attente de toutes les conditions (figure
4.14-b), la poursuite se faisant lorsqu’elles sont toutes satisfaites. On utilise pour cela la
technique de l’activation multiple déjà vue dans le paragraphe 4.6.2. L’attente OU est identique
à une attente conditionnelle multiple (figure 4.14-c). On utilise donc cette technique sachant
qu’une seule séquence est exécutable après. La Sélection (figure 4.14-d) ne pose pas de
difficultés car il s’agit d’indiquer l’indice (attribut ‘Path) de l’entrée sélectionnée dans le
vecteur.
Chapitre 4
122 M.C.S.E
-Figure 4.14- Les conditions et leur principe de transcription.
4.6.7 Transcription des actions
La transcription des actions multiples est la duale de celle des conditions et ne pose pas de
difficultés particulières. Seul le cas de la simultanéité diffère et nécessite l’activation de
process synchronisés par les méthodes Fork/Join (figure 4.15-b).
-Figure 4.15- Les actions et leur principe de transcription.
E1
E2
Op1&?(E1&E2)&A1
E1
E2
Op1&?(E1^E2)&A1
E1
E2
Op1&?(E1|E2)&A1 Op1&?$Pt[:]&A1
ET sans ordre
Pt[1:n]
Ordre strict L’un Sélection
& ^ OR S
E1
E2
&
E1
a) b) c) d)
Idem à b) mais en
utilisant la technique
de l’attente conditionnelle
multiple
Sélection par l’indice
dans le vecteur
E2
OP: PROCESS
........;
..........
BlockingTask(OpState);
Fork(OpStatus);
WaitJoin(OpStatus);
WaitingTask(OpState)
..........;
END PROCESS OP;
E1AndWithoutOrder: PROCESS
BEGIN
InactiveTask(E1AndWithoutOrderState);
LOOP
WaitFork(OpStatus);
WaitingTask(E1AndWithoutOrderState);
WaitEv(E1,E1AndWithoutOrderState);
InactiveTask(E1AndWithoutOrderState);
Join(OpStatus);
END LOOP;
END PROCESS E1AndWithoutOrder;
OP: PROCESS
........;
WaitEv(E1,OpState);
WaitEv(E2,OpState);
..........;
END PROCESS OP;
a)
b)
c)
OP: PROCESS
........;
InitConditionalActivation(E1.protocol,1,now);
InitConditionalActivation(E2.protocol,1,now);
WaitConditionalActivation(ProtocolVector,
BranchNumber,
state);
ResetConditionalActivation(E1.protocol);
ResetConditionalActivation(E2.protocol);
CASE BranchNumber IS
WHEN 1 =>
WaitEv(E1,state);
.......;
WHEN 2 =>
WaitEv(E2,state);
.......;
END CASE;
..........;
END PROCESS OP;
S1
^
S2
S
Op&!$Pt[:]
S1 Pt(1:n)
OR
S2
Alternative Sélection
Op&!(S1|S2)
Simultanéité
Op&!(S1^S2) ‘Path
S1
&
S2
Op&!(S1&S2)
Séquence
S1
S2
&
S1
a) b) c) d)
Utilisation de la Sélection par l’indice
S2 condition pour l’exécution dans le vecteur
de la sortie sélectionnée
Transcription du modèle de performance en VHDL
M.C.S.E 123
4.6.8 Bilan sur la transcription du modèle comportemental
La transcription d’un modèle de comportement séquentiel (utilisation d’un process VHDL)
et les constructions telles que l’alternative et la répétition n’ont pas posé de difficulté. Dans le
cas général, le comportement de chaque fonction est modélisé comme un ensemble de process
synchronisés et coopérants. Le mécanisme de synchronisation de process concurrents est très
simple. Il est basé sur l’utilisation d’un signal à trois états dont la valeur courante est gérée avec
une fonction de résolution.
Le protocole de communication en 4 phases a permis de traduire aisément l’attente
conditionnelle. Les primitives d’accès aux éléments de relation ont été modifiées car le
protocole peut maintenant être déjà commencé lors de leur appel procédural.
La transcription de l’achèvement forcé d’activité a été plus difficile. Elle a néanmoins été
facilitée par le fait que l’entité gérant un élément de relation est passive par rapport à la
ressource d’exécution des fonctions ou activités. En effet, les temps d’accès sont gérés au
niveau des primitives d’accès et non pas par l’entité modélisant l’élément de relation. Un état
supplémentaire (ExitNow) a été rajouté à l’ensemble des états possibles d’un tâche (fonction
ou activité). Les primitives associées à l’état d’une tâche ont donc été légèrement modifiées.
Les primitives d’accès à un élément de relation ont également été enrichies pour prendre en
compte une fin d’activité forcé sans perdre pour autant un degré de concurrence sur les accès
à l’élément de relation utilisé.
Les conditions et actions simples se traduisent par l’appel à une primitive d’accès. La
traduction des conditions ou actions composées repose sur l’utilisation des principes de
traductions définis pour le parallélisme et l’attente conditionnelle.
4.7 CONNEXION ENTRE ELEMENTS DE RELATION ET COMPOSANTS ACTIFS
En VHDL, les éléments sont reliés obligatoirement entre eux par des signaux définis par un
type. Comme la généricité de définition d’un type est limitée, l’instanciation multiple et le
respect de la hiérarchie du modèle source nous amènent à considérer trois cas de problèmes.
4.7.1 Utilisation d’un lien de connexion uni-dimensionnel
Si l’élément de relation est simple ou multiple mais avec un seul consommateur/producteur
(correspondance indice par indice ou élément actif simple), alors le signal de connexion est un
vecteur. Ce vecteur regroupe tous les accès (ou liens) rattachés à l’élément de relation. Pour
des problèmes de convention de nom et de restriction au niveau du port map du composant
gérant l’élément de relation (le simulateur utilisé n’accepte pas l’opérateur de concaténation &
de signaux lors du port map), nous utilisons des alias pour distribuer les éléments du vecteur
sur les différentes fonctions; ce qui nous oblige à gérer les indices de ce vecteur et de ces alias.
La figure 4.16 représente un cas où le signal reliant le composant gérant l’élément de
relation et les blocks représentant les fonctions est obligatoirement un vecteur. La structure
fonctionnelle considérée (figure 4.16-a) fait partie de l’exemple du serveur vidéo présenté dans
le chapitre 7. Deux fonctions multiples Enregistrement et Lecture accèdent à une variable
partagée nommée Séquences. La traduction VHDL (figure 4.16-c) utilise un vecteur nommé
Chapitre 4
124 M.C.S.E
SequencesAccess et deux alias LectureSequences et EnregistrementSequences pour répartir ce
vecteur sur la fonction Lecture et la fonction Enregistrement.
-Figure 4.16- Structure fonctionnelle et code MCSE et VHDL d’un élément de relation simple.
Il faut déterminer la taille du vecteur (pour les ports et les événements, il faut déclarer un
vecteur d’entrée et un vecteur de sortie). Pour des problèmes de convention de nom et de
restrictions au niveau de la connexion du port map, nous utilisons des ALIAS pour distribuer
les éléments du vecteur sur les différentes fonctions; ce qui nous oblige à gérer les indices de
ce vecteur.
4.7.2 Utilisation d’un lien de connexion bi-dimensionnel
Si l’élément de relation est multiple et est relié à plusieurs producteurs/consommateurs
alors le signal de connexion est un vecteur de vecteur.
La figure 4.17 donne un exemple ainsi que le principe de transcription pour ce cas.
L’exemple est dérivé de l’exemple précédent. La variable Séquences a été remplacée par un
port (DemD) et une fonction (Disque) multiple. Le rond noir sur les liens entre le port DemD
Séquences
Enregistrement[1:N] Lecture[1:N]
...
<Var> Sequences : DefSequences;
<Component> [1:n] Enregistrement
(InOut Var Sequences : DefSequences;
...);
<EndComponent>
<Component> [1:n] Lecture
(In Var Sequences : DefSequences;
...);
<EndComponent>
...
CONSTANT NPlus1 : INTEGER := n+1;
CONSTANT DeuxN : INTEGER := n+n;
...
Serveur : BLOCK
...
SIGNAL SequencesAccess:DefDataAccessVector(1 TO DeuxN);
ALIAS EnregistrementSequences is SequencesAccess(1 to n);
ALIAS LectureSequences is SequencesAccess(Nplus1 to DeuxN);
...
BEGIN
...
Sequences : DataObject
GENERIC MAP(NbUsers=>DeuxN,
...)
PORT MAP (Accesses=>LectureEnregistrementSequences,
...);
...
Lectures : BLOCK
PORT (Sequences : INOUT DefDataAccessVector(1 TO n);
...);
PORT MAP(Sequences=>EnregistrementSequences,
...);
BEGIN
MultipleInstanciation: FOR i IN 1 TO n generate
Lecture : BLOCK
PORT (Sequences : INOUT DefDataAccess;
...);
PORT MAP (Sequences=>Sequences(i),
...);
BEGIN
END BLOCK Lecture;
END GENERATE MultipleInstanciation;
END BLOCK Lectures;
...
Enregistrements : BLOCK
PORT (Sequences : INOUT DefDataAccessVector(1 TO n);
...);
PORT MAP (Sequences=>LectureSequences,
...);
BEGIN
MultipleInstanciation: FOR i IN 1 TO n generate
Enregistrement : BLOCK
PORT (Sequences : INOUT DefDataAccess;
...);
PORT MAP (Sequences=>Sequences(i),
...);
BEGIN
END BLOCK Enregistrement;
END GENERATE MultipleInstanciation;
END BLOCK Enregistrements;
...
END BLOCK Serveur;
a) Représentation graphique de la structure
fonctionnelle du système
b) Représentation textuelle partielle du système
c) Code VHDLpartiel
Transcription du modèle de performance en VHDL
M.C.S.E 125
et les producteurs de messages Enregistrement et Lecture indique que tous les éléments du
vecteur de fonction Enregistrement (respectivement Lecture) peuvent accéder à chaque
élément du vecteur de port DemD. Ainsi, chaque élément du vecteur de port DemD est rattaché
à 2*N fonctions d’où la déclaration d’un vecteur de dimension P d’un vecteur de dimension
2*N. Comme la langage VHDL ne permet pas de définir un vecteur non contraint d’un vecteur
non contraint et ne permet pas de définir des paramètres génériques au niveau d’un package,
les types et la primitive d’accès sont nécessairement définis au niveau de l’entité.
-Figure 4.17- Structure fonctionnelle et code VHDL d’un élément de relation multiple.
Enregistrement Lecture
Disque[1:P]
DemD[1:P]
[1:N] [1:N]
...
CONSTANT NPlus1 : INTEGER := n+1;
CONSTANT DeuxN : INTEGER := n+n;
...
Serveur : BLOCK
...
TYPE DefDemDVectorOfPortInVector IS ARRAY
(NATURAL RANGE <>) OF DefPortInVector(1 TO DeuxN);
SIGNAL LectureEnregistrementDemD:
DefDemDVectorOfPortInVector(1 TO P);
...
-- on ne peut pas definir des types non contraint
d'elements non
-- contraint donc comme on ne connait pas N et ND(P) au
niveau du
-- Package on est oblige de declarer des primitives send
a ce niveau
PROCEDURE send( information : IN DefDemD;
SIGNAL message : INOUT DefDemDVectorOfPortInVector;
dest : IN NATURAL;
source : IN NATURAL;
LinkWriteTime : IN TIME;
priority : IN NATURAL;
date : IN TIME) IS
VARIABLE TmpPortAccess : DefUPortIn;
BEGIN
TmpPortAccess.information.InfDemD:=information;
TmpPortAccess.protocol:=
DefProtocol'(priority,date,ActiveReq);
message(dest)(source)<=TmpPortAccess;
...
END send;
...
...
BEGIN
...
InstantiationPortDemD : FOR i IN 1 TO P generate
PortDemD : PortObject
GENERIC MAP (NbUsersInput=>DeuxN,NbUsersOutput=>1,
...)
PORT MAP (InputAccesses=>LectureEnregistrementDemD(i),
OutputAccesses(1)=>DisquesDemD(i),
...);
END GENERATE InstantiationPortDemD;
...
Sequences : BLOCK
PORT (DemD : INOUT DefPortOutVector(1 TO P);
...);
PORT MAP (DemD=>DisquesDemD,
...);
BEGIN
MultipleInstanciation: FOR i IN 1 TO P generate
Disques : BLOCK
PORT (DemD : INOUT DefPortOut;
...);
PORT MAP (DemD=>DemD(i),
...);
...
END BLOCK Disques;
END GENERATE MultipleInstanciation;
END BLOCK Sequences;
...
Lectures : BLOCK
PORT( DemD : INOUT DefDemDVectorOfPortInVector(1 TO P);
...);
PORT MAP (DemD=>LectureEnregistrementDemD,
...);
BEGIN
MultipleInstanciation: FOR i IN 1 TO n generate
Lecture : BLOCK
PORT (DemD : INOUT DefDemDVectorOfPortInVector(1 TO P);
...);
PORT MAP (DemD=>DemD,
...);
...
END BLOCK Lecture;
END GENERATE MultipleInstanciation;
END BLOCK Lectures;
...
Enregistrements : BLOCK
PORT (DemD : INOUT DefDemDVectorOfPortInVector(1 TO P);
...);
PORT MAP (DemD=>LectureEnregistrementDemD,
...);
BEGIN
MultipleInstanciation: FOR i IN 1 TO n generate
Enregistrement : BLOCK
PORT (DemD : INOUT DefDemDVectorOfPortInVector(1 TO P);
...);
PORT MAP (DemD=>DemD,
...);
...
END BLOCK Enregistrement;
END GENERATE MultipleInstanciation;
END BLOCK Enregistrements;
...
END BLOCK Serveur;
...
b) Code VHDLpartiel
a) Représentation graphique de la structure
fonctionnelle du système
Chapitre 4
126 M.C.S.E
Au niveau des primitives d’accès, chaque producteur doit alors donner son identité et
l’indice du port destinataire du message.
4.7.3 Problème des accès de niveaux hiérarchiques différents.
Un point particulier de la transcription en VHDL concerne les éléments de relation à
multiple producteurs/consommateurs lorsque les producteurs/consommateurs se situent dans
des niveaux hiérarchiques différents comme le montre l’exemple de la Figure 4.18.
-Figure 4.18- Transcription VHDL d’une variable à multiples écritures
Deux approches sont possibles pour ce problème mais aucune n’est réellement
statisfaisante:
- La première approche (solution a) consiste à utiliser une interface dans chaque
fonction (décodeur de priorité). La priorité de l’accès devient alors locale au niveau.
Si l’on ne tient pas compte de l’attribut ‘Concurrency de l’élément de relation
(concurrence infinie), cette implantation est possible et permet de respecter la
hiérarchie du modèle MCSE.
- Si l’on doit tenir compte de l’attribut ‘Concurrency, on n’a pas d’autres choix que de
mettre à plat la description (solution b). Mais, cette mise à plat n’est pas possible si
il y a une imbrication de fonctions multiples sur plusieurs niveaux.
F1
F2
F3
F4
F5
F6
V
F1
F3
F4
F5
élément de F6
relation
Entité
Block
Block
Block
Block
Composant
F1
F2
F3
F4
F5
F6
Interface d’
élément de
relation élément de
relation
Block Entité
Block
Block
Block
Block
Composant
Composant
Solution a Solution b
Transcription du modèle de performance en VHDL
M.C.S.E 127
4.8 EXTRACTION DES RESULTATS D’UN MODELE DE PERFORMANCE
L’évaluation des performances d’un système nécessite l’extraction des informations
pertinentes pour l’analyse. Ces informations pertinentes dépendent des indices de performance
à analyser.
Le monitoring, terme aussi utilisé pour l’extraction de performances, concerne d’une
manière générale l’observation de:
- l’état des fonctions, activités, opérations, processeurs,
- l’état des éléments de relation,
- le respect de certaines contraintes telles que des contraintes de temps par exemple.
Deux solutions de monitoring sont envisageables:
- une solution systématique qui se traduit par une instrumentation automatique du code
VHDL pour observer toutes les transitions exploitables pour les performances,
- une solution spécifique pour chaque modèle. Le code VHDL ajouté est décidé et écrit
par le concepteur du modèle pour ses besoins propres. Une librairie de composants de
monitoring peut être mise à disposition du concepteur.
-A- Solution systématique: génération d’un fichier de trace et analyseur de performances
La première solution fait l’objet d’une étude approfondie par l’équipe et se traduit par le
développement d’un outil temps-réel d’analyse de performances. Cet outil est présenté plus en
détail dans [CALVEZ-95b] [CALVEZ-95c] [CALVEZ-98a].
Pour l’exemple du serveur vidéo présenté dans le chapitre 7, avec la trace générée par
simulation et l’outil d’analyse de trace, on observe:
- le nombre d’utilisateurs actifs (NbUsers),
- la charge globale imposée au système (Throughput),
- le nombre de fragments dans la fifo interne d’un canal (Mess count),
- le taux d’occupation d’un Processeur Execution.
Non représentés par les courbes de la figure 4.19-a, on peut également obtenir à partir de la
trace générée:
- le nombre de disques utilisés (NbDiskUsed),
- le taux d’occupation d’un disque.
L’outil d’analyse de trace sert également à visualiser des traces capturées en temps réel et
de visualiser un déroulement temporel (time line) de l’application utile pour une analyse
détaillée telle que par exemple la recherche de la cause du non respect d’une contrainte
temporelle. Un exemple de déroulement temporel obtenu par simulation d’un système
d’asservissement en vitesse et position d’un moteur à courant continu [HELLER-93] est donné
par la figure 4.19-b. Le diagramme temporel permet de visualiser l’état des fonctions et la trace
des événements et de mesurer les temps de réponse. Ainsi, il facilite la compréhension des
dépendances d’activation entre tâches et la recherche des éventuels problèmes
d’ordonnancement (non respect de contrainte de temps, interblocage, etc.).
Chapitre 4
128 M.C.S.E
-Figure 4.19- Aperçu de l’interface graphique de l’outil d’analyse de Trace.
-B- Solution spécifique
Avec l’utilisation d’un simulateur VHDL, les possibilités d’observation sont de 2 types:
- l’observation sous forme de chronogrammes: il s’agit de suivre l’état d’un signal du
type State. Quatre valeurs différentes sont possibles ce qui permet de suivre précisément
l’état d’un constituant actif: Inactive=X, Blocked=0, Waiting=Z, Active=1.
a) calcul et visualisation d’indices de performance
b) déroulement temporel
Transcription du modèle de performance en VHDL
M.C.S.E 129
- l’observation de données obtenues par une évaluation VHDL et mémorisées dans un
fichier. Des programmes (en Shell par exemple) permettent ensuite d’obtenir les
résultats selon la forme souhaitée et de les visualiser en exploitant par exemple le
logiciel GnuPlot.
Ces 2 possibilités ont été exploitées simultanément sur les deux exemples. La première
forme d’observation sert plus particulièrement pour la mise au point et la vérification fine du
bon comportement du modèle et nettement moins pour l’évaluation des indices de
performance.
-Figure 4.20- Exemple de chronogrammes.
4.9 EXEMPLE DE VALIDATION
L’exemple de validation considéré ici est le serveur vidéo simplifié dont le modèle de
performance a été présenté dans le chapitre 3. Nous présentons donc les résultats de
performance obtenus par transcription du modèle de performance en un modèle VHDL
comportemental, puis par simulation du programme VHDL obtenu. La taille du code source
MCSE est de 129 lignes et la taille du programme VHDL est de 651 lignes pour l’entité et 1108
lignes pour le package.
4.9.1 Résultats de simulation du modèle fonctionnel
La première simulation consiste à vérifier le bon déroulement temporel de l’application
sans considérer l’effet du processeur P. Aussi son degré de concurrence est supposé infini.
waiting
Preemption
Le chronogramme ci-dessus permet de voir pour l’exemple du serveur vidéo
l’effet de préemption du processeur: la fonction de lecture du canal 5 perd le processeur
au profit de celle du canal 4 et ne le récupère qu’après la fin d’activation de
la fonction lecture du canal 6. Le signal nbactivetasksprocessorexecution avant
dernier chronogramme réprésente le nombre de tâches actives sur le processeur
d’exécution et sert également pour calculer le taux d’occupation du processeur.
Chapitre 4
130 M.C.S.E
On se place dans le cas de 2 disques possédant un temps d’accès de 20 ms, de 10 usagers
lancés progressivement d’une manière aléatoire.
La figure 4.21 donne le résultat de simulation en montrant: le nombre de disques sollicités,
le nombre d’usagers et le débit global de transmission.
-Figure 4.21- Déroulement temporel pour la validation du modèle.
4.9.2 Simulation avec un modèle réaliste des disques
Le modèle est maintenant modifié pour être plus réaliste pour les disques. La variable
partagée est remplacée par un ensemble de ND fonctions Disque. Les demandes se font par des
ordres de lecture et d’écriture DemD[i]. Dans le cas de la lecture, le retour est fourni par
RepD[i]. Les demandes sont mémorisées dans les ports DemD[i]. Le comportement de chaque
disque est décrit par un modèle comportemental. Le temps de lecture ou d’écriture est défini
par le temps de positionnement sur la piste, le temps d’attente du bloc sous la tête, le temps de
lecture du bloc.
-Figure 4.22- Modélisation réaliste des disques.
0
5
10
15
20
25
0 10 20 30 40 50 60 70
"DisksConcurrency"
"TransmissionRate"
"WatchingUsers"
Temps (s)
Cmd
BlockIn
BlockOut[1:
OrderRec
ReadMovie
Supervision
TV set[1
Processor P
P‘Concurrency=M;
Explicit concurrency of ND;
Séquences
Disque[1:ND]
DemD[1:ND]
RepD[1:n]
User[1:n]
Source
TaccDisk = Tseek + Tlatency + Tread;
with
- Tseek = U(2,24) ms (U a random law),
- Tlatency = U (0,11) ms,
- Tread = 12,8 ms (read time)
Recording
OrderRead[1:n]
DemD[]
*
Write Read
DemD[]‘Op=write
Read‘Time = TaccDisk;
Write‘Time = TaccDisk;
Disque[]
DemD[]‘Op=read
RepD[]
OR
Transcription du modèle de performance en VHDL
M.C.S.E 131
Le modèle étant vérifié au niveau fonctionnel, on considère maintenant que les fonctions
ReadMovie sont implantées sur un processeur P de degré de parallélisme M. Pour le
dimensionnement de l’architecture, nous faissons une évaluation de M et de ND en fonction du
nombre simultané d’usagers ou du débit global. Pour cela, le degré M est incrémenté jusqu’à
ne plus détecter de rupture de séquence. Le nombre de disques est ici évalué d’une manière
statique par le débit global des disques qui doit être supérieur au débit de transmission.
La figure 4.23 donne le résultat du dimensionnement.
-Figure 4.23- Dimensionnement du processeur et des disques en fonction de la charge.
4.10 CONCLUSION
Les principes de transcription du modèle de performance en un programme VHDL
simulable présentés dans ce chapitre se sont inspirés:
- des concepts des exécutifs temps réels pour l’implantation des processeurs à degré de
ressource limité,
- du mécanisme de communication par jeton du modèle UVa pour la communication
entre éléments de relation et composants actifs,
- de l’implantation en VHDL des SpecCharts pour le parallélisme d’activité et
l’achèvement forcé d’activité.
Comme remarques concernant l’emploi de VHDL, on peut citer les points positifs et
négatifs suivants [CALVEZ-95a]:
- son intérêt pour représenter des modèle hiérarchiques et paramétrables,
- son intérêt certain pour la simulation d’un parallélisme,
- son intérêt pour les instanciations multiples statiques, et sa restriction gênante pour
notre modèle de performance concernant l’instanciation dynamique de blocks ou de
process, ce qui serait pratique pour l’instanciation d’activités,
- l’intérêt de la surcharge d’opérateurs et de procédures,
- la limitation sérieuse concernant l’absence de records variants,
- l’impossibilité de définir un package générique et un vecteur non contraint de vecteur
non contraint,
0
2
4
6
8
10
12
0 5 10 15 20 25 30 35 40 45 50
"NumberOfDisks"
"NumberOfProcessors"
Nombre d’usagers
Chapitre 4
132 M.C.S.E
- l’absence de possibilité de suspension et reprise d’un process avec gel du temps ce qui
aurait permis une modélisation aisée de la notion de ressource d’exécution avec degré
de concurrence limité.
Les constructions telles que l’attente conditionnelle, l’achèvement forcé d’activité et
certains cas de l’instanciation multiple ont posé des difficultés de transcription. Dans ces cas,
la complexité de la solution d’implantation en VHDL retenue se paie malheureusement au
niveau de la génération de code et de la lisibilité et l’efficacité du code VHDL produit.
Les principes de transcription ont d’abord été expérimentés sur l’exemple simplifié du
serveur vidéo puis ont été validés à l’aide de deux exemples qui sont présentés dans le chapitre
7. Ces deux exemples ont permis de constater la nécessité de ressources importantes pour la
simulation (puissance de calcul et mémoire) et une durée de simulation souvent trop longue
pour trouver rapidement la solution optimale recherchée.
Il est probablement possible de réduire le temps de simulation en générant un modèle ne
respectant pas la hiérarchie du modèle MCSE (moins de process et de signaux à gérer pour le
simulateur) et en utilisant deux signaux Req et Ack au lieu d’une fonction de résolution pour
le protocole de communication. Mais, le couple VHDL/Simulateur restera quand même moins
performant que la technique basée sur l’exécution d’un programme C++ dans un
environnement multi-tâches qui sur l’exemple du système de communication présenté dans le
chapitre 7 s’est révélée environ 4 fois plus rapide.
L’emploi de VHDL a cependant permis d’expérimenter rapidement le modèle de
performance sur des exemples alors que le simulateur C++ a demandé un temps de
développement et de mise au point relativement long.
Maintenant que les règles de transcription ont été décrites, nous devons nous charger de les
implanter dans un générateur automatique de code. La technique de génération de code retenue
fait l’objet des chapitres 5 et 6.

M.C.S.E 133
5
Le Méta-Générateur MetaGen
Après avoir défini les règles de transcription, il s’agit de les implanter dans un générateur
de code. Le rôle de ce générateur de code est de transcrire la description textuelle du modèle
de performance d’un système en un programme VHDL conformément aux règles de
transcription décrites dans le chapitre 4. La description textuelle d’entrée et celle de sortie du
générateur à développer sont conformes à une grammaire. Elles respectent une syntaxe et une
sémantique données.
Développer un outil pour effectuer cette transformation n’est pas une tâche facile. L’effort
est encore plus important quand la génération de code inclut également une phase de synthèse
logicielle ou matérielle. On se limitera dans ce document uniquement à la génération de code,
ce qui signifie que l’outil de génération à développer n’est pas capable de choisir une solution
d’implantation de lui-même. Si plusieurs alternatives possibles existent, la solution retenue
sera spécifiée dans le modèle source ou via l’interface utilisateur de l’outil. Pour cet objectif,
l’effort de développement est fortement dépendant de la syntaxe et la sémantique des langages
source et cible et de la complexité des règles de transformation.
Dans le passé, l’équipe MCSE a déjà développé trois types de générateurs de code pour le
modèle fonctionnel de MCSE: un générateur de C [CALVEZ-93c], un générateur d’OCCAM
[PASQUIER-93], un générateur de VHDL simulable [BAKOWSKI-92] et synthétisable
[HELLER-92] [CALVEZ-93d]. Ces générateurs de code écrits en C utilisaient des structures
internes spécifiques. Cette solution d’implantation qui dépendait également de
l’environnement graphique SunView ou XMOTIF pour l’interface utilisateur s’est vite révélée
pénalisante. Elle n’était pas portable. Elle ne facilitait pas la maintenance et la mise à jour des
générateurs en fonction des modifications de la grammaire de la spécification d’entrée ou de
celles des règles de transcription.
Afin d’obtenir des outils multi plate-formes et plus faciles à développer, maintenir et
enrichir, l’équipe MCSE s’est alors intéressée à la technologie méta-case et en particulier à
l’outil GraphTalk pour l’édition de graphes et l’outil LEdit pour la génération de code. Cette
Chapitre 5
134 M.C.S.E
approche a également été abandonnée. L’explication de cette abandon est donnée en début de
chapitre. Mais cette expérience et en particulier le travail effectué sur la génération de code
avec LEdit a amené l’équipe MCSE à revoir entièrement sa stratégie de développement des
outils dont les générateurs de code comme support pour la méthodologie MCSE. La
présentation de la nouvelle philosophie de développement de la plate-forme MCSE montre
qu’elle repose sur les concepts d’analyseurs syntaxiques et de méta-structure.
Ces deux concepts nous ont permis de développer un principe générique de génération de
code présenté dans ce chapitre et exploité pour implanter de nouveaux générateurs de code
ayant comme spécification d’entrée le modèle de performance de MCSE décrit dans le chapitre
3. Un analyseur syntaxique est obtenu à partir de la spécification de la grammaire du langage
concerné. Si la spécification de la grammaire est enrichie de règles de production, alors elle
peut engendrer la structure de données interne image du texte analysé. La structure interne
obtenue à partir d’un fichier texte est le coeur des générateurs. Pour que ceux-ci aient une
architecture commune, nous avons défini un modèle générique de modèle de structure de
données. Après avoir analysé la spécification d’une grammaire, nous présentons dans ce
chapitre ce modèle générique appelé par la suite méta-structure ainsi que l’architecture
commune des générateurs.
Le principe de génération de code qui est ensuite décrit repose également sur le concept de
template qui est un fichier contenant toutes les constructions en langage cible nécessaires à la
transcription. Pour un générateur donné, le fichier source et un fichier template sont analysés,
puis les opérations de manipulation des structures de données résultantes sont exécutées pour
réaliser la transcription. Pour avoir un générateur facilement reconfigurable, nous avons décidé
de décrire les opérations de manipulation de structures de données dans un langage interprété
nommé Script. La syntaxe et les constructions de ce langage dédié à la manipulation de
structure de données sont définies. Cette définition sert par la suite à l’interprétation de
l’implantation du générateur de code VHDL qui fait l’objet du chapitre 6.
Une fois saisi, le Script est interprété ou transcrit en code JAVA par un programme dont
l’implantation en Java est décrite à l’aide du modèle statique de la méthode OMT-UML. Ce
programme nommé MetaGen est donc un générateur de générateurs de code ou métagénérateur.
5.1 LA TECHNOLOGIE META-CASE
De 1993 à 1996, le développement de la plate-forme MCSE a reposé sur l’utilisation d’un
méta-outil orienté éditeur de graphes (GRAPHTALK) et d’un méta-outil orienté éditeur
syntaxique (LEdit). La mise en oeuvre d’un outil CASHE (Computer Aided Software
Hardware Engineering) pour une méthodologie à l’aide de la technologie méta-Case est
normalement réduite à la déclaration du formalisme de ses modèles. Les méta-outils
permettent, en effet, de se focaliser sur la méthode et la sémantique des modèles plutôt que sur
des aspects bas niveau tels que l’intégration d’outils, la gestion d’une base de données et
l’environnement graphique.
L’outil GraphTalk était séduisant pour au moins 4 raisons. Il est multi plate-formes (PC,
UNIX). Il est construit autour d’une base de données orientée objet. Les spécifications des
modèles sont saisies graphiquement et l’outil permet d’adopter une démarche incrémentale
facilitant le prototypage. La spécification graphique du méta-modèle fournit un bon support
pour la documentation et le suivi du développement de l’outil.
Le Méta-Générateur MetaGen
M.C.S.E 135
Malheureusement, l’utilisation de GraphTalk a révélé progressivement un certain nombre
de limitations:
- les concepts de méta-modélisation sont trop limités pour décrire complètement le
modèle MCSE et il fallait écrire de plus en plus de code C (API C) pour définir des
démons et actions sur les objets du méta-modèle. Au fur à mesure de l’implantation, on
perdait en efficacité (interprétation des démons) et en facilités de prototypage.
- la personnalisation de l’interface utilisateur est très limitée.
- il n’y a quasiment plus de maintenance et d’évolubilité des outils GraphTalk et LEdit
alors que ceux-ci sont pourtant fortement "buggés".
- l’utilisation nécessite de payer un "runtime" par machine.
L’utilisation des méta-outils GraphTalk/LEdit a conduit à une impasse. Pour compenser
leurs limites, l’équipe devait dépenser de plus en plus d’efforts alors que les résultats ne
pouvaient être que médiocres, non propriétaires et sans perspective d’évolution.
Cependant, l’expérience de génération de code avec LEdit qui est une encapsulation de
Lex&Yacc a permis d’appréhender les concepts des générateurs d’analyseurs syntaxiques et de
méta-structure sur lesquels repose entièrement la nouvelle "philosophie" de développement des
outils MCSE. Avec l’expérience de la technologie méta-Case, l’équipe a également pris
conscience que le succès du développement d’un outil CASHE repose essentiellement sur la
généricité et l’évolubilité de la structure des données internes aux outils. Début 1997, l’équipe
a donc réfléchi à une autre orientation.
5.2 NOUVELLE STRATEGIE DE DEVELOPPEMENT DES OUTILS
Il est usuel de constater que dans la plupart des outils CASHE actuels le couplage de
données entre outils est basé sur un échange par fichiers et non sur l’utilisation d’une base de
données pour des raisons d’efficacité et d’indépendance. Sur la base de ce constat, l’équipe a
donc décidé de développer une nouvelle plate-forme d’outils basée sur un couplage possible
entre outils par fichiers. Dans ce contexte, comme le montre la figure 5.1, chaque outil de la
plate-forme peut être implanté sous la forme d’une architecture générique basée sur trois
fonctions principales:
- la fonction Load qui permet de créer la structure de données à partir du fichier texte,
- la fonction Save qui est la réciproque de la fonction Load et qui consiste à parcourir la
structure de données et à exploiter la grammaire correspondante pour générer un fichier
texte,
- la fonction Transformations qui est spécifique à l’outil et qui définit les manipulations
effectuées sur la structure de donnée chargée.
-Figure 5.1- Architecture générique des outils de la plate-forme.
Texte en entrée
Outil
Texte résultat
Grammaire définissant la
syntaxe du texte en entrée
Structure de données interne Grammaire du langage cible
Transformations
Sauvegarde/ Restitution
sur disque
Load
Save
Chapitre 5
136 M.C.S.E
Cette approche nécessite de résoudre deux problèmes:
- La lecture d’un texte et sa conversion en une structure de données (Load) et l’opération
inverse (Save). Pour résoudre ce problème, nous sommes partis du principe que toute
structure de données peut être engendrée d’une manière automatique par un analyseur
syntaxique enrichi des règles de production de la structure de données. Cet analyseur
syntaxique est obtenu par un générateur d’analyseur syntaxique à partir de la
spécification de la grammaire (syntaxe d’entrée du texte source) et des règles de
production. Pour avoir un principe de création de la structure de données indépendant
de la grammaire, nous avons défini pour la spécification des règles de production un
modèle de modèle de structure de données ou méta-structure basé sur la composition de
trois constructions de noeuds: le record ou ensemble fini d’éléments, l’alternative et la
liste. Ce principe est présenté en détail dans le paragraphe 5.4. L’utilisation de cette
technique permet de répondre aux critères de généricité et d’évolubilité des structures
de données internes aux outils considérés indispensables pour le succès du
développement de la plate-forme d’outils. Pour faire évoluer la structure de données, il
suffit en effet de modifier la grammaire et de regénérer l’analyseur syntaxique associé.
La fonction Save qui correspond à un parcours ordonné de la structure de données
interne et à l’exploitation de la grammaire pour le formatage du texte de sortie ne pose
pas de difficultés particulières d’implantation.
- la sauvegarde et restitution d’une structure de données sur disque sans contrainte de
format, ce qui se résoud bien avec le concept d’objets persistants. Ce problème est
résolu implicitement par le choix d’implantation des outils en Java qui dispose en
standard (JDK 1.1) de la sérialisation/désérialisation d’objets.
5.3 ANALYSE D’UNE GRAMMAIRE
Le fichier d’entrée d’un outil respecte une syntaxe donnée. La syntaxe acceptée se décrit
par une grammaire. Une grammaire se décrit elle-même selon une grammaire qui est alors
appelée méta-grammaire. Un analyseur syntaxique est une fonction chargée de vérifier qu’un
texte donné en entrée respecte une grammaire donnée. Si l’analyseur syntaxique est enrichi par
des règles de production ou actions, il est alors à même de produire directement quelque chose
en sortie. Nous sommes ici intéressés par la production de la structure de données interne
équivalente au texte analysé et la fonction inverse pour la production de texte de manière à
disposer d’une fonction bi-univoque texte <-> structure de données.
5.3.1 Définition d’une grammaire
Une grammaire est un ensemble fini de règles de la forme "coté gauche ::= coté droit" où
le coté gauche représente un symbole non terminal et le coté droit est un ensemble
éventuellement vide de symboles non terminaux et terminaux. Les symboles terminaux
représentent les mots clés et les expressions régulières (identificateurs, nombre, etc).
Pour la compréhension de la technique employée par un générateur d’analyseur syntaxique,
nous commençons par présenter quelques règles de grammaire pour un exemple très simple.
Le texte suivant constitue un ensemble de règles de grammaire écrites selon la norme BNF
(Backus Naur Form).
Le Méta-Générateur MetaGen
M.C.S.E 137
ComponentDescription ::= <Component> [Range] Name [GenericParameters]
Parameters ";" [Attributes] ComponentDef <EndComponent>
Range ::= "[" Indice ":" Indice "]"
GenericParameters ::= Generic Name {"," Name }
Parameters ::= "(" {Parameter";"} ")"
ComponentDef ::= StructureDef | BehaviorDef
La signification de la notation pour interpréter les règles est la suivante:
- <Component> et "(" sont des symboles terminaux (directement présents dans le texte).
Les autres noms (GenericParameters, Parameters, etc.) sont appelés symboles nonterminaux
et doivent être définis par des règles de grammaire.
- ::= définit une règle de grammaire. La partie gauche est régie selon la description à
droite.
- Y ::= A B C veut dire que le texte doit comporter A puis B puis C.
- Y ::= A | B | C veut dire que le texte comprend A ou B ou C (Ou exclusif)
- Y ::= [ A ] veut dire que A est optionnel.
- Y ::= { A } veut dire qu’il s’agit d’une suite de longueur quelconque de A, la suite
pouvant être vide.
5.3.2 Structure de données pour une grammaire
La figure suivante montre les règles de grammaire ci-dessus, mais cette fois représentées
sous une forme graphique. La notation graphique est celle recommandée par la méthodologie
MCSE pour la structuration des données [CALVEZ-90].
-Figure 5.2- Structure de données pour une grammaire.
ComponentDescription
Range
Name
";"
"<Component>" "<EndComponent>"
":"
Parameter
"["l
Indice Indice
"]"
"Generic"
"(" ")"
Parameters
ListeParam
ListeName
Name
0:1 0:1
0:n
0:n
","
Name
GenericParameters
ComponentDef
1:1
StructureDef BehaviorDef
0:1
Attributes
";"
Chapitre 5
138 M.C.S.E
La notation graphique utilise ici 3 types de symboles:
- Lerectangle qui contient un identificateur ou une valeur (symbole terminal),
- Unrond qui signifie le produit cartésien et qui veut aussi dire la composition de tous les
champs qui en partent. C’est l’équivalent d’un record. Un champ peut être un mot clé,
une valeur ou identificateur, la désignation d’un autre noeud de la structure.
- Un demi-rond pour l’ensemble qui signifie le regroupement d’une collection
d’éléments. Un ensemble peut être vide ou non, peut aussi être borné. Dans ce dernier
cas, les 2 nombres dans le symbole indiquent la borne minimale et la borne maximale.
Sur la base de cette notation, la structure de données devient plus lisible. La première règle
de grammaire textuelle de l’exemple se traduit par le rond ComponentDescription. Comme
Range est optionnel, on utilise le symbole ensemble (0:1) pour représenter l’alternative: Range
ou absence de Range. On retrouve la même notation pour les paramètres génériques. La
notation 0:n pour ListeName et ListeParam indique une suite vide ou de longueur quelconque.
La notation 1:1 représente l’alternative des cas possibles. Une seule doit exister. C’est le cas
pour ComponentDef.
A noter que dans le cas d’une récursivité, la structure de données est arrêtée dès la rencontre
d’un symbole non-terminal déjà défini au préalable.
On peut conclure que tout texte respectant une grammaire peut se décrire sous la forme
d’une structure de données construite sur la base des 2 opérateurs: composition et ensemble.
5.3.3 Structure de données pour une solution
Considérons maintenant un texte respectant les règles de grammaire ci-dessus. Un exemple
est donné ci-après.
<Component> [1:k] F1 Generic n, k ( E; S;)
<Structure>
.........
<EndComponent>
Intéressons-nous à sa représentation possible sous la forme d’une structure de données en
exploitant la même notation que précédemment.
La structure de données de l’exemple représentée par la figure suivante montre la
disparition des ensembles 0:1, 1:1. Ceci s’explique par le fait que l’alternative représentée par
l’ensemble 0:1 se trouve maintenant spécifié pour un texte donné. On trouve par exemple ici
Range avec sa définition. En l’absence de Range, le lien pointe sur Nil (qui veut dire vide). Pour
un ensemble 1:1, on trouve le noeud correspondant au cas représenté dans le texte (ici
StructureDef).
Les noeuds de composition se retrouvent intégralement dans la solution. Dans le cas d’une
récursivité, la structure de données est prolongée. En effet, si un composant contient un autre
composant, on doit retrouver la structure de données de cet autre composant (différence
Le Méta-Générateur MetaGen
M.C.S.E 139
essentielle par rapport à la structure de données de la grammaire). Le cas est représenté par la
figure 5.3 pour le noeud StructureDef qui inclut des composants définis par le noeud
ComponentDescription.
-Figure 5.3- Structure de données pour une solution.
5.4 SPECIFICATION D’UNE META-STRUCTURE
La présentation faite dans le paragraphe précédent permet maintenant de définir une
méthode générale de construction d’un chargeur (loader) assurant la transformation d’un texte
sous la forme d’une structure de données. Le texte à analyser est défini par un ensemble de
règles de grammaire. A ces règles se trouvent associées des règles de production induisant la
construction de la structure de données du texte analysé. Dans ce paragraphe nous montrons
que les règles de grammaire peuvent se représenter sur la base d’une méta-structure appelée ici
MetaDs. La MetaDs sert alors à la construction de la représentation interne de la grammaire
appelée ici GrammarDs. La GrammarDs est utilisée par un analyseur syntaxique aussi appelé
parser pour analyser et construire la structure de données de chaque solution appelée ici XDs.
La XDs est basée sur un modèle de noeud générique appelé ici DsModel. Ceci est expliqué
dans le paragraphe suivant.
Il s’agit donc de tirer des règles générales de transformations texte <-> structure à partir de
l’exemple de présentation du paragraphe précédent.
La figure 5.4 indique sous la forme de tableau le résultat de synthèse. La première colonne
indique les 5 cas de règles de grammaire selon la notation BNF. Les autres cas s’en déduisent
par composition ou association. Y est un symbole non-terminal. A, B et C sont des symboles
terminaux ou non-terminaux.
La deuxième colonne montre la représentation graphique équivalente sous la forme de la
notation des structures de données. On retrouve le noeud de composition et 4 types
d’ensembles, chacun défini par des bornes différentes.
ComponentDescription
Range
F1
";"
"<Component>" "<EndComponent>"
":"
Parameter
"["l
Indice Indice
"]"
"Generic"
"(" ")"
Parameters
ListeParam
ListeName
k
","
n
0:n
0:n
StructureDef
........
"<Structure>"
ComponentDescription
Chapitre 5
140 M.C.S.E
La troisième colonne donne une implémentation appropriée pour chaque type de noeud.
Ainsi une grammaire peut se représenter en interne sur la base de records. Le premier champ
indique le type. Le deuxième champ indique le nombre de symboles qui suivent, sauf s’il un
seul existe.
-Figure 5.4- Correspondances entre les règles BNF et les modèles de structure de données.
Les trois premières colonnes du tableau définissent ainsi la méta-grammaire et la métastructure
pour spécifier toute grammaire et la construction de structure équivalente. La
transformation des règles textuelles d’une grammaire donne une structure de données appelée
GrammarDs conforme à la notation MetaDs construite sur la base des règles qui viennent d’être
définies.
Intéressons-nous maintenant à la structure de données qui doit être construite par la
fonction Loader lors de la reconnaissance d’un texte. La quatrième colonne représente la
notation de la structure de données pour une solution tandis que la cinquième colonne montre
une solution pour l’implémentation.
Pour un noeud de composition, la notation est identique à celle de la grammaire, mais
l’implantation diffère. Pour des raisons d’optimisation de la structure, seuls les champs nonterminaux
sont placés dans le record (pour l’exemple, A est considéré ici comme symbole
terminal). En effet, comme les champs terminaux sont constants, il ne sert donc à rien de les
dupliquer dans ce record car leur existence et valeur sont définies dans la GrammarDs. Ainsi,
l’interprétation de la structure de données pour tout texte se fera à l’aide de la GrammarDs.
Pour cette raison, on ne trouve dans un noeud de composition que des références vers d’autres
noeuds.
Lors d’une alternative Set1:1, on trouve la notation alternative. Pour une solution donnée,
l’alternative disparaît car l’élément concerné est fixé dans le texte. Le cas est alors défini par
le type de record (ici A ou B ou C...). Ainsi l’ensemble disparaît dans la structure XDs. Si la
Règles BNF notation MetaDs MetaDs
A
B C
A C
B
Y
1:1
Y
Y ::= A B C...
Record
n
AB
Y ::= A | B | C...
Set11
n
AB
A
0:1
Y ::= [A] Y Set01
A
Y
Y
Y
A
1:n
Y ::= A {A} Y Set1n
A
Y
A
0:n
Y ::= {A} Y Set0n
A
Y
XDs
Record Y
mB
C
A ou B ou C
Record A
Nil
A A
A A
Nil
ou
Modèle Ds
Type
NextFriend
Father
FieldNb
Reserved
B
NodeDs
Nil
Node
Value
ID dans
ID
Node
Key
HashTable
Le Méta-Générateur MetaGen
M.C.S.E 141
structure doit pouvoir se modifier par un éditeur syntaxique par exemple, les alternatives
possibles sont connues par l’analyse du noeud de la GrammarDs qui indique les possibilités par
le Set 1:1.
Pour l’alternative Set 0:1, on trouve les 2 possibilités: absence ou symbole A.
L’implantation est immédiate. Une référence Nil indique la non-existence de l’option. Dans le
cas contraire on y trouve la référence du noeud.
Les ensembles Set 1:n et Set 0:n se retrouvent dans la structure. Elles sont implantables
comme une liste chaînée des noeuds composant cet ensemble. Si l’ensemble est vide, alors la
référence est Nil.
Il ressort de cette analyse que toute structure XDs peut se construire sur la base d’un modèle
de noeud appelé ici NodeDs. Le modèle est représenté dans la dernière colonne. Chaque noeud
est identifiable par son type qui est le même que le noeud équivalent dans la GrammarDs. On
trouve ensuite les champs:
- NextFriend pour permettre son inclusion dans une liste et donc dans un ensemble,
- Father pour être capable de remonter la structure,
- Reserved pour des utilisations ultérieures,
- FieldNb qui définit le nombre de références qui suivent. Ces références désignent
obligatoirement des noeuds non-terminaux. Elles sont définies dans le noeud du même
type de la GrammarDs.
- Chaque référence désigne 4 cas possibles: vide, un autre noeud, une valeur, un
identificateur.
Une valeur peut être un booléen, un entier ou un flottant. Un identificateur est une chaîne
de caractères. Si un accès par le nom est souhaité, une hashtable pour la mémorisation des
identificateurs peut être appropriée. Mais il faut faire très attention à la portée des
identificateurs. Ce point essentiel conduit à un ensemble de hashtables et pas uniquement une
seule.
En conclusion, tout texte source conforme à un langage X est représenté par une structure
de données XDs dont la signification est fournie par une structure de donnée XGrammarDs qui
est la transcription des règles de grammaire textuelles de X.
5.5 GENERATION DU LOADER
L’objectif est de disposer d’un programme Loader capable de transformer tout texte MCSE
conforme aux règles de grammaire du modèle MCSE en une structure de données McseDs et
un ensemble de tables des identificateurs. Une qualité essentielle du loader est son aptitude à
pouvoir s’adapter à toute modification de la grammaire. Cette technique doit donc aussi
pouvoir s’employer pour toutes autres grammaires telles que C et VHDL par exemple.
Le loader souhaité est en fait un parser (analyseur syntaxique). Le terme parser inclut ici
tout d’abord un analyseur lexical pour identifier les tokens successifs et les présenter à
l’analyseur syntaxique. La figure 5.5 explique la technique dite du "bootstrapping" que nous
avons utilisée pour engendrer le parser souhaité.
Le loader est en fait réalisé par un programme dénommé MCSE-Parser. Il exploite en entrée
tout texte MCSE pour l’analyser avec l’aide de la structure MCSEGrammarDS et de la table
des symboles associée de la grammaire du modèle MCSE. La MCSEGrammarDs et la table
Chapitre 5
142 M.C.S.E
des symboles sont des classes d’objets fixes (statiques) pour une grammaire donnée intégrées
au programme MCSE-Parser lors de sa compilation pour disposer d’une version exécutable.
Cette compilation ne doit se faire que lors d’une modification de grammaire.
Il faut bien comprendre que le programme MCSE-Parser contient, en plus des tables de
reconnaissance du texte, les procédures ou méthodes appropriées de production des noeuds de
la structure de données McseDs. La question intéressante est: comment engendrer
automatiquement ce programme?
La figure suivante fournit la réponse.
-Figure 5.5- Technique du "bootstrapping" pour la génération du loader.
Pour générer la MCSEGrammarDs et la table des symboles correspondante, mais aussi le
programme source MCSE-Parser, il faut disposer d’un autre programme. Un parser peut à
nouveau effectuer cette production à condition qu’il sache produire du code source. Un tel
parser est ici appelé Grammar-Parser puisqu’il exploite pour cela en entrée la grammaire du
modèle MCSE. Le lien en gras représente la production d’un code source.
Le programme Grammar-Parser doit disposer en entrée:
- de la grammaire du modèle MCSE qui est le texte parsé,
- intégrées à cette grammaire, les règles de production de la MCSEGrammarDs, de la
table des symboles de la grammaire et du code source de MCSE-Parser. Ces règles sont
directement écrites dans le langage du programme, c’est-à-dire ici en JAVA.
- de la MetaDs et de la table des symboles de la méta-grammaire, indispensable pour
l’interprétation de la grammaire et la production de la GrammarDs.
On peut à nouveau continuer le raisonnement en se demandant comment obtenir
automatiquement le programme Grammar-Parser. La réponse est maintenant clair. Il suffit
d’utiliser à nouveau un parser appelé maintenant Meta-Parser.
Le méta-Parser exploite en entrée la méta-grammaire à laquelle se trouvent associées les
règles de production du code source de Grammar-Parser, de la MetaDs, de la table des
symboles de la méta-grammaire.
Pour résumer ou pour avoir une autre vision de cette technique, le méta-parser produit des
classes d’objets appelées MetaDs et Grammar-Parser. L’exécution de l’objet Grammar-Parser
produit des instances des classes d’objets MetaDs pour représenter la grammaire ce qui donne
Meta-Parser
Méta-grammaire
MetaDs
Grammar-Parser
+règles de
production de la MetaDs
et de la table des
méta-symboles
Table des
symboles
Grammaire modèle MCSE
+règles de
production de la GrammarDs
et de la table des
symboles
MCSEGrammarDs
MCSE-Parser
Table des
symboles
Texte MCSE
McseDs
Tables des
Identificateurs
Loader
Le Méta-Générateur MetaGen
M.C.S.E 143
les classes MCSEGrammarDs et MCSE-Parser. L’exécution de l’objet MCSE-Parser produit
des instances des objets de la classe MCSEGrammarDs pour représenter une solution de
description.
L’intérêt essentiel de cette technique est son évolutivité. Un changement souhaité de la
structure interne McseDs se traduit par une modification de la grammaire du modèle MCSE ou
par une modification de la MCSEGrammarDs ou par une modification des règles de
production. Un nouveau loader est engendré par exploitation de Grammar-Parser.
Ce résultat a été obtenu grâce à l’utilisation d’un classe java disponible sur le web réalisant
la fonction de Meta-Parser [HUDSON-96].
5.6 STRUCTURE INTERNE GENERIQUE DE CHAQUE OUTIL
La technique de chargement du modèle MCSE étant maîtrisée, il s’agit de compléter
l’organisation autour de la structure de données McseDs nécessaire pour chaque outil.
Il est clair maintenant que la structure de données interne est l’équivalent du texte source
McseModel. Le texte est indispensable car il peut se lire et se mémoriser sous la forme de
fichier. La structure de données en interne est aussi indispensable car c’est la seule forme
exploitable efficacement par des programmes.
Disposant de la fonction Load, il faut aussi la fonction inverse appelée Save. De plus pour
pouvoir modifier la structure interne, l’enrichir par exemple, il faut ajouter une fonction Edit.
-Figure 5.6- Structure interne générique de chaque outil.
La fonction Save est simplement un programme de parcours de la structure interne assurant
sa transcription sous forme textuelle et son formatage par indentation et contrôle des retours de
ligne. La signification de la structure McseDs se trouve par exploitation de la structure
MCSEGrammarDs qui représente la grammaire. MCSEGrammarDs contient donc aussi les
règles de formatage. La table des symboles est aussi indispensable pour l’écriture textuelle des
symboles terminaux.
McseModel
McseDs
McseModel
MCSEGrammarDs + Table des symboles Affichage Selection
Load
Save
Edit
Chapitre 5
144 M.C.S.E
La fonction Edit peut avoir un rôle varié. Un premier rôle est la modification de la structure
par une édition textuelle assistée par la syntaxe. Un deuxième rôle est la modification de la
structure par une édition graphique assistée. Un autre catégorie de rôle est la transformation
automatique ou assistée de la structure. Ce type de rôle permet d’entrevoir des possibilités
intéressantes par exemple pour la réalisation de générateurs de solutions et de code.
5.7 PRINCIPE DE GENERATION DE CODE
Le principe de génération de code retenu est d’exploiter la structure de données
équivalente d’un fichier template (ou fichier modèle) écrit dans le langage cible noté ici X. Le
contenu de ce fichier template va comprendre toutes les constructions qui vont se retrouvées
dans le programme cible. Chaque construction sera définie sous sa forme la plus complète et
uniquement une fois. Un tel template permet alors de disposer en interne de la structure
XGrammarDs, la table des symboles et la structure de données XTemplateDs pour toute
production d’une structure représentative du code de sortie.
Ainsi, la production d’un programme ou d’un texte selon un langage cible nécessite de
disposer de sa grammaire. Connaissant la grammaire, on peut alors disposer d’un analyseur
syntaxique capable d’analyser un texte modèle et de produire la structure de données interne
équivalente. Pour la compréhension de la méthode utilisée, nous commençons par une analyse
des textes source et résultat voulu pour en déduire ce que doit être un template.
5.7.1 Analyse des textes source et résultat
Pour comprendre le principe de génération basé sur l’emploi d’un template, considérons
tout d’abord une très petite partie d’un exemple de modèle MCSE et du programme VHDL
correspondant.
-A- Description du modèle MCSE
Ce modèle contient la description d’un système décrit sous la forme d’une structure qui elle
même contient 2 ports et une fonction. Le port Cmd est un vecteur. La fonction Emission est
multiple. Sa description est décrite par un comportement.
-Figure 5.7- Exemple de modèle MCSE partiel.
<Component> Serveur Generic n, k ( In Mess E: DefE; Out Var S: DefS;)
<Structure> Modele1;
<Port> [1:k] Cmd : DefCmd;
<Port> Rep: DefRep;
<Component> [1:n] Emission
(Out Mess Cmd[] : DefCmd;);
<Attributes>
Cmd[]‘Id = me‘Index;
Cmd[]‘Size = 5;
Tprod‘Time = 0;
<Behavior> Modele2;
Emission::{Tprod&!Cmd[]}*;
<EndBehavior>
<EndComponent>
<EndStructure>
<EndComponent>
Emission[1:n]
Cmd[]
* ‘Id=me‘Index;
‘Size=5;
Tprod‘Time=0;
Tprod
Emission
Cmd[1:k]
Rep
Modèle1
a) Représentation textuelle b) Représentation graphique
Le Méta-Générateur MetaGen
M.C.S.E 145
-B- Résultat VHDL souhaité
Compte tenu du chapitre 4, la traduction souhaitée pour avoir un modèle VHDL noninterprété
est la suivante.
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.all;
LIBRARY STANDARD;
USE STANDARD.TEXTIO.all;
LIBRARY ServeurLibrary;
USE ServeurLibrary.ServeurDeclaration.all;
ENTITY Serveur IS
GENERIC ( n : INTEGER := 1;
k : INTEGER := 1);
PORT ( SIGNAL E: IN DefE;
SIGNAL S: OUT DefS;);
END Serveur;
ARCHITECTURE behavioral OF Serveur IS
FOR all : PortObject
USE ENTITY Library.PortObject (behavioral);
..............................
SIGNAL CmdInputAccesses : DefPortInVector(1 TO n);
ALIAS EmissionCmd : DefPortInVector(1 TO n) IS CmdInputAccesses(1 TO n);
SIGNAL CmdNumberOfCurrentAccesses : DefNaturalVector(1 TO n);
SIGNAL CmdNumberOfMessagesInPort : DefNaturalVector(1 TO n);
BEGIN
-- Instanciation des ports Cmd[1:k] et Rep
MultipleCmd :
FOR i IN 1 TO k GENERATE
Cmd :
COMPONENT PortObject
GENERIC MAP (NbUsersInput =>1,
NbUsersOutput =>1,
policy =>Fifo,
concurrency =>1,
capacity =>1,
WriteTime =>NullTime,
ReadTime =>NullTime)
PORT MAP (InputAccesses (1) =>CmdInputAccesses (i),
OutputAccesses (1) =>CmdOutputAccesses (i),
NumberOfCurrentAccesses =>CmdNumberOfCurrentAccesses (i),
NumberOfMessagesInPort =>CmdNumberOfMessagesInPort (i));
END GENERATE MultipleCmd;
Rep :
COMPONENT PortObject
GENERIC MAP (NbUsersInput =>1,
NbUsersOutput =>1,
policy =>Fifo,
concurrency =>1,
capacity =>1,
WriteTime =>NullTime,
ReadTime =>NullTime)
PORT MAP (InputAccesses (1) =>RepInputAccesses (1),
OutputAccesses (1) =>RepOutputAccesses (1),
NumberOfCurrentAccesses =>RepNumberOfCurrentAccesses (1),
NumberOfMessagesInPort =>RepNumberOfMessagesInPort (1));
-- Instanciation des fonctions
MultipleEmission :
BLOCK
PORT (Cmd : OUT DefPortInVector(1 TO n));
PORT MAP (Cmd => EmissionCmd);
BEGIN
MultipleInstantiationEmission :
Chapitre 5
146 M.C.S.E
FOR i IN 1 TO n GENERATE
Emission :
BLOCK
PORT (Cmd : OUT DefPortIn);
PORT MAP (Cmd => Cmd (i));
CONSTANT me : INTEGER := i;
BEGIN
EmissionBehavior : PROCESS
CONSTANT TprodTime : TIME := 0;
VARIABLE InfoCmd : DefTprod;
BEGIN
LOOP
Delay (TprodTime);
InfoCmd.Id := me;
InfoCmd.Size := 5;
Send (Cmd, InfoCmd, NullTime, 0, now);
END LOOP;
END PROCESS EmissionBehavior;
END BLOCK Emission;
END GENERATE MultipleInstantiationEmission;
END BLOCK Serveur;
END behavioral;
Le programme commence par des déclarations fixes. On trouve ensuite la librairie utilisée
puis la déclaration de l’entité. La partie Architecture contient la déclaration de signaux et alias
nécessaires pour les ports. On trouve ensuite l’instanciation de composants PortObject pour les
ports Cmd et Rep. Le port multiple Cmd exploite l’instruction VHDL Generate.
On trouve pour finir l’instanciation de la fonction multiple Emission. Celle-ci est décrite
comme un block avec ses entrées et sorties. L’instanciation multiple s’obtient aussi par
l’instruction Generate. Le corps de la fonction possède un comportement séquentiel. Un
process est utilisé à cet effet. On trouve dans ce process les instructions représentant le
comportement.
Pour cette description, nous avons mis en gras les mots qui sont spécifiques de l’exemple.
On peut de cette manière comprendre aisément l’idée du template. Ainsi, si on considère la
transcription du port Cmd[1:k], il faut produire toutes les lignes comprises entre
"MultipleCmd" et "END GENERATE MultipleCmd;". Il faut au préalable ajouter 3 signaux
et un alias. Il en est de même pour l’instanciation d’une fonction décrite par un comportement.
Toute la structure entre "MultipleEmission" et "END GENERATE
MultipleInstantiationEmission;" doit être reproduite pour chaque fonction. L’adaptation porte
alors sur certains champs: uniquement le nom Cmd pour le port.
5.7.2 Le concept de fichier Template
La description suivante correspond au template possible pour produire le programme
précédent. Les lettres en gras sont X pour une chaîne de caractères, un N pour un nombre. Dans
ce template certains champs alternatifs (par exemple IN, OUT ou INOUT) sont aussi indéfinis.
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.all;
LIBRARY STANDARD;
USE STANDARD.TEXTIO.all;
LIBRARY XLibrary;
USE XLibrary.XDeclaration.all;
ENTITY X IS
GENERIC (X : INTEGER := N;);
Le Méta-Générateur MetaGen
M.C.S.E 147
PORT (SIGNAL X: X X;); /*Choix entre IN, OUT, INOUT*/
END X;
ARCHITECTURE behavioral OF X IS
FOR all : PortObject
USE ENTITY Library.PortObject (behavioral);
..............................
SIGNAL XInputAccesses : DefPortInVector(1 TO N);
ALIAS X : DefPortInVector(1 TO N) IS XInputAccesses(1 TO N);
SIGNAL XNumberOfCurrentAccesses : DefNaturalVector(1 TO N);
SIGNAL XNumberOfMessagesInPort : DefNaturalVector(1 TO N);
BEGIN
-- Instanciation d’un port
MultipleX :
FOR i IN 1 TO N GENERATE
X :
COMPONENT PortObject
GENERIC MAP (NbUsersInput =>1,
NbUsersOutput =>1,
policy =>Fifo,
concurrency =>1,
capacity =>1,
WriteTime =>NullTime,
ReadTime =>NullTime)
PORT MAP (InputAccesses (1) => XInputAccesses (i),
OutputAccesses (1) => XOutputAccesses (i),
NumberOfCurrentAccesses => XNumberOfCurrentAccesses (i),
NumberOfMessagesInPort => XNumberOfMessagesInPort (i));
END GENERATE MultipleX;
-- Instanciation d’une fonction
MultipleX :
BLOCK
PORT (X : X DefPortInVector(1 TO N)); /* X vaut IN, OUT, INOUT*/
PORT MAP (X => X);
BEGIN
MultipleInstantiationX :
FOR i IN 1 TO N GENERATE
X :
BLOCK
PORT (X : X DefPortIn);
PORT MAP (X => X (i));
CONSTANT me : INTEGER := i;
BEGIN
XBehavior : PROCESS
CONSTANT XTime : TIME := N;
VARIABLE InfoX: X;
BEGIN
LOOP
Delay (XTime);
InfoX.X := X;
Send (X, InfoX, NullTime, 0, now);
END LOOP;
END PROCESS XBehavior;
END BLOCK X;
END GENERATE MultipleInstantiationX;
END BLOCK X;
END behavioral;
Ce template n’est bien sûr pas exhaustif pour la génération d’un programme VHDL noninterprété
complet. Il est ici simplement considéré suffisant pour l’exemple. Il ne sert donc qu’à
illustrer la méthode utilisée.
Chapitre 5
148 M.C.S.E
Il est aisé de comprendre que, par exemple, la création de chaque port ou chaque fonction
va nécessiter la copie des lignes de VHDL du template pour chaque élément. Il faut ensuite
assurer la mise à jour, par exemple modifier le nom X en Cmd. Un port simple ou une fonction
simple se déduit d’un élément multiple par simplification. Ceci est mis en évidence dans le
paragraphe suivant.
Pour faciliter la production, un template doit contenir la description la plus complexe. Toute
copie du modèle est alors ajustée par changement de valeurs et par élimination des parties nonutiles.
5.7.3 Analyse des structures de données
Pour comprendre la technique de génération, la figure suivante représente (partiellement)
la structure de données du modèle MCSE de l’exemple ci-dessus et la structure de données du
template VHDL.
-Figure 5.8- Structure de données pour le modèle MCSE et le template VHDL.
Serveur
<Component>
StructureDef
ComponentDescription
<EndComponent>
<Structure>
BehaviorDef
<Behavior>
Emission
"::"
BehaviorDefinition
BehaviorInstance
1:n
Interface
Modele1
Attributes
StructureDescription
1:n
<EndStructure>
Relation
";"
<EndBehavior>
Modele2
";"
ActivityDef
";"
Attributes
(Nil) Range
ComponentInstance
Attributes
MCSEModelDescription
(Nil)
Emission
<Component> ComponentDescription
<EndComponent>
Interface
Attributes
([1:n]) Range
(’Id, ‘Size, ‘Time)
(Out Mess Cmd[]:...;)
<Port>
<EndRelation>
1:n
TypedRelationDef
":"
DefCmd
*NameList
([1:k])Range Attributes
";"
RelationDescription
Cmd
(Nil)
(Nil)
<Port> Rep
";"
InputOutput
n
0:n
"Generic"
","
k
0:n
"(" ")"
GenericParameters InputOuputs
NextList
NextName
Declarations
Relations
BlockDef
VHDLProgram
Behavior
*BlockDef
1:1
ForGenerate
Block
EndGenerate
Architec.
Multiple
Block
"Block"
Block
EndBlock
Block
"Process"
Statements
EndProcess
Process
If
Case
Send
Stat
StatementPart
0:n
Process
0:n
Declarations
Entity
Architecture
"Architecture"
EntityDeclaration
End Architecture
RelationDescription
0:n
Declarations
Le Méta-Générateur MetaGen
M.C.S.E 149
La démarche de génération peut être la suivante:
1- Copie de la structure complète du template comme structure du programme de sortie.
2- Mise à jour du champ Declarations en remplaçant X par Serveur.
3- Mise à jour du champ EntityDeclaration en utilisant le nom Serveur puis en créant les
paramètres génériques et entrées/sorties par exploitation de la structure Interface de
MCSE.
4- L’architecture est ensuite mise à jour par le nom du modèle (Modele1) et le nom du
composant Serveur.
5- Il s’agit ensuite de créer autant de relations que dans le modèle MCSE avec mise à jour
des noms X pour les signaux et alias de chaque relation. Si une relation n’est pas
multiple, il faut supprimer la structure Generate, ce qui se fait simplement par
élimination du noeud MultipleBlock (idem à la déclaration des composants).
6- La définition de blockDef est ensuite mise à jour pour l’instanciation de n blocs
Emission. Il s’agit de modifier la valeur n, le nom du block, de créer ses entrées et sorties
conformément à la déclaration de l’interface de Emission dans le modèle MCSE. Si le
composant n’est pas multiple, il suffit de détruire le noeud MultipleBlock (lien en
pointillé sur la figure).
7- Il faut ensuite assurer la mise à jour de la partie comportementale (Behavior). Le process
est mis à jour compte-tenu de la déclaration du comportement par ActivityDef. Si
plusieurs process sont nécessaires, chacun est créé à l’image du process dans le
template.
8- il suffit ensuite de transcrire la structure sous forme textuelle pour avoir le programme
résultat souhaité.
Ainsi l’explication précédente montre que dans le cas de cet exemple, la structure du
résultat s’obtient par une seule copie de la structure complète du template, puis par sa mise à
jour. La mise à jour inclut la destruction des champs inutiles car le template est une version
complète, la modification de noms et valeurs de champs, l’ajout d’éléments supplémentaires
dans les ensembles par copie du modèle dans le template.
5.8 STRUCTURE ET FONCTIONNEMENT D’UN GENERATEUR
Dans ce paragraphe nous expliquons la structure d’un générateur et son principe de
fonctionnement.
5.8.1 Structure du générateur
Un générateur basé sur le principe expliqué dans les paragraphes précédents exploite en
entrée les 2 structures McseDs et XTemplateDs. Le résultat en sortie est la structure OutputDs.
Les 2 structures en entrée sont obtenues par l’analyseur syntaxique Loader paramétré par la
grammaire du texte. Chacune des structures possède une référence sur sa grammaire
(GrammarDs) en incluant la table des symboles pour permettre son interprétation. La structure
de sortie nécessite aussi de se référer à une grammaire, ici celle de XtemplateDs. La sortie
textuelle se fait avec la fonction Save qui exploite alors cette structure de données et la
grammaire pour le formatage.
Chapitre 5
150 M.C.S.E
La figure 5.9 montre l’organisation d’un générateur.
-Figure 5.9- Structure interne d’un générateur.
Un générateur pour un programme ou texte donné en sortie peut se concevoir comme un
programme écrit en C, C++ ou Java assurant les opérations nécessaires sur les structures de
données et selon l’ordre approprié. Cette solution conduit à devoir développer autant de
générateurs que de résultats différents en sortie. On peut aisément imaginer que les générateurs
devraient posséder des opérations en commun par suite de similitudes. Ne peut-on pas alors
pousser plus loin le raisonnement en cherchant une solution d’un seul générateur
programmable de l’extérieur. On arrive alors à l’idée d’un script définissant le comportement
souhaité. Nous avons retenu cette idée car elle devrait permettre à toute autre personne de
développer un générateur spécifique sans avoir à connaître et à intervenir dans le code du
générateur. Pour cela, il suffit que toutes les opérations nécessaires soient possibles par le
script.
5.8.2 Fonctionnement du générateur
La génération est le résultat de l’exécution d’un programme se conformant à un script de
génération. Plutôt que d’effectuer l’interprétation du texte du script pour l’exécution, le script
est aussi chargé en mémoire sous la forme d’une structure de données comme le montre la
figure 5.9. Le programme de génération doit donc assurer le parcours de la structure du script
pour effectuer les opérations de manipulation de OutputDs.
Le fonctionnement possible pour un générateur piloté par un script est alors le suivant:
- Il commence par lire le fichier texte McseModel de manière à construire la structure
interne McseDs. De la même manière, il va créer la structure interne XTemplateDs à
partir du fichier texte XTemplate.
- La structure de sortie OutputDs est créée à l’image de XTemplateDs par copie de parties
de structures en se basant sur une analyse de la structure McseDs.
McseModel
OutputDs OutputText
Script
McseDs
MCSE
XTemplateDs
Template
XTemplate
Load
Load
ScriptDs
Script Load
Générique
Générateur
Generation
Save
Edit
Le Méta-Générateur MetaGen
M.C.S.E 151
- Il met ensuite à jour la structure créée dans OutputDs compte-tenu des champs des
noeuds de McseDs. La mise à jour veut dire: placer les noms appropriés des
identificateurs, supprimer les champs inutiles car le template contient la structure la plus
complète, mettre à jour les listes correspondant aux ensembles.
- Il procède ainsi pour toute la structure McseDs par récurrence et/ou récursivité.
- Lorsque la structure est complète, le programme code est produit dans un fichier par la
fonction Save qui exploite la XGrammarDs pour l’interprétation et sa table des
symboles pour l’écriture des champs terminaux.
Ce principe de générateur s’avère ainsi relativement indépendant du langage à produire. Il
s’agit donc de développer la fonction Generation selon une approche d’automate d’exécution
s’appliquant sur le parcours du script représenté en interne par sa structure de données. Le
script doit être construit sur la base des opérations générales de parcours, copie et mise à jour
de structures.
Sur la figure précédente nous avons grisé la fonction Edit. La question est: peut-on exploiter
Edit dans un générateur? Edit peut par exemple servir à proposer des alternatives. Ainsi ne
peut-on pas utiliser Edit pour sélectionner une solution particulière pour la génération lorsque
plusieurs sont possibles? C’est le cas par exemple en VHDL pour une variable partagée à
plusieurs écritures. Les différentes solutions peuvent être dans le template.
Une autre suggestion est de constituer plusieurs templates différents et de choisir le
template le mieux adapté. Ainsi dans le cas du langage C avec l’emploi d’un exécutif tempsréel,
il est utile de pouvoir "fitter" sur plusieurs exécutifs temps réel. La différence est au moins
dans les primitives: noms et arguments, ainsi que dans les déclarations.
Un éditeur orienté par la syntaxe peut aussi servir à l’édition de tout texte défini par une
grammaire. Ainsi, il peut donc tout à fait servir pour l’édition du script. Une telle édition peut
s’imaginer se faire d’une manière interactive; choix d’une action et visualisation immédiate du
résultat.
5.9 DEFINITION DU SCRIPT
La question fondamentale pour définir la grammaire du script concerne les opérations
nécessaires pour assurer toute transformation de structure. On peut donc se dire qu’il s’agit de
rechercher un langage de manipulation de structures.
Pour répondre à cette question, nous commençons par analyser l’ensemble des opérations
élémentaires nécessaires puis nous proposons une technique d’exécution.
5.9.1 Opérations sur les structures
La présentation de la méthode faite dans le paragraphe précédent permet d’extraire assez
facilement les opérations de base nécessaires. Nous retenons la liste suivante:
- Chargement d’une structure à partir d’un texte,
- Sauvegarde d’une structure sous forme textuelle,
- Copie d’une structure complète à partir du point de désignation,
- Copie d’un noeud d’une structure,
- Destruction d’une structure,
- Destruction d’un noeud,
- Mise à jour d’un champ d’un noeud,
Chapitre 5
152 M.C.S.E
- Ajout d’un élément dans un ensemble.
-A- Chargement d’une structure à partir d’un texte: LoadDs
Les structures nécessaires pour la génération (par exemple McseDs et XTemplateDs) sont
chargées par l’opération RefDs := LoadDs(AccessFileName, Grammar, mode);.
- AccessFileName est le chemin d’accès au fichier. Pour que l’outil soit indépendant du
système de fichiers, le chemin est défini à l’aide d’une variable prédéfinie FileSeparator
qui représente le caractère de séparation d’un "path". L’utilisateur du script peut
également utiliser d’autres variables systèmes: ProjectPath pour le chemin du projet,
ToolsPath pour le chemin des outils et Date pour la date courante.
- Grammar définit la grammaire à utiliser pour l’analyse et la construction de la
structure de données.
- mode indique le format du fichier à charger. Le ficher peut être du type Ascii (mode=0)
et dans ce cas il est chargé par un analyseur syntaxique. Mais il peut également être du
type Binaire (mode=1) et dans ce cas on utilise le mécanisme de sérialisation/
désérialisation du langage JAVA pour le charger. Un fichier sérialisé sera chargé plus
rapidement qu’un fichier texte, mais il n’est pas lisible.
- Le résultat RefDs est une référence sur la structure de données créée. Mais comme une
structure de données n’a de signification qu’avec sa grammaire, le résultat va contenir
aussi une référence sur la structure de données de la grammaire GrammarDs qui a été
chargée pendant l’opération LoadDs. GrammarDs contient aussi bien-sûr la table des
symboles.
L’opération peut se représenter par la figure suivante.
-Figure 5.10- Opération LoadDs.
-B- Sauvegarde d’une structure sous forme textuelle: SaveDs
La sauvegarde est l’opération strictement inverse du LoadDs. La syntaxe est:
SaveDs(RefDs, AccessFileName);. RefDs et AccessFileName ont les mêmes significations et
définitions que ci-dessus.
Une bonne vérification consiste à écrire le script suivant:
RefDs := LoadDs(Texte1, McseModel,0); SaveDs(RefDs, Texte2);
On doit alors trouver dans Texte2 la même description que Texte1 mais avec en plus un
formatage qui peut être meilleur si Texte1 ne respectait pas les règles de présentation.
Texte
LoadDs(Texte,Grammaire,mode)
Grammaire
GrammaireDs
TexteDs
RefDs:Ds
Le Méta-Générateur MetaGen
M.C.S.E 153
-C- Copie d’une structure complète: CopyDs
L’objectif est d’obtenir une nouvelle structure image complète de sa source. Une telle copie
concerne la duplication de tous les noeuds de la structure, de tous les identificateurs et valeurs,
de la mise à jour de tous les champs de cette nouvelle structure.
La copie doit être telle que la destruction de la structure source doit permettre son
remplacement par sa copie.
La syntaxe est la suivante: NewDs := CopyDs(SourceDs);
L’opération peut se représenter par la figure suivante.
-Figure 5.11- Opération CopyDs.
La référence sur la nouvelle structure inclut la référence sur sa grammaire pour
l’interprétation. La structure de la grammaire n’est pas copiée.
Une vérification de cette opération peut être la suivante:
SourceDs := LoadDs(Texte1, Grammaire,0);
NewDs := CopyDs(SourceDs);
DelDs(SourceDs);
Save(NewDs, Texte2);
On doit alors retrouver en sortie Texte2 le même contenu que Texte1.
-D- Copie d’un noeud d’une structure: CopyNode
Il s’agit ici de dupliquer uniquement le noeud (et donc pas ses noeuds fils). La duplication
exploite le modèle du noeud dans la grammaire. Tous les champs terminaux sont donc
existants. Les champs contenant des références sur d’autres noeuds ou sur des valeurs ou
identificateurs sont vides (Nil).
La syntaxe est la suivante: NewNode := CopyNode(SourceDs);
L’opération peut se représenter par la figure suivante.
-Figure 5.12- Opération CopyNode.
CopyDs(SourceDs) Ds
NewDs:Ds
GrammarDs
Ds
SourceDs:Ds
CopyNode(SourceDs) Node
NewNode:Ds
GrammarDs
Ds
SourceDs:Ds
Chapitre 5
154 M.C.S.E
La référence sur la nouvelle structure inclut aussi la référence sur la grammaire source pour
l’interprétation. Comme chaque noeud possède son type même après duplication, les champs
du noeud résultat sont définis par ceux de son noeud modèle dans la structure de la grammaire.
En fait, un noeud est simplement le cas particulier d’une structure à un seul élément.
Nous avons aussi considéré utile d’ajouter l’opération CreateNode(GrammarDs,
NodeType); qui a pour objectif de créer un noeud sans avoir un exemplaire disponible. La
création se fait à partir du modèle de la grammaire. L’argument est alors la grammaire et le type
de noeud.
-E- Destruction d’une structure: DelDs
La destruction d’une structure définie par une référence permet de récupérer de la place en
mémoire ou permet de simplifier une structure plus globale.
La syntaxe est la suivante: DelDs(RefDs);
L’opération peut se représenter par la figure suivante.
-Figure 5.13- Opération DelDs.
La référence sur la structure détruite n’est plus utilisable car possédant un contenu Nil. Pour
l’exploitation correcte de cette opération pour le cas représenté par la figure, il faut que la
référence sur SubDs dans Ds doit aussi être supprimée. Ceci est possible avec l’opération de
modification d’un champ décrite ci-après.
La destruction de toutes les structures d’une même grammaire peut conduire à la
destruction de la grammaire de manière à réduire la place mémoire.
-F- Destruction d’un noeud: DelNode
Cette opération n’a de signification que s’il s’agit d’un noeud isolé (sans références). Dans
ce cas il s’agit d’un cas particulier d’une structure. La destruction d’un seul noeud d’une
structure plus globale n’a pas de sens car alors les noeuds fils (ceux référencés) ne sont plus
référencés et donc inutilisables.
-G- Mise à jour d’un champ: ModifField
La modification d’un champ est une opération importante. Il s’agit de pouvoir affecter une
nouvelle valeur. Il y a 2 catégories de noeuds: le noeud de composition (NodeDs), le noeud de
valeur (DataNode). Le noeud de valeur est un noeud élémentaire contenant un nombre ou un
identificateur. Le noeud de composition contient un ensemble de champs de référence. Chaque
champ de référence pointe sur un autre noeud et donc sur une structure. L’assignation d’un
champ est donc fonction de la catégorie concernée. Un champ peut aussi être mis à vide (Nil).
DelDs(RefDs)
RefDs:Ds
GrammarDs
SourceDs:Ds
Nil
Nil
SubDs
Ds
RefDs:Ds
Le Méta-Générateur MetaGen
M.C.S.E 155
La syntaxe est la suivante: RefDs.Field := [ Ds | Val | Nil];
La figure suivante représente les 3 types d’opérations.
-Figure 5.14- Opération ModifField.
Une variante est indiquée pour le champ Range. Dans la grammaire du modèle MCSE, le
champ Range est une référence sur une structure. Si Range ne doit pas exister, il s’agit de
détruire la structure et d’affecter le champ à Nil. Dans ce cas, l’opération DelDs est suffisante.
-H- Ajout d’un élément dans un ensemble: AddFirst, AddLast, AddAfter
les 3 opérations AddFirst, AddLast et AddAfter servent à la mise à jour d’un ensemble
d’éléments. Il s’agit de pouvoir ajouter une structure ou une valeur en début de liste, en fin de
liste ou après un élément donné de la liste.
La syntaxe est la suivante: AddLast(RefDs.Field,VarDs);
La figure suivante représente la structure d’un ensemble et l’effet de l’opération.
-Figure 5.15- Opération AddLast.
SourceDs.Set désigne l’ensemble pour lequel il faut ajouter la structure référencée par
VarDs. Compte-tenu du choix adopté pour l’implantation d’un ensemble, il s’agit d’effectuer
les opérations plus élémentaires suivantes:
TmpDs := SourceDs.Set;
While TmpDs # Nil do TmpDs := TmpDs.NextFriend;
Tmps.NextFriend := VarDs;
DataNode: String
GrammarDs
SourceDs:Ds
Toto
SubDs
RefDs:Ds
Descript
Range = nil
Name
SourceDs.Descript := RefDs;
Source.Name := ’Toto’;
ou bien DelDs(SourceDs.Range);
Source.Range := Nil;
VarDs := SourceDs.Range;
DelDs(VarDs);
DataNode: String
GrammarDs
SourceDs:Ds
Toto
Set
Range = nil
Name
Name Name
Father Father
NextFriend Nil
VarDs:Ds
AddLast(SourceDs.Set,VarDs);
Chapitre 5
156 M.C.S.E
VarDs.NextFriend := Nil;
VarDs.Father := SourceDs;
L’ajout en début de l’ensemble ou après un élément donné est assez similaire.
5.9.2 Instructions d’enchaînement
Après avoir défini les opérations de base, il faut pouvoir construire une instruction ou une
transformation plus complexe. Pour décider des constructions nécessaires, nous partons des
bases de la programmation structurée qui recommande l’emploi des 3 constructions suivantes:
- Exécution séquentielle,
- Répétition,
- Exécution conditionnelle.
Un ensemble d’opérations peuvent se regrouper en une procédure, ce qui va se traduire par
une règle de construction ou de transformation. Nous retenons les instructions suivantes:
- Règle = suite d’instructions ou de règles exécutées en séquence,
- While Condition do règle;
- ForEach élément do règle; instruction appropriée pour les ensembles
- Case pour l’exécution conditionnelle.
Ces instructions sont décrites dans les paragraphes suivants.
-A- Définition d’une règle composite
Une règle de transformation ou de construction se définit comme une suite de règles plus
élémentaires ou d’opérations telles que celles décrites auparavant.
La syntaxe est la suivante: R ::= { R1; R2; ....... Rn; }
La traduction de cette règle sous la forme d’une structure conduit à un vecteur des règles
plus élémentaires. La récursivité est possible en permettant l’utilisation de règles plus
englobantes.
-B- Instruction While
Il est indispensable de pouvoir répéter une règle jusqu’à une condition d’arrêt. La syntaxe
est la suivante: While( Condition : Règle);
La condition peut être élémentaire ou composée de conditions élémentaires avec les
opérateurs logiques ou (OR), et (AND) et ou exclusif (XOR). Une condition élémentaire est
booléenne et limitée aux tests simples Egal (=), Différent (#), Inférieur (<) et supérieur (>). Il
s’agit de tester la valeur de champs.
-C- Instruction Case
L’exécution conditionnelle englobe l’instruction If et l’instruction Case. On retient
l’instruction Case car elle englobe la première. La syntaxe retenue est la suivante:
Case( Condition1 : Règle1 | Condition2 : Règle2 ........ [ | Else : RègleN ]);
Le cas Else est optionnel. Une condition se définit comme pour le While.
-D- Instruction ForEach
Cette instruction porte sur la manipulation d’un ensemble d’éléments. Il s’agit par exemple
de pouvoir exécuter une règle pour chaque élément de l’ensemble. La syntaxe retenue est la
suivante: ForEach( Set : Règle );
Le Méta-Générateur MetaGen
M.C.S.E 157
Set est une référence sur un ensemble. Les éléments de l’ensemble constituent une liste
chaînée avec le pointeur NextFriend.
5.9.3 Définition des variables
L’analyse qui précède montre que les références ou valeurs sont de 3 natures: Référence sur
une structure de données, chaîne de caractères, Nombre. La clarté d’un script passe par la
déclaration des variables utilisées dans celui-ci. Des opérations particulières sont ensuite
nécessaires pour faciliter l’écriture du script.
-A- Déclarations
Pour éviter les erreurs et faciliter la transcription du script pour une exécution efficace, il
est judicieux d’associer un type à chacun.
Les variables désignant un scalaire sont du type String ou du type Value.
Les variables désignant une structure ou un noeud doivent être typées avec la grammaire.
Ceci est nécessaire pour donner une signification aux champs de la structure ou du noeud
référencé. Ceci a été montré comme indispensable pour les opérations CopyDs et CopyNode.
D’où la déclaration: Var : [ Value | String | Grammar ];
La structure de données d’une variable du script pour l’exécution est représentée par la
figure suivante.
-Figure 5.16- Structure de données pour une variable du script.
Certaines opérations nécessitent d’employer des données prédéterminées. Il s’agit alors de
constantes qu’il faut pouvoir déclarer pour faciliter leur modification globale.
D’où la déclaration: Const [ Number | ’String’];
-B- Portée des variables
Par rapport à un langage classique et pour des raisons de simplicité, les règles d’un script
n’ont pas d’arguments d’appel ni de variables locales. Ceci oblige le développeur de Script à
maîtriser parfaitement la traçabilité des variables qu’il utilise et à empiler et désempiler
explicitement les variables utilisées par des règles récursives. Pour éviter d’avoir une liste trop
longue d’instructions Push(Var); et Pop(Var); , une clause LocalVisibility a été rajoutée à la
définition d’une règle. Les variables déclarées dans cette liste sont implicitement empilées lors
de l’appel de la règle et désempiler à la fin de son exécution.
LocalVisibility::=LocalVisibility name {, name};
0:n
VariableScript
TypeName
GrammarRuleName
Name
Value
Element
Integer
Real String
NodeDs
1:1
Pour une variable désignant une structure, la
variable doit aussi avoir une référence sur la règle de
grammaire concernée. Les valeurs des variables sont
gérées sous la forme de pile pour permettre la
récursivité des règles du script. Ceci explique
l’ensemble 0:n
Chapitre 5
158 M.C.S.E
Travailler uniquement par variables globales offre un avantage du point de vue efficacité
du code, mais se paie évidemment par une plus mauvaise lisibilité du code.
5.9.4 Manipulations des variables
Des manipulations des variables du type Value et String sont indispensables.
-A- Les opérations sur les chaînes de caractères
Les opérations de manipulations des chaînes de caractères retenues sont:
- la conversion d’un nombre sous la forme d’une chaîne de caractères (ToString),
- la concaténation de plusieurs chaînes de caractères (&),
- l’obtention du type (nom de la règle de grammaire) d’un noeud de structure (TypeOf),
- l’obtention de la première chaîne rencontrée dans un record (LabelOf),
- l’obtention de la longueur d’une chaîne de caractères (LengthOf),
- l’extraction d’une sous-chaîne dans une chaîne de caractères (SubStringOf).
Les syntaxes de ces instructions sont:
- VarString := ToString(VarValue );
- VarString := VarString1 & VarString2 ......& VarStringN;
- VarString := TypeOf(RefDs.Field);
- VarString := LabelOf(RecordDs);
- VarValue := LengthOf(VarString);
- VarString2 := SubStringOf(VarString1, IndexMin, IndexMax);
Les générateurs de code qui seront obtenus à partir du méta-générateur MetaGen doivent
permettre de produire un programme complet pour faire une simulation fonctionnelle ou une
synthèse. Dans ce cas, des comportements sont écrits directement sous une forme
algorithmique. Le générateur doit alors intégrer ce code saisi manuellement au code généré
automatiquement. Pour cela, nous avons défini l’instruction IncludeOp dont la syntaxe est:
VarString := IncludeOp(FileAccessName, mode)
L’inclusion d’un fichier texte peut se faire par copie (mode=0) ou par référence (mode=1).
Pour le mode par référence, le fichier est inclut uniquement au moment de la sauvegarde de la
structure de données concernée sous forme textuelle.
Lorsque l’on analyse un fichier template, certaines parties déclaratives de ce fichier
n’auront pas à être modifiées pour la transcription. Au lieu de créer une sous-structure de
données pour ces textes figés, le concepteur a la possibilité de les charger uniquement sous
forme de chaînes de caractères en les délimitant par des mots clés spécifiques
(NO_PARSE_TEXT et END_NO_PARSE_TEXT par exemple). L’exemple ci-dessous est
une partie d’un fichier de template illustrant ces propos.
NO_PARSE_TEXT
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.all;
LIBRARY STANDARD;
USE STANDARD.TEXTIO.all;
END_NO_PARSE_TEXT
LIBRARY work;
Le Méta-Générateur MetaGen
M.C.S.E 159
USE work.Declaration.all;
ENTITY ApplicationName IS
...
Lors de la sauvegarde sous forme textuelle, il faut éliminer les délimiteurs de zones non
analysées syntaxiquement. Pour cela, le concepteur dispose de l’instruction DelDelimiter dont
la syntaxe est la suivante:
DelDelimiter(StringRef, BeginDelimiterString, EndDelimiterString);
Bien que ce soit déconseillé, le concepteur peut modifier ces zones de texte figées avec
l’instruction ReplaceCharAt qui permet de changer un caractère d’une chaîne de caractères et
dont la syntaxe est:
ReplaceCharAt(StringRef, Index, NewChar);
-B- Les opérations sur les nombres
Les opérations du script concernant les nombres sont:
- la conversion d’une chaîne de caractères en un nombre (ValueOf),
- l’obtention de l’heure courante (GetTime),
- l’obtention de la mémoire système libre (GetFreeMemory),
- le calcul d’expression avec les opérateurs +, - , * et /.
La syntaxe de ces instructions est:
- VarValue := ValueOf( VarString );
- VarValue := GetTime(Unit); avec Unit ::=ms | sec | min
- VarValue := GetFreeMemory();
5.9.5 Manipulations de liste
Une variable du script est implantée sous la forme d’une pile. Donc pour créer une liste
d’éléments, il suffit de les empiler dans une variable à l’aide des instructions Push et
d’assignation: Push(Var); Var:=NewElement;. Pour gérer ces piles, les instructions à
disposition sont:
- l’obtention de la taille de la liste (SizeOf),
- l’obtention d’un élément de la liste à partir de son index (PeekAt),
- la recherche d’un élément dans la liste à partir de sa référence (IsIn),
- la recherche d’un élément dans la liste à partir de son type et de son nom (Search),
- la réinitilisation d’une variable (ResetVariable).
La syntaxe est la suivante:
- VarValue := SizeOf( ListRef );
- NodeRef := PeekAt( ListRef,Index);
- VarValue := IsIn( ListRef,NodeRef );
- NodeRef := Search( ListRef,TypeName,NodeName);
- ResetVariable( VarRef );
Chapitre 5
160 M.C.S.E
5.9.6 Configuration d’un script
-A- Configuration
L’interprétation du script et sa transcription en code Java peuvent être pilotées en fonction
de paramètres contenus dans un fichier de configuration situé dans le répertoire du projet. Il
s’agit dans le principe d’une sorte de pré-compilateur tel que celui du langage C. Seules les
parties de Script validées par ces paramètres sont compilées et interprétées ou transcrites en
code JAVA. Par exemple, un même script peut ainsi fournir un générateur pour C/VxWorks ou
un générateur pour C/NoyauETRIreste.
La syntaxe est la suivante:
Configuration ExecutifETR;
...
Case (ExecutifETR=’VxWork’: ...;
| Else : ...):
-B- Importation de règles
Un script est un ensemble de règles. Il est possible d’importer et d’utiliser des règles d’un
autre script. Ceci permet à l’utilisateur de pouvoir découper son code en différents petits
morceaux de script. Cette possibilité de découpage a au moins deux avantages:
- elle réduit la taille des fichiers de code et donc améliore leur lisibilité,
- elle permet de créer des librairies de règles qui sont utilisables par différents
générateurs et donc améliore la réutilisabilité du code.
La syntaxe est la suivante: ImportOp NomRegle1,NomRegle2;
Les chemins d’accès aux scripts contenant les règles à importer sont définis dans le fichier
de configuration de l’outil.
-C- Contrôle de l’exécution
En mode interprété, le concepteur peut mettre des points d’arrêt dans son code script avec
l’instruction "BreakPoint;". Il a alors la possibilité de visualiser le contenu des variables, faire
du pas à pas ou continuer l’exécution.
Le concepteur dispose également de l’instruction "Error(msg);" qui permet d’afficher un
message et stopper l’exécution du générateur. A tout moment, il peut aussi envoyer un message
avec les instructions "Display(msg);" et "Warning(msg);" sans stopper l’exécution du
générateur.
Enfin, on retrouve comme instructions du script les méthodes spécifiques à l’exploitation
du modèle MCSE et qui permettent de résoudre les problèmes de:
- portée des noms,
- traçabilité des liens entre éléments de relations et interfaces de composant,
- inclusion de modèle.
Ces méthodes ont été détaillées dans le chapitre 3 sur le modèle de performance de MCSE.
5.10 SPECIFICATION DE LA GRAMMAIRE DU SCRIPT
La syntaxe du langage Script a été inspirée de celle de langages existants. Elle devrait ainsi
être assez familière pour tous nouveaux développeurs de scripts. Sa description au format BNF
est donnée dans le paragraphe suivant.
Le Méta-Générateur MetaGen
M.C.S.E 161
5.10.1 Syntaxe BNF de la grammaire du script
Script ::= ScriptName [Configuration] [Importation] [Constants] [Variables] Operations
Configuration ::= "Configuration" ParameterName {"," ParameterName} ";"
Importation ::= "ImportOp" RuleName {"," RuleName} ";"
Constants ::= "Constants" ConstName ":" ConstValue ";" {ConstName ":" ConstValue ";"}
ConstValue ::= Integer | String
Variables ::= "Variables" VarName ":" VarType ";" {VarName ":" VarType ";"}
VarType ::= "Value" | "String" | GrammarName
Operations ::= "Operations" {OpDefinition}
OpDefinition ::= OpName "::" "{" [LocalVisibility] OpDef; {OpDef;} "}"
LocalVisibility ::= "LocalVisibility" VarName {"," VarName} ";"
OpDef ::= OpName | SaveOp |AssignOp | DelDs | DelNode | ExecOp | SetOp |
CaseOp | WhileOp | PushOp | PopOp | GetAttributes | RelationLinks |
UnLinkInstance | AddFirst | AddLast | AddAfter | ResetVariable | Error |
Warning | Display | "BreakPoint;"
SaveOp ::= "SaveDs(" IdName "," StringDef ");"
AssignOp ::= IdName ":=" Value ";"
IdName ::= VarName {.FieldName}
Value ::= "Nil" | StringDef | Expression
StringDef ::= "LabelOf(" IdName ")" | StringDef {"&" StringDef} |
"IncludeOp(" StringDef "," Integer ")" | "TypeOf(" IdName")" |
"Date" | "ProjectPath" | "ToolsPath" | "FileSeparator" |
DataStructure | "DelDelimiter(" IdName "," StringDef "," StringDef ")" |
SubStringOf(" StringDef "," Expression "," Expression ")" | "ToString(" IdName ")" |
"HierarchyName(" IdName "," IdName "," StringDef ")" |
"ReplaceCharAt(" StringDef "," Expression "," StringDef ")"
DataStructure ::= IdName |
"LoadDs(" StringDef "," Name "," Integer ")" |
"CopyDs(" DataStructure ")" | "CopyNode(" DataStructure ")" |
"CreateNode(" GrammarName "," NodeType ")" |
"PeekAt(" Name "," Expression ")" | "Search(" Name "," StringDef "," StringDef ")" |
"IncludeComponent(" IdName ")" | "GetLibraryPath(" IdName ")" |
"FindModel(" IdName "," Integer ")" | "FindRelationalElement(" IdName ")" |
"FindStartComponent(" IdName "," StringDef "," StringDef "," Integer ")" |
"FindActivityDescription(" IdName ")"
Expression ::= BinaryExpression | Factor
BinaryExpression ::= Expression Op Expression
Op ::= "+" | "-" | "*" | "/"
factor ::= Integer | Real | "SizeOf(" Name ")" | "IsIn(" Name "," IdName ")" |
"ValueOf(" IdName ")" | "GetTime(" Name ")" | "GetFreeMemory()" | "LengthOf(" IdName ")"
DelDs ::= "DelDs(" IdName ");"
DelNode ::= "DelNode(" IdName ");"
ExecOp ::= "Exec(" String ");"
SetOp ::= "ForEach(" VarName ":" OpDef; {OpDef;} ");"
While ::= "While(" Condition ":" OpDef; {OpDef;} ");"
CaseOp ::= "Case(" Condition ":" OpDef; {OpDef;} {"|" Condition ":" OpDef; {OpDef;}}
["| Else" : OpDef; {OpDef;}] ");"
Condition ::= IdName ComparisonOp |alue | Value | LogicalExpression
ComparisonOp ::= "=" | "#" | "<" | ">"
LogicalExpression ::= "(" Condition LogicalOp Condition ")"
LogicalOp ::= "AND" | "OR" | "XOR"
PushOp ::= "Push(" VarName ");"
PopOp ::= "Pop(" VarName ");"
GetAttributes ::= "GetAttributes(" Idname "," VarName ");"
RelationLinks ::= "RelationsLinks(" IdName ");"
UnLinkInstance ::= "UnLinkInstance(" IdName ");"
AddFirst ::= "AddFirst(" IdName "," DataStructure ");"
AddLast ::= "AddLast(" IdName "," DataStructure ");"
AddAfter ::= "AddAfter(" IdName "," DataStructure ");"
ResetVariable ::= "ResetVariable(" VarName ");"
Error ::= "Error(" StringDef ");"
Warning ::= "Warning(" StringDef ");
Display ::= "Display(" StringDef ");
5.10.2 Exemple de Script
L’exemple suivant est un script permettant de traiter partiellement le problème de
génération présenté dans le paragraphe 5.7.1.
ExempleDeScript1
Variables VarMcseDs: McseGrammar; VarTemplateDs: VhdlGrammar;
VarOutputDs: VhdlGrammar; Tmp1Ds: VhdlGrammar;
Tmp2: VhdlGrammar;
Operations
VHDLGenerate :: { Load; CreateEntity; CreateRelations; CreateBlocks; }
Load :: { VarMcseDs :=LoadDs(’McseDescription’, McseGrammar,0);
VarTemplateDs := LoadDs(’template’, VhdlGrammar,1);
}
CreateEntity :: { OutputDs:=CopyDs(TemplateDs);
Chapitre 5
162 M.C.S.E
OutputDs.Name:=McseDs.Name;
}
CreateRelations :: { VarMcseDs:=McseDs.RelationDef;
VarTemplateDs:=TemplateDs.RelationDef;
VarOutputDs:=OutputDs.RelationDef;
ForEach( VarMcseDs : AddLast(VarOutputDs,copyDs(VarTemplateDs));
}
CreateBlocks :: { VarMcseDS:=McseDs.StructureDef;
VarTemplateDs:=TemplateDs.BlockDef;
VarOutputDs:=OutputDs.BlockDef;
ForEach( VarMcseDs : CreateBlock);
}
CreateBlock :: { Tmp1Ds:=copyDs(VarTemplateDs);
Case( VarMcseDs.Range = Nil : DeleteMultipleBlock);
AddLast(VarOutputDs,TempDs);
}
DeleteMultipleBlock :: { Tmp2:=Tmp1Ds.BlockDef;
Tmp1Ds.BlockDef:=Tmp2.block;
}
5.11 AUTOMATE D’EXECUTION
Le script sert à définir la fonctionnalité du générateur. Le comportement sera obtenu par
interprétation de la structure de données ScriptDs qui est le résultat de son chargement par
l’analyseur syntaxique approprié. Dans ce paragraphe nous analysons la structure de données
ScriptDs pour déduire la spécification du moteur d’exécution.
5.11.1 Analyse de ScriptDs
La structure de données ScriptDs est associée à sa structure de grammaire
ScriptGrammarDs comme c’est le cas pour toute structure. Compte-tenu de la grammaire, la
structure de données souhaitée pour tout script est représentée sur la figure suivante.
-Figure 5.17- Structure de données pour la grammaire du Script.
Un script se décompose en deux parties: une partie déclaration et une partie description des
opérations. Dans la partie déclaration, il y a:
ScriptName
Constants
Script
0:n
ConsValue
ConstDef
Const
Name
VarType
VarDef
Var
Name
Variables
Operations
0:n
OpDef
OpName
*Operations
CompoundOp
OpType
Arg1
1:1
ElementaryOp
Arg2
Arg3
0:1
Configuration
0:n
Name
CommaName
,
Name
0:1
ImportOp
Name
Configuration Importation
0:1 0:1
0:n
Constants Variables
:: { }
Le Méta-Générateur MetaGen
M.C.S.E 163
- le nom du script qui est utilisé pour nommer la classe d’objet obtenue par la
transcription du script en code JAVA,
- la clause de configuration qui permet de paramétrer l’exécution et la génération du
script. Les paramètres de configuration sont déclarés et initialisés dans le fichier de
configuration du méta-générateur.
- la clause d’importation qui indique les règles importées d’un autre script. Le nom des
règles et le chemin du fichier dans lequel elles sont définies sont également déclarés
dans le fichier de configuration du méta-générateur.
- la déclaration des constantes et des variables.
Chaque opération est soit une opération composite et donc définie par un ensemble
d’opérations, soit une opération élémentaire. Chaque opération élémentaire est caractérisée par
son type et l’ensemble de ses arguments. Par exemple, l’opération LoadDs possède les 3
arguments: FileName, GrammarName et mode. A noter qu’un argument peut se définir comme
un noeud opération qui est alors le résultat de cette opération (donc une variable implicite).
C’est par exemple le cas pour l’opération LoadDs qui est l’argument de droite de l’opération
d’assignation.
L’ordre de déclaration des règles n’a pas d’importance: les règles sont exécutées suivant
l’ordre d’appel de ces règles.
La récursivité apparaît lorsqu’une opération comprend une opération de niveau supérieur.
5.11.2 Principe d’exécution
La structure du script doit être construite pour avoir une efficacité d’exécution. On analyse
dans ce paragraphe les transformations à apporter à la structure ci-dessus avant exécution pour
permettre une exécution efficace.
-A- Objectif d’efficacité
L’exécution s’obtient par un programme se comportant comme un automate d’exécution
assurant le parcours ordonné de la structure de données du script et exécutant au fur et à mesure
les opérations élémentaires.
L’efficacité d’exécution résulte:
- d’une efficacité du parcours,
- d’une efficacité d’exécution des opérations.
Le parcours de la structure est efficace car l’implantation des ensembles d’opérations est
faite sous la forme de listes chaînées.
L’efficacité des opérations résulte d’un accès efficace aux opérandes puis d’une exécution
rapide. Le point important concerne l’accès aux éléments (variables, champs) comme
opérandes qui doit être le plus direct possible. Les opérandes sont de 2 natures:
- une référence sur une donnée ou une structure. Il s’agit alors d’un accès direct.
- la désignation d’un champ dans un noeud d’une structure qui est faite par son nom
symbolique. La difficulté consiste à connaître directement la position de ce champ dans
le noeud. Cette position est dépendante du type de noeud, la structure du type de noeud
étant définie dans la structure de données de la grammaire GrammarDS.
Chapitre 5
164 M.C.S.E
Le champ concerné est défini dans le script par son nom. Il s’agit donc d’assurer la
conversion du nom du champ en un index dans le noeud. Cette conversion est faite avant
exécution. L’index dans le champ se trouve par la grammaire de la structure du texte considéré.
Comme le type d’une variable (type de la règle de grammaire) dépend de l’historique de
l’exécution du script, cette conversion nécessite de faire une pseudo-exécution qui ne tient
compte que du type des variables (et non leurs valeurs): c’est la phase dite d’optimisation d’un
script.
-B- Exploitation des variables
Les opérandes sont en fait les variables du script. L’efficacité s’obtient en exploitant une
désignation directe de la variable. Ceci impose donc de remplacer le nom dans le script par un
index dans la structure de données des variables (voir le paragraphe suivant).
-C- Principe d’exécution
La figure suivante montre la technique retenue pour obtenir une exécution efficace. Il s’agit
de l’organisation de la structure de données du script pour qu’un programme conçu comme un
automate soit efficace.
Les variables sont regroupées sous la forme d’un vecteur. Chaque variable se désigne alors
par son index dans le vecteur. Chaque variable est également gérée comme une pile qui permet
la récursivité et la gestion de listes.
-Figure 5.18- Structure de données pour une exécution du Script.
Le noeud ElementaryOp illustre le cas des 2 types d’opérandes: une variable ou constante,
un champ d’un noeud. S’il s’agit d’une constante, l’opérande est une référence directe sur cette
constante. S’il s’agit d’une variable, l’opérande est l’index de la variable dans le vecteur. S’il
s’agit d’un champ, il s’agit de l’index dans le noeud.
ScriptName
Constants
OpName
Script
0:n
ConsValue
ConstDef
Const
Name
0:n
VarType
VarDef
Var
Name
Variables
Operations
0:n
OpDef
OpName
*Operations
CompoundOp
OpType
Arg1
1:1
ElementaryOp
Arg2
Arg3
Value
Variable ou constante
Index de champ
Noeud de type connue par VarType
Variables regroupées sous la forme d’un vecteur
Gestion LIFO de chaque variable
VarName
Désignation par l’index dans le vecteur
Le Méta-Générateur MetaGen
M.C.S.E 165
La figure 5.19 illustre le cas de l’opération d’assignation.
-Figure 5.19- Structure de données pour l’opération d’assignation.
L’assignation est définie par IdName := Value. IdName et Value sont ici représentés
comme l’emploi d’un champ d’une variable. Chaque opérande est soit une désignation directe
(cas d’une variable sans champ ou d’une constante), soit un champ d’un noeud désigné par une
succession de champs (indirections multiples comme pour Arg1 de la figure 5.19). Les champs
sont traités dans l’ordre pour faire toutes les indirections déclarées.
5.11.3 Implantation de l’automate
L’automate d’exécution se déduit assez directement de la technique décrite dans le
paragraphe précédent. Il s’agit d’implanter:
- le programme de chargement du script de manière à aboutir à la structure de données
(phase de vérification syntaxique et chargement),
- le programme de parcours de la structure du script pour son optimisation avant
exécution (phase d’optimisation et de contrôles sémantiques),
- le programme de parcours et d’exécution de toutes les opérations élémentaires (phase
d’exécution).
5.11.4 Traduction d’un script en Java
Au lieu d’interpréter le Script en parcourant sa structure de données image, il est également
possible de traduire le Script en un programme Java. On obtient alors un programme de
génération indépendant du méta-générateur pour son exécution et plus rapide que le
fonctionnement en mode interprété. En effet, que le script soit en mode interprété ou transcrit
en code Java, les mêmes méthodes sont utilisées pour l’exécution des opérations élémentaires.
La transcription se limite donc simplement à convertir une structure de données en un
enchaînement d’instructions. Cette conversion repose sur la dualité qui existe entre opérateurs
de composition d’une structure de données et structures de contrôle d’un programme. Ainsi un
record de la structure de données du script est traduit par une séquence d’instructions,
l’alternative par la sélection et l’ensemble par l’itération.
Variables
VarName
AssignOp
IdName
ElementaryOp
Arg2
Value du type IdName
VarName
Champ1
ChampN Champ1
VarName
Arg1
Exemple:
Tmp.BlockDef.Block:=V.Block;
Chapitre 5
166 M.C.S.E
Comme un script peut contenir un ou plusieurs appels récursifs directs ou indirects, nous
sommes obligés de définir une méthode pour chaque règle. Cette solution donne également la
possibilité de surcharger chaque méthode ou règle et donc de piloter le script de l’extérieur.
5.12 LA TECHNOLOGIE JAVA
Le changement de philosophie de conception des outils MCSE a offert l’opportunité
d’utiliser pour l’implantation des outils, le dernier né des langages orienté objet, c’est à dire le
langage Java. Jamais encore un nouveau langage de programmation n’a reçu autant d’attention
et est devenu très populaire aussi rapidement. Les raisons de ce succès sont principalement
liées à la sélection minutieuse des constructions du langage et son ouverture sur le web.
Pour le développement d’une plate-forme d’outils, le langage Java offre un certain nombre
d’avantages non négligeables par rapport à une implantation en C++ ou l’utilisation d’un métaoutil.
Il est en effet [JAWORSKI-97]:
- objet (et non orienté objet). Contrairement à C++ qui permet de programmer sans
utiliser nécessairement une approche et des concepts objet, Java n’autorise de travailler
qu’avec des classes d’objets et supporte tous les concepts de la programmation orientée
objet: hiérarchie de classes, héritage, encapsulation (package), polymorphisme
(méthode de même nom), réutilisation (Java Beans), etc.
- interprété et portable. Un programme Java tourne sur toute plate-forme disposant de la
machine virtuelle Java. Si le logiciel doit satisfaire des contraintes de temps sévères, un
programme Java peut aussi être compilé en code machine à la volée (compilateur Just-
In- Time) ou définitivement (compilateur natif). Le mode interprété permet d’instancier
des classes d’objets dont on ne connaît pas le nom (nom saisi par l’utilisateur par
exemple) lors de la compilation en byte-code. Le pseudo-code (byte-code) utilisé par la
machine virtuelle a aussi la particularité d’être facilement retransformable en code Java
("reverse-coding"). Un déassembleur est livré en standard dans le JDK.
- simple et familier. Pour l’écriture, la syntaxe est proche de celle du C++ avec quelques
concepts plus formalisés tel que l’absence de pointeurs, la persistance d’objets
(sérialisation), etc. La similitude syntaxique entre Java et C++ facilite la translation d’un
programme C++ en Java.
- multi-thread. L’ordonnancement des threads est préemptif et à priorité fixe. La
protection des données partagées entre threads est assurée en standard
(synchronisation). Java offre ici une propriété très intéressante pour la simulation du
modèle de performance de MCSE. En plus de la programmation multi-thread, d’autres
constructions ont aussi été inspirées d’ADA: les concepts de package et d’exception.
- fiable. Les constructions qui sont souvent source de problèmes en C/C++ telles que par
exemple les pointeurs génériques (*void) et la conversion implicite de type ne sont pas
autorisés en Java. Le garbage collector s’occupe de libérer automatiquement la mémoire
désallouée. Le mécanisme d’exception permet de retrouver plus facilement la source
d’une erreur survenue lors de l’exécution du programme.
- riche. La richesse des classes prédéfinies facilite en autre la génération d’interfaces
utilisateurs conviviales (menus, boutons, boite de dialogue, ScrollBar, animations,
gestion des événements, etc),
Le Méta-Générateur MetaGen
M.C.S.E 167
- facile à documenter et à maintenir. Si le code source respecte un format donné,
l’utilitaire javadoc génère un document HTML contenant la hiérarchie des classes, une
description détaillée de chaque classe (attributs, constructeur, méthodes), un index, etc.
- adapté à l’implantation de systèmes distribués sur un réseau local ou distant. Java
permet de décrire facilement des architectures client/serveur et autorise l’utilisation de
différents protocoles de communication (TCP/IP, UDP, IPX, HTTP, etc). Comme il
autorise également le lancement de différents process (programme C, simulateur
spécifique), Java est donc très intéressant pour faire de la co-simulation hétérogène.
- sécurisé. Dédié à programmer des applications sur Internet, Java a été conçu avec
différentes couches de sécurité. Le package Security Manager contient des méthodes
pour contrôler les accès des utilisateurs et encrypter les données.
- ouvert vers le web. Un programme Java décrit sous forme d’applet est téléchargeable
par le web. Si de plus, l’application est implantée sur le modèle client-serveur et utilise
le protocole RMI (Remote Method Invocation), alors elle est utilisable par tous mais sa
propriété intellectuelle (code source) est préservée.
- plein de vitalité. La technologie Java est en plein essor (prolifération de livres, outils et
classes). Le système d’exploitation JavaOs qui est multi-tâches et orienté réseaux de
communication devrait connaître un franc succès avec l’apparition des "Network
Computers" à bon marché et la banalisation d’Internet.
5.13 REALISATION DE L’OUTIL META-GEN
Ce paragraphe décrit la solution retenue pour l’implantation de l’outil MetaGen. Pour
représenter les classes d’objets implantées, nous utilisons le modèle statique de la méthode
OMT-UML. Pour le lecteur non familiarisé avec le dialecte de cette notation pour la conception
orientée objet, les concepts du modèle statique de la méthode unifiée sont présentés dans
[RUMBAUGH-91] [RUMBAUGH-95].
5.13.1 Les classes d’objets
Toutes classes d’objets sont regroupées en deux catégories. La première catégorie concerne
l’interface utilisateur de l’outil. La classe StartScript sert à lancer l’outil sous forme
d’application locale ou d’applet. La classe GenEdit implante l’interface utilisateur qui sera
détaillée dans le paragraphe suivant. La seconde catégorie regroupent les classes qui
constituent le coeur du méta-générateur.
L’ensemble des instructions du script est réparti sur trois classes de la seconde catégorie:
- la classe VariableScript qui implante les variables du script,
- la classe NodeDs qui implante un noeud de structure de données,
- la classe GeneratorAll qui contient les méthodes qui ne sont rattachées ni aux variables
du script ni aux noeuds d’une structure de données.
-A- La classe VariableScript
Chaque variable du script possède une référence sur la grammaire et la règle de grammaire
concernées. Les valeurs d’une variable sont gérées par une pile dont la tête est la valeur
courante de la variable. Lors d’une assignation, il y a systématiquement vérification de la
cohérence entre le type de la variable et la valeur qui lui est assignée.
Chapitre 5
168 M.C.S.E
La hiérarchie des classes est représentée sur la figure 5.20.
-Figure 5.20- Hiérarchie des classes d’objets de l’outil MetaGen.
Vector VariableVector
int nbWaring
boolean debugFlag,historyFlag
Properties generatorConfiguration
...
setDebugFlag
setHistotyFlag
writeMsg
sendMsg
clear
updateVariableTable
getTime
getFreeMemory
replaceCharAt
delDelimiter
includeOp
initReport
initVariableValue
writeHistory
startExecution
suspend
resume
stopExecution
gscriptDs root
Vector ConstantVector
boolean steptostep
Vector ConfigurationVector
...
setStepFlag
load
compile
interprete
interprete
doJavaCode
ToolsPath
ProjectPath
WorkPath
startComponent
...
init
main
String type
String grammar
String name
Stack Value
resetValue
nameOf
grammarOF
typeOf
setType
isIn
search
peekAt
size
push
pop
assign
read
duplicate
NodeDs nextFriend,superFather,father
Vector element
GrammarDs grammarDs
...
copyNode
copyDs
typeOf
addAfter
addFirst
addLast
createNode
delDs
delNode
loadAscii
loadBin
Vector linkUp
Vector linkDown
...
findModel
findRelationElement
getAttributes
getLibraryPath
hierarchyName
includeComponent
relationLinks
unLinkInstance
MetaGen m_generator
watchDialog m_watchDialog
String fileName
String findText
int findIndex
...
open_Action
save_Action
exit_Action
cut_Action
copy_Action
paste_Action
replace_Action
find_Action
compile_Action
execute_Action
code_Action
breakButton_Clicked
stepButton_Clicked
continueButtonClicked
watchButtonClicked
debugFlag_Action
historyFlag_Action
reload_Action
Vector roots
Vector Infos
Vector paths
...
putRoot
getRoot
delete
getPathName
removeAll
...
1
StartScript
GenEdit
1
1 0..*
GeneratorAll MetaGen
gscriptDs
NodeDs
LoadSaveManager
VariableScript
McseDs
VHDLDs GrammarCDs
0..* 0..* 0..*
1
watchDialog findReplaceDialog attentionDialog
1 1 1
Thread exeThread
getVariableOf
getListVariable
getWatchTree
HashTable constantTable,variableTable,
configurationTable,ruleTable
Interface Utilisateur
Méta-générateur
Le Méta-Générateur MetaGen
M.C.S.E 169
-B- Les classes des noeuds de structure
Les classes des noeuds de structure héritent toutes de la classe NodeDs. Parmi ces classes,
la classe McseDs se distingue par le fait qu’elle possède des attributs (linkUp, linkDown) et des
méthodes spécifiques à l’exploitation du modèle MCSE.
-C- La classe LoadSaveManager
Cette classe sert à mémoriser les structures de données chargées (fichiers templates) lors de
l’exécution d’un script. Lors d’une nouvelle exécution, les classes mémorisées qui n’auront pas
été volontairement effacées par l’utilisateur ne seront pas rechargées d’où un gain de temps non
négligeable. Ce mécanisme est également valable pour les générateurs engendrés par le métagénérateur
pour lesquels plusieurs générations de code successives seront nécessaires pour
parcourir le domaine des solutions possibles.
-D- La classe GeneratorAll
La classe GeneratorAll est une classe abstraite dont héritent la classe MetaGen et les classes
obtenues par transcription d’un script en code Java. Elle contient comme principaux attributs
le vecteur des variables du script et un "Thread" qui sert pour l’interprétation ou l’exécution du
script. L’utilisation de ce thread permet de suspendre l’exécution du script à tout moment. On
peut remarquer qu’il n’y a pas de table de constantes. En effet, lors de la génération de code
Java, les constantes sont remplacées par leurs valeurs. Les erreurs de syntaxe, compilation ou
exécution sont gérées par le mécanisme d’exception de Java. En cas d’erreur, un événement
contenant un message d’erreur est envoyé vers l’interface graphique. On utilise également un
événement mais sans message pour signaler la fin d’exécution d’un script.
-E- La classe MetaGen
En plus de ceux hérités de la classe GeneratorAll, les attributs importants de la classe
MetaGen sont:
- la racine de la structure de données du script (root),
- la table des constantes (constantVector),
- la table des paramètres de configuration du script (configurationVector),
Les principales méthodes de cette classe sont chargées de:
- la vérification syntaxique et le chargement de la structure de données du script (load),
- l’optimisation de la structure de données avant son interprétation (compile),
- l’exécution ou plutôt interprétation (interprete),
- la transcription en code java (doJavaCode).
Durant la phase de chargement et vérification syntaxique, on met à jour des "hashtables"
concernant les paramètres de configuration, les constantes, les variables et les règles du script.
Ces hashtables sont ensuite utilisées durant la phase d’optimisation de la structure de données
qui consiste à remplacer une variable par son index dans la table des variables et un nom d’un
champ de record pour son index. Cette phase d’optimisation est une pseudo-interprétation du
script qui ne tient compte que du type des variables. La phase d’exécution est un parcours
ordonné de la structure du script et une exécution des opérations élémentaires.
Chapitre 5
170 M.C.S.E
5.13.2 L’interface utilisateur de l’outil MetaGen
L’interface de l’outil se compose:
- d’une barre de menu principal,
- d’une zone d’édition permettant de saisir le script et où l’on retrouve les commandes
classiques d’un éditeur textuel (open, save, copy, paste, cut, find, replace, etc.),
- d’une zone d’affichage de messages,
- d’une zone de boutons de commande,
- d’une ligne de statut,
- d’une zone d’affichage du contenu des variables sous forme d’arbre.
La figure suivante montre l’interface utilisateur du méta-générateur.
-Figure 5.21- Interface utilisateur de l’outil MetaGen.
La mise au point d’un script se fait d’une manière interactive. Le concepteur assure d’abord
son édition et sa sauvegarde. Le script est ensuite compilé. Durant la phase de compilation,
l’outil fait une vérification syntaxique et charge la structure de données du script. Une fois
chargé, des contrôles sémantiques et des optimisations sont faites (Compile) sur cette structure.
Lorsque la compilation s’est passée sans erreur, le concepteur peut lancer l’interprétation de
son script (Execute). Pour la mise au point, il a la possibilité de placer des points d’arrêt dans
le code (instruction BreakPoint) ou de suspendre l’interprétation à tout moment (Break). Il peut
Le Méta-Générateur MetaGen
M.C.S.E 171
alors visualiser le contenu des variables (Watch) et relancer l’interprétation en continu
(Continue) ou en pas à pas (Step). Des indicateurs permettent d’avoir une trace sur l’écran
(Debug) ou dans un fichier (History) de la compilation ou de l’exécution. Enfin, il peut
transcrire le script en un programme Java dont l’exécution sera beaucoup plus rapide (Code).
5.14 CONCLUSION
Ce chapitre a décrit la stratégie adoptée pour disposer d’un outil général permettant une
conception aisée et efficace de tout générateur de code.
Le travail sur la génération de code présenté dans ce chapitre a aussi amené l’équipe MCSE
à revoir sa stratégie de développement des outils comme support pour la méthodologie MCSE.
Dans la nouvelle plate-forme en cours de développement "MCSE ToolBox", le couplage entre
outils est basé sur un échange par fichiers. Ce fichier d’échange doit être transformé en une
structure de données qui est ensuite manipulée par l’outil concerné. Or, toute structure de
données peut être engendrée d’une manière automatique par un analyseur syntaxique enrichi
des règles de production de la structure de données. Cet analyseur syntaxique est obtenu par un
générateur d’analyseur syntaxique à partir de la spécification de la grammaire (syntaxe
d’entrée du texte source) et des règles de production.
Pour avoir un principe de création de la structure de données indépendant de la grammaire,
nous avons défini pour la spécification des règles de production un modèle de modèle de
structure de données ou méta-structure basé sur la composition de quatre éléments de base qui
sont la séquence d’éléments, l’optionnel, l’alternative et la liste ou ensemble.
Cette solution offre au moins deux avantages. Tout d’abord, elle est évolutive. En effet,
pour faire évoluer la structure de données, il suffit de modifier la grammaire et de regénérer
l’analyseur syntaxique associé. Elle est aussi générique. Comme tous les outils de la plateforme
MCSE ToolBox, un générateur de code repose sur une architecture générique
comportant une fonction de chargement, de modification et de sauvegarde de structure de
données. La fonction de chargement charge sous la forme d’une structure interne le texte
source. La fonction de manipulation parcourt la structure de données du modèle source et crée
à partir des informations recueillies une structure de données de sortie dont la grammaire est
celle du langage cible. La fonction de sauvegarde qui correspond à un parcours ordonné de la
structure de données créée et à l’exploitation de la grammaire pour le formatage du texte de
sortie génère le fichier texte final.
Pour faciliter les manipulations des structures de données à effectuer pour mener à bien une
transcription texte à texte, nous avons également utilisé deux autres concepts: le concept de
template et le concept de script. Un template est un fichier écrit dans le langage cible souhaité
et contenant toutes les constructions nécessaires pour la translation texte à texte. Il s’agit d’un
modèle générique du résultat attendu. Ainsi, la production de la structure de sortie consiste à
parcourir la structure de données du modèle source, copier des parties de la structure du
template puis les mettre à jour. Le script est un langage que nous avons défini pour décrire de
manière concise les manipulations de structures de données à effectuer: chargement d’une
structure à partir d’un texte, sauvegarde d’une structure sous forme textuelle, copie d’une
structure complète ou d’un noeud de structure, destruction d’une structure complète ou d’un
noeud de structure, mise à jour d’un champ d’un noeud et ajout d’un élément dans un ensemble.
Un générateur est alors le résultat de la définition des grammaires des langages source et
cible afin d’obtenir les analyseurs syntaxiques associés, la définition d’un ou plusieurs fichiers
Chapitre 5
172 M.C.S.E
template et l’écriture d’un script. Ce script sert de point d’entrée au générateur de générateurs
de code ou méta-générateur nommé MetaGen qui permet d’interpréter le script ou de le
transcrire en code JAVA. En mode interprété, le script est chargé et la génération se fait par
parcours de la structure de données du script. Bien que relativement lent, ce mode est très utile
pour:
- la mise au point d’un script: vérification incrémentale, point d’arrêt, exécution pas à
pas, visualisation du contenu des variables, etc,
- la modification de la structure de données du script et donc du résultat de la génération
par un programme extérieur (éditeur orienté par la syntaxe par exemple): le script peut
ainsi être modifié de manière interactive par l’utilisateur en fonction de choix
d’implantation. Cette propriété est intéressante pour le développement d’un générateur
d’interface matériel/logiciel qui doit laisser le choix au concepteur entre plusieurs
solutions d’implantation possibles.
Lorsque le script est transcrit en code Java, l’exécution est plus rapide, sachant qu’en
contre-partie il ne peut plus être modifié par un programme extérieur que par une surcharge de
méthodes.
L’intérêt du script est que toute la définition de la génération se fait par des règles de
production fournies au générateur pour son paramétrage. Ainsi une modification dans le script
est immédiatement reportée dans le générateur concerné. Un autre aspect intéressant est la
possibilité de construire un script (c’est-à-dire sa structure de données) par un autre
programme. Il peut s’agir d’un programme interactif permettant au concepteur de spécifier ce
qu’il désigne comme solution en sortie. Ceci peut par exemple être le cas pour le choix d’une
solution pour l’implantation d’une variable partagée ou d’une fonction. Il peut aussi s’agir de
l’emploi d’un autre script qui par son exécution engendre le script de production du code!. La
modification de la structure de données d’un script peut aussi se faire en interactif par une
édition orientée par la syntaxe car toutes les règles de grammaire sont connues par l’outil.
L’éditeur exploite alors la méta-structure et la table des symboles pour proposer à l’utilisateur
les solutions possibles. La sélection faite respecte ainsi obligatoirement la grammaire.
Actuellement, les concepts retenus et le méta-générateur développé ont été utilisés pour
générer trois générateurs de code:
- un générateur de code VHDL comportemental pour la vérification fonctionnelle et
l’évaluation des performances qui est présenté dans le chapitre 6. Ce générateur a
demandé un temps de développement plus long (6 mois) que les deux autres (3 mois)
car d’une part les règles de transcription sont plus complexes et d’autre part il n’a pas
pu bénéficier contrairement aux deux autres de l’expérience acquise sur l’implantation
d’un générateur équivalent mais limité au modèle fonctionnel de MCSE. Ce générateur
est également celui qui est le plus avancé, debuggé et testé.
- un générateur de code VHDL au niveau RTL pour la synthèse matérielle
- un générateur de code C/Noyau Temps-réel pour la synthèse logicielle pour lequel la
possibilité de configuration permet de changer facilement de noyau temps-réel cible.
Un générateur de code C++ pour l’évaluation des performances est également en cours de
développement. Pour tester efficacement l’intérêt de notre solution, ce générateur est
développé par des personnes nouvelles au projet (utilisation de candide pour ne pas biaiser les
résultats de cette expérience).

M.C.S.E 173
6
Le Générateur VHDL
Ce chapitre décrit l’implantation du générateur de code VHDL. Rappelons que l’objectif à
atteindre consiste à obtenir un outil capable de transcrire le modèle de performance de la
méthodologie MCSE en une description VHDL comportementale. Le modèle de performance
qui est l’entrée du générateur a été présenté dans le chapitre 3. Les règles de transcription qu’il
s’agit d’implanter dans le générateur de code ont été détaillées dans le chapitre 4. Pour avoir
un principe de génération commun à tous les générateurs de code et indépendant du langage
cible, nous avons développé un méta-générateur qui a fait l’objet du chapitre 5.
Pour développer un générateur de code avec le méta-générateur nommé MetaGen, nous
préconisons de suivre une démarche en trois phases:
- Entrer la grammaire du langage cible correctement afin d’obtenir un analyseur
syntaxique. Généralement on n’utilisera pas toutes les constructions du langage cible et
on peut évidemment se contenter de définir la syntaxe de celles qui nous seront utiles.
Le générateur d’analyseur syntaxique fournit un rapport de la syntaxe saisie très utile
lors du développement du script (recherche de la syntaxe d’une règle).
- Définir un ou plusieurs fichiers template. Ce fichier doit contenir toutes les
constructions du langage utiles pour la génération de code. Une fois analysé, ce fichier
est stocké sous la forme d’un arbre à partir duquel on dupliquera des branches pour
générer l’arbre du programme de sortie. Comme il est plus facile de détruire une partie
d’arbre que de construire des feuilles une par une, il est conseillé de définir les
constructions utilisées sous leur forme complète. Cette définition est importante car elle
influe directement sur la rapidité du développement du générateur et sur l’efficacité et
la qualité de son implantation.
Chapitre 6
174 M.C.S.E
- Ecrire le script pour implanter les opérations nécessaires pour réaliser la transcription:
d’un point de vue macroscopique, une grande partie du temps sert à dupliquer des
branches et à mettre à jour des noms.
Nous commençons donc ce chapitre en présentant la spécification d’entrée de la grammaire
VHDL qui sert à produire un analyseur syntaxique pour le langage VHDL. Les templates
utilisés pour faciliter la génération du package et de l’entité VHDL sont ensuite décrits. La
présentation du Script définissant les manipulations à effectuer sur les structures de données du
modèle source et des templates est décomposée en deux parties: une partie Analyse du modèle
MCSE et une partie Génération. La description de la partie Analyse détaille le parcours et
l’analyse de la composante structurelle puis de la composante comportementale du modèle de
performance de MCSE. La partie Génération regroupe l’ensemble des règles de production de
la structure de données de sortie. Ces règles appelées dans la partie Analyse utilisent les
informations fournies par la partie Analyse et les structures de données des templates pour
générer la structure de données de sortie qui sera sauvegardée au final sous forme textuelle. Le
générateur obtenu a été testé avec les exemples décrits dans le chapitre 7. Un tableau
comparatif avec les autres générateurs de code prototypés pour la plate-forme d’outils "MCSE
ToolBox" est fourni. Une fois transcrit en code Java par le méta-générateur, le script a été
associé à une interface utilisateur et a été intégré au "framework" de la plate-forme "MCSE
ToolBox". Une présentation succincte de l’interface utilisateur du générateur est également
donnée. Au terme de ce développement, diverses améliorations sont envisageables à court
terme. Avant de conclure, nous présentons donc une liste non exhaustive d’améliorations
possibles.
6.1 SPECIFICATION DE LA GRAMMAIRE VHDL
Le générateur d’analyseur syntaxique sur lequel est basé la plate-forme des outils MCSE
en cours de développement se nomme JAVACUP. C’est un générateur d’analyseur syntaxique
du type LALR(1) comparable à YACC qui génère du code JAVA et qui a été développé par
Scott E. Hudson [HUDSON-96].
Dans les paragraphes suivants, nous allons décrire le fonctionnement d’un analyseur
syntaxique obtenu avec JAVACUP. La compréhension de ce fonctionnement est indispensable
pour écrire les règles grammaticales d’une manière correcte et efficace.
6.1.1 Principe de fonctionnement de l’analyseur syntaxique utilisé
L’analyseur syntaxique généré par JAVACUP est en fait une machine d’états pour laquelle
chaque état correspond à une position dans une ou plusieurs règles partiellement analysées. Il
est couplé à un analyseur lexical dont le rôle est de découper le texte source en unités
significatives que l’on nommera par la suite token. A chaque fois que l’analyseur syntaxique
lit un token provenant de l’analyseur lexical et qui ne complète pas une règle, il l’empile et va
dans l’état correspondant au nouveau token lu: cette action s’appelle "a shift".
Quand il a obtenu (empilé) tous les tokens nécessaires pour compléter une règle, l’analyseur
syntaxique les désempile, empile le symbole correspondant à la règle réduite et va dans l’état
correspondant à la nouvelle situation: cette action s’appelle "a reduce" (le nombre d’objets
dans la pile a diminué). Si une action est associée à la règle réduite, elle est alors exécutée.
Dans notre cas, à chaque réduction de règle, il y a mise à jour de l’arbre du programme qui
contiendra au final le code analysé.
Le Générateur VHDL
M.C.S.E 175
6.1.2 Les conflits
JAVACUP peut échouer dans la translation de la spécification d’une grammaire si celle-ci
est ambiguë ou contient des conflits. Si la grammaire est réellement ambiguë, il y a deux
possibilités d’analyse pour une chaîne d’entrée et JAVACUP ne peut traiter ce cas. Si la
grammaire est non ambiguë, il peut y avoir des conflits liés au fait que l’analyseur syntaxique
aurait besoin de tenir compte de plus de un token d’entrée ("limited lookahead") pour décider
laquelle des possibilités utiliser.
Il y a deux types de conflits qui peuvent apparaître quand JAVACUP essaie de créer un
analyseur syntaxique: les "shift/reduce" conflits et les "reduce/reduce" conflits.
Un "shift/reduce" conflit apparaît quand pour un token d’entrée il y a deux possibilités
d’interprétation et que l’une des possibilités complète une règle (reduce option) et pas
l’autre (shift option).
Un "reduce/reduce" conflit apparaît quand un même token d’entrée peut compléter
deux règles différentes.
Nous allons présenter dans les paragraphes suivants les principaux types de problèmes
rencontrés lors de la génération d’un analyseur syntaxique pour le langage VHDL’93.
-A- Expressions arithmétiques
Considérons le cas des expressions arithmétiques qui sont décrites directement ou
indirectement par une règle récursive telle que par exemple:
expr ::= expr + expr |
expr - expr |
expr * expr |
expr / expr |
factor
Avec la chaîne d’entrée suivante expr + expr + expr, il y aura un shitft/reduce conflit sur la
deuxième occurrence du signe +. Contrairement à Yacc qui possède des opérateurs de priorité
et d’associativité (%left, %right, %nonassoc), JAVACUP ne permet pas d’éviter ce type de
conflit. On obtient alors un shift/reduce conflit où le shift l’importe: ce qui correspond à une
associativité à droite.
-B- Problèmes liés au "limited lookahead"
Considérons le cas de la déclaration d’un sous-type en VHDL décrite par la syntaxe BNF
suivante:
subtype_declaration::=subtype identifier is subtype_indication
subtype_indication::=[resolution_function_name] type_mark [constraint]
avec pour simplifier
resolution_function_name::=identifier
type_mark::=identifier
JAVACUP ne peut pas savoir si l’identificateur qui suit le mot clé "is" correspond au nom
de la fonction de résolution ou au nom du type. Avec un analyseur syntaxique fonctionnant
avec un "lookahead" d’au moins deux tokens, il n’y aurait pas de conflits dans ce cas.
Pour résoudre ce type de conflit, on n’a pas d’autres choix que de mettre à plat la description
comme indiqué ci-dessous:
subtype_declaration::=
subtype_declaration_with_resolution_function_name |
subtype_declaration_without_resolution_function_name
Chapitre 6
176 M.C.S.E
subtype_declaration_with_resolution_function_name::=
subtype identifier is resolution_function_name type_mark [constraint]
subtype_declaration_without_resolution_function_name::=
subtype identifier is type_mark [constraint]
-C- Problèmes liés au recouvrement d’alternatives
Considérons les règles syntaxiques suivantes:
name::= identifier |
operator_symbol |
selected_name |
indexed_name |
slice_name |
attribute_name
operator_symbol::=string_literal
primary::=name |
literal |
aggregate |
function_call |
qualified_expression |
type_conversion |
allocator |
(expression)
literal::= numeric_literal |
enumeration_literal |
string_literal |
bit_string_literal |
null
Au niveau de la règle primary, il y a un recouvrement de la règle string_literal au travers
des règles name et literal et par conséquent il y aura un reduce/reduce conflit entre les règles
name et literal.
Pour éviter ce type de problème, il faut s’arranger pour que tous les éléments d’un choix
multiple soient disjoints:
primary::=name_without_literal_string |
literal_without_literal_string |
literal_string |
aggregate |
function_call |
qualified_expression |
type_conversion |
allocator |
(expression)
Il n’est pas toujours immédiat de retrouver la source d’une erreur. La spécification d’une
grammaire est une opération longue pour laquelle une maîtrise totale de la syntaxe est
indispensable. Enfin, la représentation de la grammaire sous la forme du modèle graphique de
méta-structure est très utile pour son optimisation.
6.1.3 L’analyseur syntaxique obtenu
La syntaxe du langage VHDL décrite dans le LRM (Langage Reference Manual) n’est pas
du type LR(1). Elle est même ambiguë hors contexte. Pour éliminer les shift/reduce et reduce/
reduce conflits de notre grammaire VHDL, nous avons fait quelques petites transgressions des
règles syntaxiques décrites dans le LRM. Notre analyseur syntaxique n’est donc pas
strictement "full VHDL’93".
Le Générateur VHDL
M.C.S.E 177
Les entrées acceptées par l’analyseur syntaxique qui ne sont pas des constructions VHDL
correctes peuvent être rejetées par des contrôles sémantiques. Comme notre but n’est pas de
générer un éditeur orienté par la syntaxe, nous n’aborderons pas le sujet des contrôles
sémantiques. D’ailleurs, l’élimination des conflits (mise à plat de la grammaire) se paie
malheureusement aussi sur l’aspect et la convivialité de l’éditeur syntaxique.
Le code de la grammaire VHDL comporte 3084 lignes alors que celui de la grammaire du
modèle MCSE ne nécessite que 1750 lignes.
6.2 LES TEMPLATES UTILISES
Le fichier template contient toutes les constructions du langage VHDL nécessaires pour le
générateur. Une fois analysé, ce fichier est stocké sous la forme d’un arbre à partir duquel on
dupliquera des branches pour générer l’arbre du programme de sortie.
Pour la génération, nous utilisons deux templates: un pour la génération de l’entité VHDL
représentant le système étudié et l’autre pour le package associé à cette entité.
La génération d’un package est due uniquement aux limitations sur la généricité des types
du langage VHDL. Pour éviter de surcharger les primitives d’accès aux éléments de relations
du modèle MCSE en fonction du type de la donnée transmise, on regroupe les types et les
attributs concernant les ports de communication dans le record TypeDefInformation. De
même, les types et attributs concernant les variables partagées sont regroupés dans le record
TypeDefData.
La représentation graphique du template du package est la suivante.
-Figure 6.1- Structure de données pour le template du package VHDL.
Les éléments en gras correspondent à des branches référencées par des variables du script.
GenericPackage
Design
PackageDeclaration PackageBody
DesignUnit File
NoParseContextClause
OptionalDesignUnit
Design
Unit
Design
Unit
Design
Unit
Package
Package
PackageName Declara.
OptionalPackage
DeclarativePart
PackageName
PackageName
NoParseConstDef
TypeDefInformation
TypeDefData
NoParseTypeDef NoParseReadSharVarDeclaration
NoParseSendDeclaration
OptionalArchitecture
StatementPart
Body
PackageName
NoParseReceiveDeclaration
NoParseComponentDeclaration
0:n
NoParseReceiveBody
NoParseSendBody
NoParseReadSharVarBody
NoParseWriteSharVarDeclaration
NoParseWriteSharVarBody
NoParseResolFunc
0:n
0:n
Chapitre 6
178 M.C.S.E
La structure de données du template de l’entité est représentée par la figure 6.2.
-Figure 6.2- Structure de données pour le template VHDL de l’entité.
Le fichier template de l’entité contient comme constructions de base du langage VHDL:
GenericEntity
ArchitectureBody
EntityDeclaration
DesignUnit
NoParseContextClause
OptionalDesignUnit
Design
Unit
Design
Unit
Design
Unit
Entity
Declara.
ContextClause
EntityName
GenericClause PortClause
0:n
OptionalArchitecture
DeclarativePart
EntityName
EntityName
ConstantDeclaration
TypeDeclaration
SignalDeclaration
AliasDeclaration
NoParseDeclarations
PortConfiguration
DataConfiguration
Library
Clause
Use
Clause
0:n
LibraryName LibraryName PackageName
ComponentEve 0:n
ComponentData
GenericBlock
OptionalArchitecture
StatementPart
ComponentPort
Block
Statem.
0:n
OptionalBlock
StatementPart
MultipleBlock
Generate
Statem.
GenerateStatement
SimpleBlock
Block
Statem.
SignalOpStatus
SignalProtocolVector
SignalStates
SignalStatesMonitoring
SignalNbActiveTask
SignalProcessorRate
OptionalBlock
DeclarativePart
0:n
Scheduler
StatesMonitor
RateMonitor
ProtocolVector
GenericProcess
Process
Statem.
0:n
ConstantTime
VarBranchNumber
VarSeed
OptionalProcess
DeclarativePart
OptionalSubProgram
StatementPart
OptionalBlock
StatementPart
OpStatusInit
NoParseSeed
InactiveTask
TaskPriority
WaitingTask
Fork
WaitFork
InitConditionalActivation
WaitConditionalActivation
ResetConditionalActivation
CaseStatement UniformCall IfStatement
ForStatement
LoopStatement
Delay
WaitJoin
Join
Send
Receive
WriteSharVar
ReadSharVar
SignalEv
0:n WaitEv
Architec.
0:n
Design
File
0:n
Le Générateur VHDL
M.C.S.E 179
- la déclaration d’une entité avec sa clause générique et son port,
- la déclaration des modèles de définition de constante, variable, signal, alias et type,
- la déclaration des modèles de composant VHDL représentant les éléments de relation
du modèle MCSE et leur instanciation,
- la déclaration d’un block multiple contenant un block simple utilisé pour la
transcription des éléments actifs du modèle MCSE,
- la déclaration de l’ordonnanceur et des signaux qui lui sont associés,
- la déclaration de l’ensemble des primitives utilisées pour la transcription du modèle de
comportement d’un élément actif.
On trouve également dans le template des portions de code délimitées par les mots clés
NO_PARSE_TEXT et END_NO_PARSE_TEXT et qui sont chargées uniquement sous forme
de chaînes de caractères. Normalement, ces chaînes de caractères ne seront pas modifiées par
la génération.
Pour une exploitation efficace du template, la structure de données est parcourue une seule
fois au début de la génération et un ensemble de pointeurs sur ses éléments caractéristiques est
mis à jour.
6.3 CONCEPTION D’UN SCRIPT
Pour bien comprendre quel doit être le contenu d’un script, rappelons tout d’abord le
fonctionnement macroscopique d’un générateur:
- Il commence par lire le fichier texte McseModel de manière à construire la structure
interne McseDs. De la même manière, il va créer la structure interne XTemplateDs à
partir du fichier texte XTemplate.
- La structure de sortie OutputDs est initialisée à l’image de XTemplateDs.
- Il met ensuite à jour la structure OutputDs en se basant sur une analyse de la structure
McseDs. La mise à jour veut dire placer les noms appropriés des identificateurs,
supprimer les champs inutiles car le template contient la structure la plus complète,
mettre à jour les listes correspondant aux ensembles.
- Il procède ainsi pour toute la structure McseDs par récurrence et/ou récursivité.
- Lorsque la structure est complète, le programme code est produit dans un fichier par la
fonction Save qui exploite la grammaire XGrammarDs pour l’interprétation et sa table
des symboles pour l’écriture des champs terminaux.
La difficulté repose sur les phases numérotées 3 et 4 pour lesquelles il faut traduire les
règles de transcription décrites en langage naturel en un ensemble de règles de script. Au moins
deux approches sont possibles pour ce problème.
La première approche consiste à partir du modèle final (copie du template) et à utiliser un
ensemble de règles de la forme "pour chaque <élément_modèle_final> faire si
<condition_modèle_source> alors <mise_a_jour_modèle_final>". Cette solution est
uniquement possible si le modèle final est une description structurée et de préférence
hiérarchique et descendante. Son principal inconvénient est la recherche des conditions de mise
à jour qui peut nécessiter un parcours multiple du modèle source. Ce principe est à rapprocher
Chapitre 6
180 M.C.S.E
de la technologie d’un système expert dans lequel les règles de transcriptions constituent une
base des connaissances et l’analyse du modèle MCSE fournit les faits qui sont introduits dans
un moteur d’inférence avec chaînage arrière.
La seconde approche consiste à partir du modèle source (modèle MCSE) et à utiliser un
ensemble de règles de la forme "si <condition_modèle_source> alors
<génération_modèle_final>. Cette fois, le modèle source est a priori parcouru une seule fois.
Nous avons retenu cette solution plus avantageuse et plus conventionnelle.
6.3.1 Structure de la fonction Génération
Compte tenu du principe utilisé, la fonction Génération de la figure 5.9 sur la structure
interne d’un générateur du chapitre 5 peut se raffiner comme le montre la figure 6.3. A noter
que nous exploitons ici la méthodologie MCSE pour la conception de la solution. Une bonne
conception fonctionnelle nécessite de chercher d’abord les variables internes caractéristiques
indispensables pour déterminer les fonctions qui l’exploitent. La variable caractéristique
retenue nommée Information représente les informations pertinentes extraites de d’analyse du
modèle source MCSE et qui sont indispensables pour la génération du code de sortie.
-Figure 6.3- Raffinement de la fonction Génération.
Cette décomposition fonctionnelle fait apparaître qu’un script peut donc se décomposer en
deux parties:
- une partie Analyse qui correspond au parcours ordonné de la structure de données
McseDs et à l’extraction d’informations pertinentes pour la génération,
- une partie Génération qui exploite les informations obtenues de l’analyse et les
structures génériques des templates pour générer la structure de données de sortie.
La partie Analyse est la partie dans laquelle on trouve le plus de similitudes entre des
générateurs de code utilisant le même modèle source (modèle MCSE par exemple). Les
différents types de parcours possibles sur la structure de données McseDs du modèle de
performance de MCSE sont détaillés dans le paragraphe suivant.
La partie Génération exploite les informations obtenues de l’analyse et les règles de
transcription. Cette partie est spécifique pour chaque générateur. On peut imaginer qu’un
générateur de code C ciblant sur différents exécutifs temps-réel utilisera une seule fonction
d’analyse et plusieurs fonctions de génération et templates.
OutputDs
McseDs
XTemplateDs
Information
Generation
GenerateOutputDs
AnalyzeMcseDS
Le Générateur VHDL
M.C.S.E 181
La tendance naturelle du concepteur de générateur va être d’écrire les règles de cette partie
de script de façon à obtenir un comportement du générateur identique à celui d’une
transcription manuelle: c’est à dire qu’il va suivre l’ordre chronologique et structurel suivi lors
d’une saisie manuelle du code cible. En procédant ainsi, il risque d’obtenir un script non
optimisé. En effet, comme on travaille sur des structures de données, on n’est pas limité par
l’accès séquentiel des fichiers et une même information peut très bien servir à mettre
simultanément à jour des parties de code cible complètement disjointes. Cependant ce constat
est à relativiser si les modèles source et destination sont structurellement très proches comme
c’est le cas pour notre générateur VHDL. Pour faire face à la complexité, la meilleure solution
est probablement d’écrire son script de manière naturelle et de l’optimiser dans un second
temps. Pour cette phase d’optimisation, il est indispensable de trouver un formalisme adéquat
pour représenter les règles de transcription décrite en langage naturel. Mais pour l’instant, nous
n’avons pas fait de recherche dans cette direction.
La décomposition du script en deux parties facilite sa lisibilité et sa maintenance. Une
modification de la grammaire du langage cible se veut être sans conséquence sur la partie
Analyse. Il est souhaitable que le format des informations échangées entre la partie analyse et
génération soit complètement indépendant des grammaires utilisées. Ainsi, une modification
de la grammaire du modèle MCSE serait également invisible pour la partie génération. Ceci
implique du point de vue implantation qu’il faut utiliser des listes intermédiaires et non pas
directement les ensembles de la structure de données source. Comme la création de ces listes
intermédiaires a un coût en temps d’exécution et mémoire occupée et que la grammaire du
modèle MCSE est maintenant relativement stable, nous n’avons pas retenu ce principe pour
l’échange d’informations entre les deux parties.
6.4 PARCOURS ET ANALYSE DU MODELE MCSE
Le modèle de performance de MCSE se compose de deux vues complémentaires: la vue
structurelle (dimension organisationnelle) et la vue comportementale (dimension temporelle).
Le parcours du modèle MCSE se décompose donc en deux étapes: un parcours du modèle
structurel et pour chaque fonction non raffinée un parcours de son modèle de comportement.
6.4.1 Parcours du modèle structurel de MCSE
La vue structurelle permet de décrire les éléments actifs (fonction, processeur) d’un
système et leurs interconnexions (événement, variables partagée et port de communication). Le
modèle structurel est hiérarchique: un élément actif peut être raffiné. Un élément actif peut
aussi être une instance d’un modèle.
Pour illustrer nos propos, nous allons partir de l’exemple représenté sur la figure 6.4. Le
système se compose de 2 fonctions F1 et F2 couplées par une variable partagée V. La fonction
F1 est raffinée par 2 fonctions F11 et F12 utilisant toutes les deux la variable V.
On s’aperçoit avec la figure 6.4 que la structure de données d’un modèle MCSE est un
graphe particulier dans lequel il existe une et une seule suite d’arêtes permettant de relier tout
couple de sommets. C’est donc un arbre et plus précisément une arborescence. En effet par
définition, une arborescence est un arbre dans lequel on particularise un sommet appelé la
racine, ici le sommet McseDs, et à partir duquel sont placés les autres sommets par niveaux
successifs. A partir de cette caractéristique, nous analysons les possibilités de parcours de la
structure.
Chapitre 6
182 M.C.S.E
-Figure 6.4- Exemple de système avec sa structure de données.
-A- Les différents types d’algorithme de parcours d’une structure MCSE
Il y a deux catégories de parcours pour les arborescences: le parcours en largeur d’abord
abrégé BFS (Breath First Search) et le parcours en profondeur d’abord abrégé DFS (Depth First
Search).
Le parcours BFS consiste à parcourir l’arborescence par niveau, de gauche à droite dans
chaque niveau. Ce type de parcours est possible pour une analyse du modèle MCSE si la
génération des éléments d’un niveau ne nécessite pas d’informations provenant de l’analyse de
niveaux inférieurs. C’est le cas le plus simple de génération de code. Avec ce type de parcours,
la hiérarchie du modèle de départ n’est pas respectée dans le modèle final.
On distingue deux types de parcours DFS:
- En préordre ou préfixé ou parcours descendant (top-down). On commence par exploiter
la racine puis la sous-arborescence de la gauche vers la droite. Tout comme pour le
parcours BFS, l’utilisation de ce type de parcours n’est possible que si la génération des
éléments d’un niveau ne nécessite pas d’informations provenant de l’analyse de niveaux
inférieurs. Par contre, la hiérarchie du modèle de départ est respectée dans le modèle
final.
F
McseDs
ComponentDef
1:n
Relations
F1
1:n
Component
DefV
<Var>
Relation
V
0:n
DefV
<Var>
Interface
V
<InOut>
InputOutput
Description
ComponentDef
F11
1:n
Component
0:n
DefV
<Var>
Interface
V
<Out>
InputOutput
Description
F12
0:n
DefV
<Var>
Interface
V
<In>
InputOutput
Niveau 1
Niveau 2
BehaviorDef
F2
Component
0:n
DefV
<Var>
Interface
V
<InOut>
InputOutput
Description
BehaviorDef
BehaviorDef
F1
F11
F12
V
F2
F
Représentation graphique de la structure
fonctionnelle du système
Représentation graphique partielle de la structure de données du système
<RelationTypes>
DefV;
<EndRelationTypes>
<GenericParameters>
<EndGenericParameters>
<FunctionalStructure>
<Component> F ();
<Structure> StructureF;
<Var> V : DefV;
<Component> F (In Var V : DefV;);
<Attributes>
V‘Read = 100 ns;
<EndAttributes>
<Behavior> BehaviorF;
...
Représentation textuelle partielle du système
sauvegarde
sous forme
textuelle
chargement de la structure de
données par l’analyseur
syntaxique
Le Générateur VHDL
M.C.S.E 183
- En postordre ou postfixé ou parcours ascendant (bottom-up). On commence par
exploiter les feuilles pour terminer par la racine. Lorsque l’on transcrit une feuille, on
dispose forcément de toutes les informations nécessaires car celles-ci ont été collectées
durant le parcours d’accès à cette feuille. Mais le modèle de départ est mis à plat.
L’ordre des traitements des feuilles de l’arborescence de l’exemple pour les 3 types de
parcours possibles est le suivant.
-Figure 6.5- Les 3 types de parcours possibles de l’arborescence de l’exemple.
Si le modèle final ne permet pas de garder la hiérarchie du modèle source, l’algorithme de
parcours le plus efficace pour la fonction analyse du générateur est le parcours ascendant
(bottom-up). Si l’on souhaite respecter la hiérarchie du modèle source, il faut utiliser un
algorithme de parcours descendant (top-down). Ce type d’algorithme ne pose aucun problème
si la génération d’une feuille ne dépend que des informations des feuilles précédentes ou si il
y a transcription quasi-directe entre un élément du modèle source et son correspondant dans le
modèle cible. Mais la majorité des générateurs de code ne correspondront pas à cette situation.
Sinon la structure de données ne sert à rien, car il aurait mieux valu faire une transcription
directe au niveau de la règle de production de l’analyseur syntaxique. Il faut alors utiliser un
algorithme mixte Top-Down/Bottom-Up permettant d’obtenir pour l’exemple précédent
l’ordre de traitement M V F1 F11 F12 F1 F2 M. Concrètement, cela signifie que la génération
d’une feuille se fera en deux phases. La première phase correspondant au parcours descendant
consiste à générer même de manière incomplète tous les éléments du modèle final permettant
de respecter la hiérarchie du modèle source. La second phase correspondant au parcours
ascendant consiste à mettre à jour si nécessaire les éléments d’un niveau donné du modèle final
en fonction d’informations provenant de niveaux inférieurs.
-B- Description des algorithmes de parcours
Nous allons maintenant donner dans le formalisme du langage script les algorithmes de
parcours possibles du modèle MCSE. Comme il s’agit d’effectuer un parcours ordonné d’une
structure de données d’un modèle MCSE, il est utile de rappeler auparavant le méta-modèle
d’une structure de données MCSE. La figure 6.6 représente la structure de données simplifiée
d’un élément actif.
Un élément actif peut être raffiné (StructureDef) ou décrit par un comportement
(BehaviorDef). Le raffinement d’un élément actif se compose d’éléments de relation et
d’éléments actifs (ComponentDescription) et/ou d’instances de modèle
(ComponentInstanceDeclaration). Un modèle peut être défini en interne (ComponentModels)
M
F11 F12
V F1 F2
M
F11 F12
V F1 F2
M
F11 F12
V F1 F2
M V F1 F2 F11 F12 M V F1 F11 F12 F2 V F11 F12 F1 F2 M
BFS TOP-DOWN BOTTOM-UP
Chapitre 6
184 M.C.S.E
ou importé d’une librairie (ComponentInclude). Ce méta-modèle fait clairement apparaître des
bouclages indiquant que l’algorithme de parcours est récursif ou utilise une pile.
-Figure 6.6- Structure de données MCSE simplifiée d’un élément actif.
Dans un parcours d’une arborescence en profondeur d’abord, après avoir rencontré une
feuille, on doit remonter dans l’arbre. Pour cela soit on utilise une pile pour empiler en
descendant et désempiler en remontant (instruction Push et Pop du script), soit le système gère
lui-même une pile par le biais de l’utilisation de la récursivité (clause Localvisibility d’un règle
de script). La différence entre un parcours en préordre (top-down) et un parcours en postordre
(bottom-up) est l’emplacement du traitement de la feuille: traitement de la feuille puis parcours
de la sous-arborescence pour le préordre et l’inverse pour le postordre.
Les différents algorithmes de parcours du modèle MCSE vont donc se différencier par
l’emplacement des appels des règles de génération et l’utilisation d’une pile implicite
(LocalVisibility) ou explicite (Push et Pop).
L’algorithme du parcours du type TopDown est décrit ci-après sous forme script.
TopDownAnalyzeStructuralDescription:: {
AnalyzeComponentModelOrInstance;
ComponentDef:=ComponentModel.ComponentDefList;
/* we assume that the first model is the model of the current configuration */
TmpType:=TypeOf(ComponentDef);
Case(TmpType='StructureDef' :
OptRelationDescriptions:=ComponentDef.StructureDef.RelationDeclarations;
ForEach(OptRelationDescriptions : RelationLinks(OptRelationDescriptions);
CurrentRelation:=OptRelationDescriptions;
AnalyzeRelationElement;);
StructureDescription:=ComponentDef.StructureDef.StructureDescription;
ForEach(StructureDescription :
TmpType:=TypeOf(StructureDescription);
Case (TmpType = 'ComponentDescription' :
ComponentModel:=StructureDescription.ComponentDescription;
ComponentInstance:=Nil;
| Else :
ComponentInstance:=StructureDescription.ComponentInstanceDeclaration;
ComponentModel:=FindModel(ComponentInstance,1););
Name
<Component>
StructureDef
ComponentDescription
*ComponentDeclaration
<EndComponent>
ComponentDef
<Structure>
ComponentModels
1:n interface
":"
<ComponentInstance>
Name
Name
1:1
0:n
Name
OptAttributes
<ComponentModels>
0:1
<End....Models>
StructureDescription
1:n
1:1
*ComponentDescription
ComponentInstance
Declaration
<EndStructure>
RelationDeclarations
";"
Range
ComponentInstance
Range
Interface
OptAttributes
ComponentDefList
OptComponentModels
Component-
DeclarationList
BehaviorDef
<From>
ComponentDeclaration
ComponentInclude
<IncludeComponent>
Name
";"
Name
1:1
utilsation de la primitive
FindModel
utilsation de la primitive
IncludeComponent
Le Générateur VHDL
M.C.S.E 185
TopDownAnalyzeStructuralDescription;);
| Else : InternalRelationsList:=ComponentDef.BehaviorDef.InternalRelationsList;
ForEach(InternalRelationsList : RelationLinks(InternalRelationsList);
CurrentRelation:=InternalRelationsList;
AnalyzeInternalRelationElement;);
BehaviorInstance:=ComponentDef.BehaviorDef.BehaviorDefinition;
AnalyzeBehavioralDescription;
);
}
L’algorithme du parcours du type BottomUp est le suivant.
Le contenu de la variable ComponentModel (pile) pour l’exemple précédent est représenté
sur la droite de l’algorithme.
L’algorithme mixte se déduit facilement des deux autres. La génération se passe en deux
phases: une phase de déclaration lors du parcours descendant et une phase de mise à jour lors
du parcours remontant.
AnalyzeStructuralDescription:: {
AnalyzeComponentModelOrInstance;
ComponentDef:=ComponentModel.ComponentDefList;
TmpType:=TypeOf(ComponentDef);
Case(TmpType='StructureDef' :
OptRelationDescriptions:=ComponentDef.StructureDef.RelationDeclarations;
ForEach(OptRelationDescriptions : RelationLinks(OptRelationDescriptions);
CurrentRelation:=OptRelationDescriptions;
AnalyzeRelationElement;);
StructureDescription:=ComponentDef.StructureDef.StructureDescription;
ForEach(StructureDescription :
Push(ComponentModel);Push(CompnentInstance);Push(PathLevel);
TmpType:=TypeOf(StructureDescription);
Case (TmpType = 'ComponentDescription' :
ComponentModel:=StructureDescription.ComponentDescription;
ComponentInstance:=Nil;
PathLevel:=PathLevel&FileSeparator&ComponentModel.Name;
| Else :
ComponentInstance:=StructureDescription.ComponentInstanceDeclaration;
ComponentModel:=FindModel(ComponentInstance,0););
TmpType:=TypeOf(ComponentModel);
Case (TmpType = 'ComponentInclude' :
PathLevel:=GetLibraryPath(ComponentModel.ComponentInclude);
ComponentModel:=IncludeComponent(ComponentMode.ComponentIncludel););
PathLevel:=PathLevel&FileSeparator&ComponentInstance.Name;);
AnalyzeStructuralDescription;
UpdateComponentModel;
Pop(ComponentModel);Pop(ComponentInstance);Pop(PathLevel);
);
BottomUpAnalyzeStructuralDescription:: {
ComponentDef:=ComponentModel.ComponentDefList;
TmpType:=TypeOf(ComponentDef);
Case(TmpType='StructureDef' :
OptRelationDescriptions:=ComponentDef.StructureDef.RelationDeclarations;
ForEach(OptRelationDescriptions : RelationLinks(OptRelationDescriptions););
StructureDescription:=ComponentDef.StructureDef.StructureDescription;
ForEach(StructureDescription :
Push(ComponentModel);
Push(ComponentInstance);
TmpType:=TypeOf(StructureDescription);
Case (TmpType = 'ComponentDescription' :
ComponentModel:=StructureDescription.ComponentDescription;
ComponentInstance:=Nil;
| Else :
ComponentInstance:=StructureDescription.ComponentInstanceDeclaration;
ComponentModel:=FindModel(ComponentInstance,1);
);
BottomUpAnalyzeStructuralDescription;
Pop(ComponentModel);
Pop(ComponentInstance);
);
AnalyzeComponentModelOrInstance;
OptRelationDescriptions:=ComponentModel.ComponentDefList.StructureDef.RelationDeclarations;
ForEach(OptRelationDescriptions : CurrentRelation:=OptRelationDescriptions;
AnalyzeRelationElement;);
| Else : InternalRelationsList:=ComponentDef.BehaviorDef.InternalRelationsList;
ForEach(InternalRelationsList : RelationLinks(InternalRelationsList);
CurrentRelation:=InternalRelationsList;
AnalyzeInternalRelationElement;);
AnalyzeComponentModelOrInstance;
BehaviorInstance:=ComponentDef.BehaviorDef.BehaviorDefinition;
AnalyzeBehavioralDescription;
);
}
F F1 F12
F F1 F11
F F1
F F2
F F1
F
F
Chapitre 6
186 M.C.S.E
OptRelationDescriptions:=ComponentModel.ComponentDefList.StructureDef.RelationDeclarations;
ForEach(OptRelationDescriptions : CurrentRelation:=OptRelationDescriptions;
UpdateRelationElement;);
| Else : InternalRelationsList:=ComponentDef.BehaviorDef.InternalRelationsList;
ForEach(InternalRelationsList : RelationLinks(InternalRelationsList);
CurrentRelation:=InternalRelationsList;
AnalyzeInternalRelationElement;);
BehaviorInstance:=ComponentDef.BehaviorDef.BehaviorDefinition;
AnalyzeBehavioralDescription;
);
}
Les algorithmes précédents utilisent des instructions du script qui sont spécifiques au
modèle MCSE (mots en italiques):
- IncludeComponent importe un composant défini dans une librairie.
- RelationLinks met à jour une association bidirectionnelle entre l’élément de relation
et les interfaces de composants qui lui sont directement ou indirectement rattachées.
- FindModel retourne la description interne du modèle d’une instance.
Ils font tous appel à trois autres règles de script:
- AnalyzeComponentModelOrInstance pour l’analyse d’un élément actif,
- AnalyzeRelationElement pour l’analyse d’un élément de relation,
- AnalyzeInternalRelationElement pour l’analyse d’un élément de relation interne
défini dans le modèle de comportement d’un élément actif.
-C- Analyse d’un élément actif
L’interface d’un composant comprend sa dimension (Range), les paramètres génériques
(GenericParameters) et la définition des entrées et sorties du composant et le type de chacune.
Le type et la valeur par défaut des paramètres génériques utilisés dans la description d’un
système sont définis dans une liste située à la racine de la structure de données du modèle
MCSE. Ces définitions s’accompagnent d’un message d’information concernant le rôle joué
par le paramètre générique défini. Le modèle de structure pour la déclaration des paramètres
génériques est le suivant.
-Figure 6.7- Structure de données pour la déclaration des paramètres génériques.
L’algorithme d’analyse des paramètres génériques qui exploite la structure de données cidessus
est le suivant.
AnalyzeGenericParameters :: {
GenericParameterDeclatationList:=McseDs.FunctionalDescription.GenericParametersDeclaration.
GenericParameterDeclarationList;
Case(OptGenericParameters # Nil :
ParameterName:=OptGenericParameters.Name;
FindGenericParameterDeclaration;
Case(GenericParameterDeclatation=Nil :
Error('Generic Parameter '&ParameterName&' not defined');
| Else : GenericParameterType:=TypeOf(GenericParameterDeclatation.FloatOrInteger);
GenericParameterDefaultValue:=GenericParameterDeclatation.IntegerOrReal;
GenerateFirstGenericParameter;);
GenericParameterDeclarationList
Name ";"
0:n
GenericParameterDeclaration
<GenericParameters> <EndGenericParameters>
GenericParametersDeclaration
","
","
","
1:1
"FLOAT" "INTEGER"
IntegerOrReal
Comment
Le Générateur VHDL
M.C.S.E 187
NameList:=OptGenericParameters.NameList;
ForEach(NameList : ParameterName:=NameList.Name;
FindGenericParameterDeclaration;
Case(GenericParameterDeclatation=Nil :
Error('Generic Parameter '&ParameterName&' not defined');
| Else : GenericParameterType:=TypeOf(GenericParameterDeclatation.FloatOrInteger);
GenericParameterDefaultValue:=GenericParameterDeclatation.IntegerOrReal;
GenerateOneGenericParameter;);
);
| Else :
GenerateNoGenericParameters;
);
}
avec
FindGenericParameterDeclaration :: {
GenericParameterDeclatation:=Nil;
While ((GenericParameterDeclatationList # Nil AND
GenericParameterDeclatation=Nil) :
Case(GenericParameterDeclatationList.Name = ParameterName :
GenericParameterDeclatation:=
GenericParameterDeclatationList;
| Else :
GenericParameterDeclatationList:=
GenericParameterDeclatationList.nextFriend;);
);
}
Lorsqu’il n’y a pas de paramètres génériques, il faut détruire si nécessaire la construction
correspondante dans la structure de données cible (clause générique d’une entité VHDL par
exemple). Sinon pour chaque paramètre générique, on recherche son type et sa valeur par
défaut.
L’analyse de l’interface d’un composant doit tenir compte des différents cas de
l’instanciation multiple.
On utilise pour cela deux indicateurs:
- BlackBall indique que l’élément d’interconnexion associé à l’entrée/sortie analysée
doit être de dimension 2 (un vecteur de vecteur par exemple),
- Vector indique que l’élément d’interconnexion doit être de dimension 1 (un vecteur
par exemple).
La figure suivante montre le méta-modèle pour la définition de l’interface.
-Figure 6.8- Structure de données de la grammaire pour la déclaration de l’interface.
"["
Range
"]"
";"
1:1
InputOutput
OptGenericParameters
0:1
Name
0:n
"Generic"
Name
","
0:1
DefRange
Integer
":"
Indice
*Indice
Name
"(" 0:n
")"
";"
InputOutput
":"
"Mess"
1:1 ParameterDef
IOType
"In"
"Out"
"InOut"
"Var"
"Node""
TypedParameter
"Ev"
UntypedParameter
1:1
Name
Name
ElementName
0:1
Index
GenericParameters
NameList
NextName
1:1
IndexRange
":"
Interface
1:1
Range
TypeRelation
Chapitre 6
188 M.C.S.E
Les différents cas possibles de l’instanciation multiple des fonctions et des éléments de
relation sont représentés dans le tableau suivant (voir chapitre 3).
-Figure 6.9- Les différents cas de l’instanciation multiple.
L’algorithme d’analyse d’un élément actif est donc le suivant.
AnalyzeComponentModelOrInstance :: {
LocalVisibility NbTask;
NbTask:=0;
InterfaceModel:=ComponentModel.Interface;
Case (ComponentInstance # Nil :
ComponentName:=ComponentInstance.Name;
Range:=ComponentInstance.Range;
InterfaceInstance:=ComponentInstance.Interface;
GetAttributes(ComponentInstance,AttributesList);
| Else : ComponentName:=ComponentModel.Name;
Range:=ComponentModel.Range;
InterfaceInstance:=ComponentModel.Interface;
GetAttributes(ComponentModel,AttributesList););
GetRangeExpression;
ComponentRangeExpression:=RangeExpression;
ComponentMultiple:=MultipleComponent;
GenerateComponentFromNameAndRange;
OptGenericParameters:=InterfaceInstance.OptGenericParameters;
AnalyzeGenericParameters;
CurrentInputOutputModel:=InterfaceModel.InputOutputList;
InputOutput:=InterfaceInstance.InputOutputList;
GenerateBeginInterface;
ForEach(InputOutput :
AnalyzeInputOutputInterface;
CurrentInputOutputModel:=CurrentInputOutputModel.nextFriend;);
GenerateEndInterface;
}
avec
AnalyzeInputOutputInterface :: {
Vector:=0;
BlackBall:=0;
TmpType:=TypeOf(InputOutput.ParameterDef);
Case(TmpType = 'TypedParameter' :
ParameterName:=InputOutput.ParameterDef.TypedParameter.ElementName.Name;
ParameterModelName:=CurrentInputOutputModel.ParameterDef.TypedParameter.ElementName.Name;
TypeName:=InputOutput.ParameterDef.TypedParameter.Name;
F[1:n]
Pt[1:n]
N -> N
F[1:n]
Pt
N -> 1
F1
Pt[1:n]
1 -> N
F[1:k]
Pt[1:m]
K -> M
La Fonction F1 peut utiliser l’un quelconque des ports
du vecteur Pt[1:n] en le désignant par son indice (utilisation
de l’attribut ‘Path pour la sélection)
Chaque fonction F[i] peut accéder à tous les éléments
du vecteur Pt[1:m] (attribut ‘Id pour désigner la source
et attribut ‘Path pour la destination). La valeur par
défaut de l’attribut ‘Id est la valeur ‘me représentant
l’indice courant de la fonction.
Toutes les fonctions F[i] exploitent le port Pt en respectant
son degré de partage.
Il y a correspondance indice par indice.
Graphique IO Range Observations
Black
Ball Vector
0 0
0 0
0 1
1 _
[ : ]
[ : ]
[ ]
Null
Le Générateur VHDL
M.C.S.E 189
ParameterType:=TypeOf(InputOutput.ParameterDef.TypedParameter.TypeRelation);
Range:=InputOutput.ParameterDef.TypedParameter.ElementName.Range;
| Else : ParameterName:=InputOutput.ParameterDef.UntypedParameter.ElementName.Name;
ParameterModelName:=CurrentInputOutputModel.ParameterDef.UntypedParameter.ElementName.Name;
TypeName:=Null;
ParameterType:=TypeOf(InputOutput.ParameterDef.UntypedParameter.Ev);
Range:=InputOutput.ParameterDef.UntypedParameter.ElementName.Range;);
GetRangeExpression;
Case (RangeExpression # Null : /* Null si Range=[] */
Vector:=1;
BlackBall:=ComponentMultiple;
RelationalElement:=FindRelationalElement(InputOutput);
TmpType:=TypeOf(RelationalElement);
Case(TmpType='EvDescription' :
Range:=RelationalElement.EvDescription.Range;
| Else : Range:=RelationalElement.PortDescription.TypedRelationDef.Range;);
GetRangeExpression;
VectorExpression:=RangeExpression;
| Else : VectorExpression:=ComponentRangeExpression;);
FindNumberOfAccessInLevel;
TmpType:=TypeOf(InputOutput.IOType);
Case (TmpType = 'In' : IsInput:=1;
| TmpType = ’InOut’ : IsInput:=2;
| Else : IsInput:=0;);
GenerateFromInputOutput;
}
Les informations mises à disposition de la règle de génération d’un élément actif sont: sa
dimension, son nom et sa liste d’attributs. Pour la génération de chaque interface du composant,
on fournit également le nom de l’interface, son type, le type de la donnée, la dimension de
l’élément de relation qui lui est associé, le nombre d’interfaces du raffinement du composant
qui lui sont associés et les indicateurs Vector, BlackBall et IsInput.
-D- Analyse d’un élément de relation
Les composants sont couplés entre eux par l’intermédiaire d’éléments de relation. Ils sont
de 3 types pour la structure fonctionnelle (Evénement, Variable partagée, Port) et de 3 types
pour la structure d’exécution (Signal, Mémoire commune, Noeud de communication). Les 2
premiers types sont identiques pour les 2 structures. Pour la simplification, on a conservé
uniquement les noms Ev et Var. On ne traitera pas ici le problème du raffinement des éléments
de relation.
Le méta-modèle pour la définition d’un élément de relation est donné par la figure suivante.
-Figure 6.10- Structure de données de la grammaire pour la déclaration d’un élément de
relation.
Pour gérer le problème de la traçabilité des liens entre éléments de relation et interfaces de
composants, on utilise un lien bidirectionnel implanté dans la structure de données à l’aide de
deux références (LinkUp et LinkDown). La mise à jour de cette association bidirectionnelle se
fait par l’instruction RelationLinks qui s’applique sur un élément de relation ou l’interface
<Port> ou <Var> ou <Node>
Var ou Port ou Node 1:1
Description
TypedRelationDef
<Ev>
":"
Name
*Range
OptAttributes
";"
Range OptAttributes
";"
RelationDescription
Name
Name 0:1
Attributes
0:n
RelationDeclarations
RelationInstance
EvDescription
<PortInstance> ou
":" Name
*Range
";"
Name
<VarInstance> ou
<NodeInstance> ou
Interface
<EvInstance> OptAttributes
Chapitre 6
190 M.C.S.E
d’un composant. Après exécution de cette instruction, le champ LinkUp référence l’élément de
relation ou l’interface de niveau supérieur. Le lien LinkDown référence un vecteur contenant
les références de toutes les interfaces du niveau associées à l’élément concerné.
La figure ci-dessous illustre cette association bidirectionnelle dans le cas de l’exemple du
début de chapitre.
-Figure 6.11- Liens entre éléments de relation et interfaces de composants.
La règle d’analyse d’un élément de relation est la suivante.
AnalyzeRelationElement:: {
TmpType:=TypeOf(CurrentRelation);
Case((TmpType='PortDescription' OR TmpType='NodeDescription'):
RelationType:='Port';TypedRelationDef: = CurrentRelation.PortDescription.TypedRelationDef;
Range:=TypedRelationDef.Range;Name:=TypedRelationDef.Name;
| TmpType = 'VarDescription' :
RelationType:='Var';
TypedRelationDef: = CurrentRelation.VarDescription.TypedRelationDef;Range:=TypedRelationDef.Range;
Name:=TypedRelationDef.Name;
| TmpType = 'EvDescription' :
RelationType:='Ev';Range:=CurrentRelation.EvDescription.Range;
Name:=CurrentRelation.EvDescription.Name;);
GetRangeExpression;
ElementRangeExpression:=RangeExpression;
ElementMultiple:=MultipleComponent;
FindNumberOfAccessInLevel;
GetAttributes(CurrentRelation,AttributesList);
GenerateFromRelationElement;
}
Les informations mises à disposition de la règle de génération d’un élément de relation sont
le type de l’élément (Port, Var, Ev), sa dimension, son nom, sa liste d’attributs, le nombre
d’interfaces du niveau et le nombre total d’interfaces du système rattachées à l’élément.
L’analyse d’un élément de relation interne d’une description comportementale est à
rapprocher de celle d’un élément de relation d’une structure fonctionnelle ou exécutive.
Contrairement au modèle structurel, le modèle comportemental n’est pas forcément
complètement hiérarchique. Un élément de relation interne peut en effet être relié à une
interface d’instance d’une activité ou directement sur une condition d’évolution ou une action.
L’instruction RelationLinks crée donc une association bidirectionnelle entre l’élément de
relation interne et l’interface de l’activité ou le champ ElementName associé à une condition
d’évolution ou une action. On utilise ce champ ElementName car une condition d’évolution ou
une action peut être simple ou composée. Les instructions FindRelationElement et
FindInternalRelationElement devront donc être appliquées sur le champ ElementName d’une
condition ou d’une action pour retrouver l’élément de relation associé à cette condition ou
action.
F1
F11
F12
V
F2
F
V
IOF2 IOF1
IOF11 IOF12
LinkUp
LinkDown
LinkUp
LinkUp
Nil
Nil Nil
Nil
LinkDown
RelationLinks(V)
Le Générateur VHDL
M.C.S.E 191
6.4.2 Parcours du modèle comportemental
La vue comportementale permet de décrire le comportement des fonctions. Le modèle de
comportement repose sur:
- des activités dynamiques décomposables (raffinement) ou élémentaire (algorithme ou
temps d’exécution),
- des opérateurs de composition d’activités (séquence, parallélisme, alternative,
répétition et attente conditionnelle),
- des opérateurs de construction de condition (attente sur une entrée),
- des opérateurs de construction d’action (génération d’une sortie) et des attributs pour
paramétrer le modèle.
Contrairement au modèle structurel, le modèle comportemental est plus riche en concepts
et n’est pas strictement hiérarchique, ce qui ne facilite son analyse. Dans le chapitre 4 sur les
règles de transcription, nous avons également vu que les règles de transcription sont plus
complexes pour la composante comportementale du modèle de performance de MCSE.
La figure 6.12 représente la représentation graphique du modèle de comportement d’un
exemple, sa description textuelle équivalente et le modèle graphique de la structure de données
obtenue à partir de l’analyse de la description textuelle.
Le modèle de comportement décrit un mécanisme de requête/acquittement. Après une
opération Op0 représentant des opérations d’initialisation, une première requête est envoyée
via le port de communication Req. Comme le suggère la boucle infinie, cette initialisation n’est
effectuée qu’une seule fois lors de la création (ou instanciation) de l’activité Proc. Cette activité
a alors une durée de vie illimitée.
La description du comportement se poursuit avec un parallélisme à deux branches. Ce
parallélisme peut éventuellement être englobé dans une activité nommée ici Activity1. Dans ce
cas, l’activité Activity1 est déclarée comme un modèle d’activité nommé Activity1Model dans
la liste ActivityUnitList (partie en pointillé des figures) et comme une instance de ce modèle
au niveau du comportement de l’activité Proc. Le parallélisme tel qu’il est décrit permet
d’occuper la ressource d’exécution (opération Op1) même si l’activité Proc est en attente de
l’acquittement (attente de message provenant du port de communication Ack). Après avoir
reçu l’acquittement, la branche de gauche signale (signalisation ready) à la branche de droite
qu’elle peut envoyer une nouvelle requête.
Lorsque l’on regarde la représentation graphique et textuelle de l’exemple, on pense a priori
que la difficulté va être d’extraire les séquences d’opérations (zones hachurées) qui seront
générées sous forme de process (VHDL) ou de tâches (C/ETR, ADA) ou de thread (Java). En
réalité, grâce à une bonne méta-modélisation du modèle comportemental, ce travail est fait
implicitement par l’analyseur syntaxique. En effet, chaque séquence est une branche de la
structure de données chargée dont la racine est du type ActivitySequence.
Chapitre 6
192 M.C.S.E
-Figure 6.12- Exemple de modèle comportemental avec sa structure de données.
BehaviorDef
Activity1Model
BehaviorDefinition
BehaviorInstance
0:n
1:n
0:n
Proc
InternalEvDeclaration
Attributes
ActivityDescription
InternalRelationsList
ActivityUnitList
Ready
AttributeValue
0:n
Attributes
ListAttributeValue
Integer
AttributeName TimeUnit
Op0 Time
100
us
0:n
DefP
<Mess>
Interface
Ack
<In>
InputOutput
DefP
<Mess>
Req
<In>
InputOutput
Op1’Time= 20 us
Op2’Time=1 us
BehaviorInstance
1:n
Activity1
1:n
ActivitySequence
SeqActivityList
"&"
ParActivity
1:n
ConcurrentActivity
ParActivityList
"||"
Op2
SeqActivity
"&"
"?"
Ack
Proc
SeqActivity
1:n
ActivitySequence
SeqActivityList
"&"
Actions
Op0
SeqActivity
"&"
"!"
Req
RepeatedActivity
"*"
Interface
Activity1 Activity1Model
ActivityInstance
SeqActivity
1:n
ActivitySequence
SeqActivityList
"&"
Actions
Op1
SeqActivity
"&"
"!"
Req
Actions
"!"
Ready
"?"
Ready
Condition
Condition
BehaviorDefinition
Op0
*
Ack
Req
Proc
&
Op1
Op2
Ready
Activity1
Ack
Op0’Time= 100 us
Op1’Time= 20 us
Op2’Time= 1 us
Proc :: Op0&!Req&{Activity1}*
Activity1 :: (?Ack&Op2&!Ready) ||
(Op1&?Ready&!Req)
Texte
Structure de données
Le Générateur VHDL
M.C.S.E 193
L’algorithme de parcours du modèle comportemental se déduit de l’analyse du métamodèle
de structure de données pour la description des activités dont la représentation
graphique est donnée ci-dessous.
-Figure 6.13- Méta-modèle pour la description des activités.
Cette représentation graphique fait clairement apparaître un rebouclage entre les noeuds de
composition d’activités (ActivitySequence, ConcurrentActivity, MultipleActivity,
AlternativeActivity, et AlternateConditionalActivity) et le noeud Activity. Il y a également un
bouclage entre les noeuds Activity, RepeatedActivity et ActivityDef. Par conséquent,
l’algorithme de parcours est un algorithme itératif utilisant une pile ou un algorithme récursif.
Pour faciliter la lisibilité et la compréhension du programme, il est préférable de définir une
règle de script pour l’analyse de chaque type de noeud. L’algorithme de parcours du modèle
comportemental ainsi obtenu comporte une récursivité indirecte et se compose de l’ensemble
des règles suivantes:
SeqActivity
1:n
ActivitySequence
Activity
SeqActivityList
ActivityDef
1:1
AlternativeActivity
"&"
Activity
ParActivity
1:n
ConcurrentActivity
Activity
ParActivityList
"||" Activity
"<"
ExpressionCondition
">"
Activity
CondActivity
1:n
CondActivityList
LastCondActivity
0:1
OptLastCondActivity
"<*>"
Activity
RepeatedActivity
"{"
ActivityDef
"}"
"*" 1:1
LoopDef
"*"
Expression
"/"
Expression
"="
Condition
AlternateConditionalActivity
"["
GuardedCondition
"("
BehaviorCondition
"|"
*GuardedCondition
"&" Activity
0:n
Activity
"><"
ActivityName
NestedActivity
"("
*ActivityDef
")" Behavior
"?"
"!" Actions
1:1
Expression
Condition
"="
1:1
Expression
"<>"
"<" ">"
"<="
">="
MultExpression DivExpression
CondExpression
GuardedConditionList
NextGuardedCondition
ActivityInstance
<ActivityInstance>
Range
Interface
Name ":"
Name
"]"
"?"
")"
1:1
Expression
ComparisonOp
BehaviorDef
ActivityUnit
<Behavior>
Name
<ActivityUnit>
<EndActivity>
*Behavior
Name
"::"
BehaviorDefinition
BehaviorInstance
0:n
1:n
0:n
Interface
<EndBehavior>
Name
Internal
";"
OptAttributes
Relations
";"
1:1
IncludeActivity
OptAttributes
Definition
ActivityDescription
InternalRelationsList
ActivityUnitList
Condition
Chapitre 6
194 M.C.S.E
- AnalyzeAlternateActivity pour l’analyse de l’alternative,
- AnalyzeRepeatedActivity pour l’analyse de l’itération,
- AnalyzeConcurrentActivity pour l’analyse du parallélisme,
- AnalyzeActivitySequence pour l’analyse de la séquence,
- AnalyzeAlternateConditionalActivity pour l’analyse de l’attente conditionnelle,
- AnalyzeActivity et AnalyzeActivityDef pour l’analyse d’une activité composée,
- AnalyzeActivityName pour l’analyse d’une activité élémentaire,
- AnalyzeBehaviorCondition pour l’analyse d’une condition d’attente,
- AnalyzeActions pour l’analyse d’une génération de sortie,
- AnalyzeActivityInstance pour l’analyse d’une instance d’activité.
A titre d’exemple, le code script de certaines de ces règles d’analyse est donné dans les
paragraphes suivants. Les mots en italiques représentent les noms de règles de génération de la
structure de données de sortie appelées lors de l’analyse du modèle source. Les mots en gras
sont des appels aux règles de la partie Analyse du Script.
-A- Analyse du parallélisme
AnalyzeConcurrentActivity :: {
LocalVisibility ParActivityList,Activity,NbTask;
Activity:=ConcurrentActivity.Activity;
GenerateBeginTaskSynchronisation;
AnalyzeActivity;
GenerateEndTaskSynchronisation;
ParActivityList:=ConcurrentActivity.ParActivityList;
ForEach(ParActivityList : NbTask:=ValueOf(NbTask) + 1;
GenerateFromParActivity; /* create new process or task */
GenerateBeginTaskSynchronisation;
Activity:=ParActivityList.Activity;
AnalyzeActivity;
GenerateEndTaskSynchronisation;
);
}
La séparation de la première des N branches d’une concurrence permet de continuer la
description de cette branche dans la séquence en cours et d’obtenir une traduction en N-1
tâches. La traduction nécessite la création/instanciation de tâches et l’utilisation de mécanismes
de synchronisation surtout si la création des tâches ne peut être dynamique comme c’est le cas
pour VHDL.
-B- Analyse d’une activité simple
Un nom d’activité peut représenter une activité élémentaire ou un découpage de l’activité
analysée défini dans l’ensemble BehaviorDefinition d’où la règle suivante.
AnalyzeActivityName :: {
ElementName:=Activity.ActivityName.ElementName;
Name:=ElementName.Name;
ActivityDef:=FindActivityDescription(Activity.ActivityName);
Case (ActivityDef = Nil :
Case (ForPerformanceEvualation = 'YES' :
TmpType:=TypeOf(ElementName.superFather.BehaviorDef);
Case(TmpType = 'ActivityDescription' :
Attributes:=ElementName.superFather.ActivityDescription.OptAttributes;
ComponentAttributes:=Nil;
| Else :
BehaviorDef:=ElementName.superFather.BehaviorDef;
Attributes:=BehaviorDef.OptAttributes;
ComponentAttributes:=BehaviorDef.superFather.ComponentDescription.OptAttributes;
);
SearchAttributeDesignator:='Time';
Case(Attributes # Nil : FindAttributeValue;);
Case ((Expression=Nil AND ComponentAttributes#Nil) :
Attributes:=ComponentAttributes;
FindAttributeValue;
);
Case(Expression=Nil : Error('Attribut Time not defined for '&Name);
| Else : GenerateElementaryActivity;
);
| Else : FileName:=PathLevel&FileSeparator&Name&SuffixFile;
Le Générateur VHDL
M.C.S.E 195
FileInclude:=IncludeOp(FileName,1);
GenerateFromIncludeFile;
);
| Else : AnalyzeActivityDef;
);
}
avec
FindAttributeValue :: {
AttributeValue:=Attributes.ListAttributeValue;
Expression:=Nil;TimeUnit:=Nil;
While ((AttributeValue#Nil AND Expression=Nil) :
AttributeDesignator:=AttributeValue.AttributeName.AttributeDesignator;
TmpType:=TypeOf(AttributeDesignator);
Case ((TmpType = SearchAttributeDesignator AND
AttributeValue.AttributeName.OptElementName.Name=Name):
Expression:=AttributeValue.Expression;
TimeUnit:=TypeOf(AttributeValue.OptTimeUnit);
| Else : AttributeValue:=AttributeValue.nextFriend;
);
);
}
L’instruction prédéfinie FindActivityDescription recherche la description interne d’une
activité dans l’ensemble BehaviorDefinition de la description comportementale de l’élément
actif concerné. Si la recherche échoue, l’activité est une activité élémentaire. Il faut alors
retrouver l’attribut ‘Time pour une évaluation des performances ou inclure le code de
l’algorithme pour une simulation interprétée ou une synthèse.
-C- Analyse d’une condition d’évolution
Une condition d’évolution s’élabore à partir des entrées de l’activité ou de la fonction et des
éléments de relation internes à la description comportementale. Les opérateurs de composition
sont le ET séquentiel (&) qui impose une relation d’ordre strict d’apparition, le ET logique (^)
sans ordre d’apparition, le OU logique (!) et la sélection ($).
Le méta-modèle de structure de données pour la description des conditions d’évolution est
le suivant.
-Figure 6.14- Structure de données de la grammaire pour les conditions.
Pour réutiliser ce qui a été fait du point de vue de l’analyse et de la génération pour le
parallélisme et l’attente conditionnelle, il est préférable de convertir le ET sans ordre sous la
OrderElements
1:n
SubOrderList
1:1
SelectName
OrderElements
NoOrderElements
ChoiceElements
"&"
ElementName
BehaviorCondition
"$" ElementName
1:1
NoOrderElements
1:n
SubNoOrderList
"^"
ElementName
ChoiceElements
1:n
ChoiceElementsList
"|"
ElementName
"("
ElementName
1:1
OutputChoiceList
")"
InputElementNameList
Name
ElementName
Range
Chapitre 6
196 M.C.S.E
forme d’une concurrence et le OU logique sous la forme d’une attente conditionnelle comme
le montre la figure ci-dessous.
-Figure 6.15- Conversion du ET sans ordre et du OU logique.
Lorsque l’élément de composition de conditions ne comporte qu’un vecteur d’entrée, la
plupart des générateurs de code traduiront cette construction sous une forme particulière.
L’algorithme d’analyse d’une condition d’évolution distingue donc ce cas par rapport au
cas général. Le code script de l’algorithme est le suivant:
AnalyzeBehaviorCondition :: {
LocalVisibility ConcurrentActivity,AlternateConditionalActivity,GuardedCondition;
Vector:=0;
IsInput:=1;
TmpType:=TypeOf(BehaviorCondition);
Case(TmpType = 'ElementName' :
ElementName:=BehaviorCondition.ElementName;
AnalyzeInputOutputName;
| TmpType = 'InputElementNameList' :
InputChoiceList:=BehaviorCondition.InputElementNameList.InputChoiceList;
TmpType:=TypeOf(InputChoiceList);
Case(TmpType='OrderElements' :
SubOrderList:=InputChoiceList.OutputChoiceList.SubOrderList;
ElementName:=BehaviorCondition.InputElementNameList.ElementName;
AnalyzeInputOutputName;
ForEach(SubOrderList : ElementName:=SubOrderList.ElementName;
AnalyzeInputOutputName;
);
| TmpType = 'NoOrderElements' :
SubNoOrderList:=InputChoiceList.OutputChoiceList.SubNoOrderList;
ElementName:=BehaviorCondition.InputElementNameList.ElementName;
ConcurrentActivity:=CreateNode(Mcse,ConcurrentActivity);
ConditionalActivity:=CreateNode(Mcse,ConditionalActivity);
ConditionalActivity.BehaviorCondition.ElementName:=CopyDs(ElementName);
ConcurrentActivity.Activity.ConditionalActivity:=ConditionalActivity;
ForEach(SubNoOrderList : ElementName:=SubNoOrderList.ElementName;
ParActivity:=CreateNode(Mcse,ParActivity);
ConditionalActivity:=CreateNode(Mcse,ConditionalActivity);
ConditionalActivity.BehaviorCondition.ElementName:=CopyDs(ElementName);
ParActivity.Activity.ConditionalActivity:=ConditionalActivity;
AddLast(ConcurrentActivity.ParActivityList,ParActivity);
);
AnalyzeConcurrentActivity;
DelNode(ConcurrentActivity);
| TmpType = 'ChoiceElements' :
ChoiceElementsList:=InputChoiceList.ChoiceElementsList;
ElementName:=ChoiceElementsList.ElementName;
AlternateConditionalActivity:=CreateNode(Mcse,AlternateConditionalActivity);
GuardedCondition:=CreateNode(Mcse,GuardedCondition);
GuardedCondition.BehaviorCondition.ElementName:=ElementName;
AlternateConditionalActivity.GuardedCondition:=GuardedCondition;
ChoiceElementsList:=ChoiceElementsList.nextFriend;
ForEach(ChoiceElementsList : ElementName:=ChoiceElementsList.ElementName;
NextGuardedCondition:=CreateNode(Mcse,NextGuardedCondition);
NextGuardedCondition.GuardedCondition:=CopyDs(GuardedCondition);
NextGuardedCondition.GuardedCondition.BehaviorCondition.ElementName:=ElementName;
AddLast(AlternateConditionalActivity.GuardedConditionList,NextGuardedCondition);
);
AnalyzeAlternateConditionalActivity;
DelNode(AlternateConditionalActivity);
E1
E2
E1
E2
ET sans ordre L’un
^ OR
&
E1 E2 E1 E2
Le Générateur VHDL
M.C.S.E 197
);
| TmpType = 'SelectName' : ElementName:=BehaviorCondition.SelectName.ElementName;
Vector:=1;
AnalyzeInputOutputName;
| TmpType = 'OrderElements' : ElementName:=BehaviorCondition.OrderElements.ElementName;
GenerateFromNoOrderElementsVector;
| TmpType = 'NoOrderElements' : ElementName:=BehaviorCondition.NoOrderElements.ElementName;
GenerateFromOrderElementsVector;
| TmpType = 'ChoiceElements' : ElementName:=BehaviorCondition.ChoiceElements.ElementName;
GenerateFromChoiceElementsVector;
);
}
Pour une condition (ou une action), il faut également retrouver l’interface du composant ou
l’élément de relation interne correspondant. On utilise pour cela le champ LinkUp du record
ElementName associé à la condition.
AnalyzeInputOutputName :: {
TmpType:=TypeOf(ElementName.linkUp.InputOutput);
Case(TmpType = 'InputOutput' : InputOutput:=ElementName.linkUp.InputOutput;
GetAttributes(InputOutput,AttributesList);
BlackBall:=0;
TmpType:=TypeOf(InputOutput.ParameterDef);
Case(TmpType = 'TypedParameter' :
ParameterName:=InputOutput.ParameterDef.TypedParameter.ElementName.Name;
ParameterType:=TypeOf(InputOutput.ParameterDef.TypedParameter.TypeRelation);
TypeName:=InputOutput.ParameterDef.TypedParameter.Name;
Range:=InputOutput.ParameterDef.TypedParameter.ElementName.Range;
| Else :
ParameterName:=InputOutput.ParameterDef.UntypedParameter.ElementName.Name;
ParameterType:='Ev';
TypeName:=Null;
Range:=InputOutput.ParameterDef.UntypedParameter.ElementName.Range;
);
| Else : InternalRelations:=ElementName.linkUp.InternalRelations;
GetAttributes(InternalRelations,AttributesList);
TmpType:= TypeOf(InternalRelations);
Case(TmpType='InternalInfoDeclaration':
TypedRelationDef:=InternalRelations.InternalInfoDeclaration .TypedRelationDef;
ParameterType:='Mess';
Range:=TypedRelationDef.Range;
ParameterName:=TypedRelationDef.Name;
TypeName:=TypedRelationDef.SecondName;
| TmpType = 'InternalDataDeclaration' :
TypedRelationDef: = InternalRelations.InternalDataDeclaration.TypedRelationDef;
ParameterType:='Var';
Range:=TypedRelationDef.Range;
ParameterName:=TypedRelationDef.Name;
TypeName:=TypedRelationDef.SecondName;
| TmpType = 'InternalEvDeclaration' :
Range:=InternalRelations.InternalEvDeclaration.Range;
ParameterName:=InternalRelations.InternalEvDeclaration.Name;
ParameterType:='Ev';
TypeName:=Null;
);
);
GetRangeExpression;
Case (RangeExpression # Null :
BlackBall:=MultipleComponent;
);
GenerateFromInputOutputName;
}
Les informations mises à disposition pour la génération d’une condition d’évolution simple
sont: son nom, son type, le type de la donnée transmise, la dimension de l’interface ou de
l’élément de relation qui lui sont rattachés, ses attributs et l’indicateur BlackBall utilisé pour
l’instanciation multiple.
-D- Analyse d’une action
Les actions concernent la génération d’informations ou d’événements par les sorties du
composant contenant l’activité ou vers d’autres activités internes au composant par
l’intermédiaire d’éléments de relation internes à la description comportementale. Les
opérateurs de composition d’actions sont la séquence qui fixe l’ordre de génération, la
simultanéité, l’alternative qui discerne une des sorties en fonction d’une condition ou d’une
Chapitre 6
198 M.C.S.E
probabilité et la sélection. Le méta-modèle de structure de données pour la description des
actions est le suivant.
-Figure 6.16- Structure de données de la grammaire pour les actions.
Comme pour les conditions d’évolution, on transforme la simultanéité et l’alternative
comme indiqué ci-dessous.
-Figure 6.17- Conversion de la simultanéité et de l’alternative.
L’algorithme d’analyse d’une action se déduit facilement par dualité de celui d’une
condition d’évolution.
6.4.3 Test de la partie analyse du script
La partie analyse du modèle source est essentielle car elle conditionne la partie génération
et donc influe directement sur l’efficacité et la qualité d’implantation du générateur. La
difficulté repose ici sur la sélection des informations pertinentes pour la génération et le choix
de l’emplacement des appels des règles de génération.
Comme le modèle MCSE sera la source pour d’autres générateurs de code, nous avons
essayé d’implanter une partie analyse suffisamment générique pour qu’elle soit commune à
tous les générateurs de code du modèle MCSE vers un langage cible quelconque. De toute
façon, un concepteur de script pourra optimiser ou compléter cette base à sa guise. Ainsi, il peut
concentrer ses efforts sur les règles de la partie génération.
Cette partie d’Analyse a été testée avec l’exemple du serveur vidéo du chapitre 7. Dans ce
test, les règles de génération affichent uniquement les informations dont elles disposent.
ElementName 1:1 OrOutput
OutputElementNameList
SelectName
OrderElements
NoOrderElements
ChoiceElements
Action
OrOutputItem
1:n
"("
ElementName 1:1
OutputChoiceList
SubOrderList SubNoOrderList
")"
"(" ")"
ElementName
"<"
">"
ConditionExpression
OrOutputList
"|" ElementName
"<" ">"
ConditionExpression
S1
^
S2
S1
OR
S2
Alternative
Op&!(S1|S2)
Simultanéité
Op&!(S1^S2)
&
S1 S2 S1 S2
OR
Le Générateur VHDL
M.C.S.E 199
Le résultat partiel de ce test est présenté ci-dessous.
-Figure 6.18- Résultat partiel du test de la partie analyse du script.
La figure donne la liste des règles de génération appelées lors de l’analyse du modèle
MCSE source et des informations fournies à ces règles. Sur un Pentium 90, le test s’effectue
en 135 secondes en mode interprété et 28 en code java. Sur les 28 secondes, 18 sont utilisées
par l’analyseur lexical et l’analyseur syntaxique pour le chargement de la structure de données
de l’exemple à partir de sa description textuelle. L’algorithme de parcours du modèle MCSE
est donc relativement rapide (10 secondes). Pour le script du générateur de VHDL
comportemental, la partie analyse représente 31% (1020 lignes) du code total (3253 lignes).
6.5 PARTIE GENERATION DU SCRIPT
La partie génération représente la plus grosse partie du code (69%) car le langage VHDL
est un langage très déclaratif et aussi parce que nous avons décidé de garder la hiérarchie du
modèle source dans le modèle final (redondance d’information), ceci pour bien exploiter
VHDL et favoriser la réutilisation de modèles internes.
6.5.1 Règles de génération
Les règles de génération concernant la composante structurelle du modèle de performance
de MCSE sont définies dans le tableau suivant. Pour chaque règle, nous précisons les
informations qui lui sont fournies et les opérations effectuées pour la fonction de génération.
Règles de Génération appelées lors de l’analyse Opérations effectuées par le générateur VHDL
GenerateComponentFromNameAndRange
Informations fournies:
ComponentName
ComponentRangeExpression
ComponentMultiple, AttributesList
Si premier composant généré alors
mise à jour des noms de l’entité et du package et
leurs contextes
Sinon
création d’un block multiple et/ou simple
Si l’attribut ‘Concurrency est limité alors
instanciation d’un composant ordonnanceur et
déclaration des signaux associés
Loading McseModel...
Time use for loading McseModel: 18
PathLevel = ApplicationServeurVideo
GenerateComponentFromNameAndRange with
ComponentName = ApplicationServeurVideo
ComponentRangeExpression =
ComponentMultiple = 0
GenerateOneGenericParameter with
n:INTEGER=10
GenerateOneGenericParameter with
k:INTEGER=10
GenerateOneGenericParameter with
nd:INTEGER=10
GenerateOneGenericParameter with
TaccDisk:INTEGER=20
GenerateFromRelationElement with
RelationType = Port
Name = CmdUsager
ElementMultiple = 1
ElementRangeExpression = k
NumberOfInputAccessInLevel = 1
NumberOfOutputAccessInLevel = 1
NumberOfInputAccessInAllLevel = 2
NumberOfOutputAccessInAllLevel = 2
GenerateFromRelationElement with
RelationType = Port
Name = RepUsager
ElementMultiple = 1
ElementRangeExpression = k
NumberOfInputAccessInLevel = 1
NumberOfOutputAccessInLevel = 1
NumberOfInputAccessInAllLevel = 2
NumberOfOutputAccessInAllLevel = 3
GenerateFromRelationElement with
RelationType = Port
Name = SequenceIn
ElementMultiple = 1
ElementRangeExpression = n
NumberOfInputAccessInLevel = 1
NumberOfOutputAccessInLevel = 1
NumberOfInputAccessInAllLevel = 3
NumberOfOutputAccessInAllLevel = 2
AttributesList:
`Capacity=0
GenerateFromRelationElement with
RelationType = Port
Name = SequenceOut
ElementMultiple = 1
ElementRangeExpression = n
NumberOfInputAccessInLevel = 1
NumberOfOutputAccessInLevel = 1
NumberOfInputAccessInAllLevel = 2
NumberOfOutputAccessInAllLevel = 3
AttributesList:
`Capacity=0
PathLevel = ApplicationServeurVideo\Usagers
GenerateFromInputOutput with
ParameterType = Mess
ParameterName = RepUsager
TypeName = DefRepUsager
VectorExpression = k
Vector = 1
BlackBall = 0
IsInput = 1
NumberOfInputAccessInLevel = 1
NumberOfOutputAccessInLevel = 0 ...
Chapitre 6
200 M.C.S.E
Les règles de génération concernant la composante comportementale du modèle de
performance de MCSE sont données dans le tableau suivant.
GenerateFirstGenericParameter
informations fournies:
ParameterName, GenericParameterType
GenericParameterDefaultValue
Mise à jour de la clause générique de l’entité ou d’un
block.
GenerateOneGenericParameter Identique à GenerareFirstGenericParameter
GenerateNoGenericParameters Destruction de la clause générique
GenerateFromInputOutput
informations fournies:
ParameterType, ParameterName
ParameterModelName, TypeName
VectorExpression, Vector
BlackBall, IsInput, NumberOfIOSubLevel
Mise à jour du Port et Port Map de l’entité ou du block.
Déclaration ou mise à jour du type, signal et alias
associés à l’interface du block.
GenerateFromRelationElement
informations fournies:
RelationType, Name, ElementMultiple
ElementRangeExpression
NumberOfAccessInLevel, AttributesList
Instanciation du composant implantant l’élément de
relation.
Mise à jour de la clause générique du composant en
fonction des attributs de l’élément de relation.
Mise à jour de la clause port map du composant et
déclaration des types et signaux associés.
Règles de Génération appelées lors de l’analyse Opérations effectuées par le générateur VHDL
GenerateFromFirstCondActivity
informations fournies:
Expression, ComparisonOp, SecondExpression
Appel de la procédure de génération de nombres
aléatoires et génération de la branche "IF" de la construction
VHDL "IF... ELSIF... ELSE..."
GenerateFromCondActivity
informations fournies:
Expression, ComparisonOp, SecondExpression
Rajout d’une branche "ELSIF..." dans la construction
"IF... ELSIF... ELSE...".
GenerateFromLastCondActivity Rajout d’une branche "ELSE..." dans la construction
"IF... ELSIF... ELSE...".
GenerateBeginTaskSynchronisation
information fournie: NbTask Appel des procédures Fork/WaitFork.
GenerateEndTaskSynchronisation
information fournie: NbTask Appel des procédures WaitJoin/Join.
GenerateFromParActivity
information fournie: NbTask Déclaration et initialisation d’un nouveau process.
GenerateInfiniteLoop Génération de la construction "LOOP... END LOOP;"
GenerateFiniteLoopExpression
information fournie:
Expression
Génération de la construction
"FOR j IN 1 TO Expression LOOP
...
END LOOP;"
GenerateFiniteUnLoop
information fournie:
Expression
Génération de la construction
"IF (cpt=0) THEN
cpt := Expression; ...
ELSE cpt := cpt - 1;
END IF;"
et déclaration de la variable cpt.
Règles de Génération appelées lors de l’analyse Opérations effectuées par le générateur VHDL
Le Générateur VHDL
M.C.S.E 201
6.5.2 Difficultés rencontrées
Certaines constructions du modèle MCSE et leurs principes de transcription en VHDL
posent des difficultés pour la génération automatique de code. On peut citer en autres:
GenerateConditionalLoop
informations fournies:
Expression, ComparisonOp, SecondExpression
Génération de la construction
"WHILE (Expression ComparisonOp SecondExpression)
LOOP
...
END LOOP;"
GenerateFromFirstGuardedCondition
information fournie: InputName
Déclaration du signal ProtocolVector et de la variable
BranchNumber.
Génération de:
- l’assignation concurrente du signal ProtocolVector
- l’appel des primitives InitConditionnalActivation,
WaitConditionnalActivation et ResetConditionalActivation
- La première branche WHEN ... de la construction
CASE
GenerateFromGuardedCondition
information fournie: InputName
Appel aux primitives InitConditionnalActivation, Wait-
ConditionnalActivation et ResetConditionalActivation
Rajout d’une branche WHEN à la construction CASE.
GenerateFromLastGuardedCondition Mise à jour de la dimension du signal ProtocolVector.
GenerateElementaryActivity
informations fournies:
Name, Expression, TimeUnit
Appel de la primitive Delay et déclaration d’une constante
ou d’une variable pour l’expression du temps.
Appel la primitive TaskPriority si l’attribut ’Priority est
défini et si la concurrence est limitée.
GenerateFromIncludeFile
information fournie: FileName
Le fichier contenant l’algorithme de l’opération élémentaire
est inclu par référence.
GenerateFromNoOrderElementsVector Pas implanté pour l’instant.
GenerateFromInputOutputName
informations fournies:
ParameterType, ParameterName
TypeName, BlackBall
IsInput, AttributesList
IsInternalElement, LocalAtttributes
Appel de la primitive d’accès à l’élément de relation.
Déclaration de la variable contenant l’information à
transmettre ou recue.
Les attributs locaux sont utilisés pour surchager ceux
de l’élément de relation.
Mise à jour des records TypeDefInformation et Type-
DefData du package.
GenerateFromActivityInstance
informations fournies:
ActivityName, ActivityRangeExpression
ActivityMultiple, AttributesList
création d’un block multiple et/ou simple.
GenerateFromBehaviorInstance
information fournie: BehaviorName Déclaration d’un nouveau process.
GenerateExit Pas implanté pour l’instant
UpdateGenerationOfComponentModel
informations fournies:
NbTask, ComponentRangeExpression
Mise à jour du paramètre générique des composants
de relation du niveau représentant le nombre d’accès
du niveau à ce composant.
Rajout de l’interface StateVector dans le port et leport
map du block si la concurrence est limitée.
Gestion des indices du signal StateVector en fonction
du nombre de process(tâches) du niveau.
Règles de Génération appelées lors de l’analyse Opérations effectuées par le générateur VHDL
Chapitre 6
202 M.C.S.E
- le problème de connexion entre éléments de relation et composants actifs qui a été déjà
présenté dans le chapitre 4 consacré aux règles de transcription du modèle de
performance en VHDL,
- le problème de la gestion des indices du vecteur d’état associé à un ordonnanceur,
- le problème du partage d’informations entre différentes branches d’un parallélisme.
-A- Gestion des indices du vecteur d’état des tâches
La limitation du degré de concurrence d’un élément actif par l’attribut ‘Concurrency nous
oblige à instancier un composant ordonnanceur et à gérer les indices d’un vecteur regroupant
l’état des tâches (process VHDL) qui peuvent être situées à des niveaux hiérarchiques
différents.
Le principe de gestion des indices du vecteur d’état est schématisé ci-dessous.
-Figure 6.19- Principe de gestion des indices du vecteur d’états des tâches.
Lors du parcours descendant du modèle source, on empile à chaque niveau hiérarchique la
valeur courante de l’indice IndexVector dans la variable IndexVectorLevel. Puis lors du
parcours ascendant, comme on connaît alors le nombre de tâches du niveau (analyse du modèle
de comportement de la fonction terminée), on met à jour le port et le port map des blocks
VHDL concernés et la dimension du signal StateVector.
-B- Partage des informations entre différentes branches d’un parallélisme
L’utilisation des attributs d’une information reçue par des branches différentes d’une
concurrence nécessite de déplacer la déclaration de la variable utilisée pour stocker
l’information reçue de la partie déclarative d’un process vers la partie déclarative du block et
de déclarer cette variable sous la forme d’une "shared variable" (VHDL’93).
La fonction Lecture de l’exemple du serveur vidéo temps réel illustre ce cas. La variable
InfCmdCanalLec liée à l’entrée CmdCanalLec[] est déclarée comme shared variable au niveau
NbTask=2
Nbtask=3
NbTask=2
F1 ‘Concurrency=1
F11
F12
F111
F112
[1:n]
PortMultiple:
PortMapMultiple:
StateVector => StateVector(IndexVector+1 To IndexVector+n*NbTask)
StateVector: INOUT DefStateVector(1 TO n*NbTask)
PortSimple:
StateVector : INOUT DefStateVector(1 TO NbTask)
PortMapSimple:
StateVector => StateVector(NbTask*(i-1)+1 TO i*NbTask)
PortMapSimple:
StateVector => StateVector(IndexVector+1 TO IndexVector+NbTask)
PortSimple:
StateVector : INOUT DefStateVector(1 TO NbTask)
IndexVector:=IndexVector+n*NbTask;
IndexVector:=IndexVector+NbTask;
PortMapSimple:
StateVector => StateVector(IndexVector+1 TO
PortSimple:
StateVector : INOUT DefStateVector(1 TO NbTask)
1 IndexVector+NbTask)
2
3
4
StateVector => StateVector(IndexVectorLevel TO IndexVector)
PortSimple:
StateVector : INOUT DefStateVector(IndexVectorLevel TO IndexVector)
PortMapSimple:
IndexVector:=IndexVector+NbTask;
Signal StateVector : DefStateVector(1 TO IndexVector);
Le Générateur VHDL
M.C.S.E 203
du block Lecture. Elle est en effet utilisée par les process Lecture et OP_2 comme le montre le
code suivant.
-Figure 6.20- Test du générateur avec la fonction lecture du serveur vidéo.
<Component> [1:n] Lecture
(In Mess CmdCanalLec[] : DefCmdCanalLec;
InOut Var Sequences : DefSequences;
Out Mess SequenceOut[] : DefSequenceOut;
Out Mess RepCanal[:] : DefRepCanal;);
<Attributes>
SequencesOut[]`Debit = CmdCanalLec[]`Debit;
RepCanal[]`Id = CmdCanalLec[]`Source;
RepCanal[]`Size = 8;
RepCanam[:]`Path = `Id;
OpDepot`Time = 500 us;
OpRetrait`Time = 500 us;
<EndAttributes>
<Behavior> BehaviorLecture;
<InfoLink> FifoLec : Frag;
<Attributes>
`Capacity = A;
<EndAttributes>
<EndInfoLink>
<EvLink> FinEmis;
<EndEvLink>
Lecture::{?CmdCanalLec[]&Lire&!$RepCanal[:]}*;
Lire::({?Sequences&OpDepot&!FifoLec}*A)&
(({?FinEmis&?Sequences&OpDepot&!FifoLec}
*CmdCanalLec[]`Size - A)||
({?FifoLec&OpRetrait&!SequenceOut[]&
!FinEmis}*CmdCanalLec[]`Size));
<EndBehavior>
<EndComponent>
Lecture
CmdCanalLec[]
*
Lire
Opdépot
FifoLec
OpRetrait
SéquenceOut[]
Séquences
*CmdCanalLec[]‘Size - A
RepCanal[:]
S
*CmdCanalLec[]‘Size
Opdépot FifoLec: Frag;
* A
FinEmis
‘Id=CmdCanalEnr[]‘Source;
&
‘Débit=CmdCanalLec[]‘Débit;
PORT MAP (CmdCanalLec => CmdCanalLec (i),
Sequences => Sequences (i),
SequenceOut => SequenceOut (i),
RepCanal => RepCanal);
CONSTANT me : INTEGER := n + i;
SIGNAL FifoLecInputAccesses : DefPortIn;
...
SIGNAL OpStatus_1 : DefForkJoinStatus := InitForkJoinStatus;
SHARED VARIABLE InfCmdCanalLec : DefInformation;
BEGIN
FifoLec : COMPONENT PortObject
GENERIC MAP (NbUsersInput => 1, NbUsersOutput => 1,
...
Capacity => A,
WriteTime => NullTime
ReadTime => NullTime)
PORT MAP (InputAccesses (1) => FifoLecInputAccesses,
OutputAccesses (1) => FifoLecOutputAccesses, ...);
FinEmis : COMPONENT EveObject
GENERIC MAP (NbUsersInput => 1,
NbUsersOutput => 1,
...
ReadTime => NullTime)
PORT MAP (InputAccesses (1) => FinEmisInputAccesses,
OutputAccesses (1) => FinEmisOutputAccesses, ...);
Lecture : PROCESS
VARIABLE InfSequences : DefData;
VARIABLE InfFifoLec : DefInformation;
VARIABLE InfRepCanal : DefInformation;
CONSTANT OpdepotTime : TIME := 500 us;
BEGIN
OpStatus_1 <= InitForkJoinStatus;
LOOP
receive (CmdCanalLec, InfCmdCanalLec, NullTime, 0, now,
FALSE);
FOR j_1 IN 1 TO A LOOP
ReadSharVar (Sequences, InfSequences, NullTime,
NullTime, 0, now);
Opdépot‘Time = 500 us;
OpRetrait‘Time = 500 us;
Delay(OpdepotTime);
send (InfFifoLec, FifoLecInputAccesses, NullTime, 0
now, FALSE);
END LOOP;
Fork (OpStatus_1);
FOR j_2 IN 1 TO InfCmdCanalLec.Size - A LOOP
WaitEv (FinEmisOutputAccesses, NullTime, 0, now);
ReadSharVar (Sequences, InfSequences, NullTime, NullTim
0, now);
Delay(OpdepotTime);
send (InfFifoLec, FifoLecInputAccesses, NullTime, 0, no
FALSE);
END LOOP;
WaitJoin (OpStatus_1);
InfRepCanal.Id := InfCmdCanalLec.Source;
InfRepCanal.Size := 8;
send (InfRepCanal, RepCanal, InfRepCanal.Id, me, NullTime
now, FALSE);
END LOOP;
END PROCESS Lecture;
OP_2 : PROCESS
VARIABLE InfFifoLec : DefInformation;
VARIABLE InfSequenceOut : DefInformation;
CONSTANT OpRetraitTime : TIME := 500 us;
BEGIN
WaitFork (OpStatus_1);
FOR j_1 IN 1 TO InfCmdCanalLec.Size LOOP
receive (FifoLecOutputAccesses, InfFifoLec,NullTime
0, now, FALSE);
Delay(OpretraitTime);
InfSequenceOut.Debit := InfCmdCanalLec.Debit;
send (InfSequenceOut, SequenceOut, NullTime, 0, now
TRUE);
SignalEv (FinEmisInputAccesses, NullTime, 0, now);
END LOOP;
Join (OpStatus_1);
END PROCESS OP_2;
END BLOCK Lecture;
END GENERATE MultipleInstantiationLecture;
END BLOCK MultipleLecture;
MultipleLecture :
BLOCK
PORT (SIGNAL CmdCanalLec : INOUT DefPortOutVector(1 TO n);
SIGNAL Sequences : INOUT DefDataAccessVector(1 TO n);
SIGNAL SequenceOut : INOUT DefPortInVector(1 TO n);
SIGNAL RepCanal : INOUT DefRepCanalInputAccesses(1 TO k));
PORT MAP (CmdCanalLec => CmdCanalLecOutputAccesses,
Sequences => LectureSequencesAccesses,
SequenceOut => SequenceOutInputAccesses,
RepCanal => RepCanalInputAccesses);
BEGIN
MultipleInstantiationLecture :
FOR i IN 1 TO n GENERATE
Lecture :
BLOCK
PORT (SIGNAL CmdCanalLec : INOUT DefPortOut;
SIGNAL Sequences : INOUT DefDataAccess;
SIGNAL SequenceOut : INOUT DefPortIn;
SIGNAL RepCanal : INOUT DefRepCanalInputAccesses(1 TO k));
code source
code généré
modèle graphique
Process1
Process2 => OP_2
Chapitre 6
204 M.C.S.E
6.6 TEST DU GENERATEUR OBTENU
Le générateur ainsi développé a été testé sur deux exemples qui sont décrits dans le chapitre
suivant. Il s’agit d’un serveur vidéo temps-réel et d’un système de communication basé sur un
ensemble de cartes identiques. Ces deux exemples ont été très utiles pour mettre au point le
générateur car ils regroupent la plupart des constructions possibles (alternative, parallélisme,
attente conditionnelle, concurrence limitée...) d’un modèle source MCSE.
Le tableau suivant donne pour chaque exemple la taille en K octets du code source MCSE,
la taille du code VHDL généré (entité uniquement), le temps de génération en mode interprété
et le temps de génération en mode compilé (transcription du script en code Java). La machine
utilisée pour les tests est un PC PENTIUM PRO 200 Mhz avec 32 Mo de mémoire vive. Le
compilateur Java (ou plutôt dans ce cas machine virtuelle) utilisé est le compilateur "Just In
Time" de Symantec (VisualCafe 1.1).
Le temps de génération qui est de l’ordre de 4 mn, peut sembler pénalisant si le parcours du
domaine des solutions possibles d’un partitionnement logiciel/matériel nécessite un nombre
important de générations de code. En réalité, la recherche de la solution optimale ne nécessitera
pas forcément plusieurs générations lorsqu’il y a utilisation judicieuse des paramètres
génériques et le temps de génération sera certainement négligeable par rapport au temps de
simulation. Pour l’instant, aucune étude d’optimisation du code n’a donc été effectuée. On peut
cependant réduire le temps de génération en utilisant un compilateur Java natif mais on perd
alors la portabilité.
Le tableau suivant permet de comparer le générateur VHDL comportemental avec les
autres générateurs développés avec l’outil MetaGen. Il s’agit d’un générateur de programme C
utilisant l’exécutif temps-réel VxWorks et un générateur de programme VHDL synthétisable
(niveau RTL). Le tableau comporte la taille du code script, la taille du code source MCSE
utilisé comme exemple, la taille des templates utilisés par les générateurs, la taille du code
généré, le temps de génération en mode interprété, la taille du code Java obtenu par
transcription du script et le temps d’exécution du programme Java obtenu.
Ce tableau met en évidence que le temps de génération du générateur de code pour
l’évaluation des performances est beaucoup plus long (rapport 3) que celui des générateurs de
code pour la synthèse logicielle et matérielle. Cette différence de temps est due:
- aux différences de complexité des modèles sources,
- aux différences de complexité des modèles de sortie générés.
Système
taille du code
source Mcse
taille du code
VHDL généré
Temps en
mode interprété
Temps en mode
compilé
ComSys 4.28 Ko 28.6 Ko 462 s 228 s
ServeurVideo 5.45 Ko 31 Ko 492 s 245 s
Generateur Script Mcse Template Sortie Interprété Java Compilé
CVxworks 150 Ko 6.33 Ko 2.23 Ko 3.2 Ko 63 s 660 Ko 23 s
VhdlSyn 194 Ko 6.93 Ko 18.6 Ko 21.7 Ko 111 s 669 Ko 83 s
VhdlPerf 176 Ko 5.45 Ko 27 Ko 31 Ko 492 s 827 Ko 245 s
Le Générateur VHDL
M.C.S.E 205
Pour le générateur VHDL synthétisable, au niveau structurel, les combinaisons
problématiques de l’instanciation multiple (K->M->N) disparaissent par raffinement (fonction
d’arbitrage de bus par exemple). Au niveau comportemental, ce générateur de code
synthétisable n’accepte que des comportements de fonctions qui sont séquentielles et
déterministes.
Le code de sortie du générateur de code synthétisable est également pour l’instant plus
simple:
- Il n’y a pas de problèmes liés aux limitations sur la généricité des types puisqu’il
travaille uniquement avec des bits (niveaux logiques),
- un port ne peut avoir qu’un seul producteur et un seul consommateur,
- un événement ne peut avoir qu’un seul producteur,
- une variable partagée peut avoir plusieurs accès simultanés mais obligatoirement du
même niveau hiérarchique. Pour des accès à une variable partagée à des niveaux
hiérarchiques différents, on instancie une interface (décodeur de priorité). La priorité
de l’accès devient locale au niveau mais comme il ne tient pas compte de l’attribut
‘Concurrency ceci n’a aucune importance.
- Le générateur n’a pas à gérer les activités concurrentes et la limitation du degré de
concurrence d’une ressource ainsi que leurs problèmes sous-jacents.
6.7 INTERFACE UTILISATEUR DE L’OUTIL OBTENU
Le générateur obtenu est intégré dans une plate-forme d’outils en cours de développement
nommée McseTools. L’interface utilisateur du générateur est représentée par la figure 6.21.
-Figure 6.21- Face avant du générateur de programme VHDL comportemental.
Chapitre 6
206 M.C.S.E
L’interface utilisateur comporte trois zones principales:
- une zone de sélection du composant de départ pour la génération. Pour une évaluation
des performances, on générera plutôt le système complet et son environnement pour ne
pas être obligé de définir de stimuli,
- une zone de messages permettant aux générateurs d’afficher des informations durant la
génération de code (instructions Display et Warning du script),
- une zone de rapport contenant la liste des fichiers générés avec leur nombre de lignes
de code et le pourcentage de code généré automatiquement.
L’outil peut être utilisé:
- durant la phase de conception fonctionnelle: vérification fonctionnelle et/ou allocation
d’exigences sur les constituants du système (taille d’un port, temps d’exécution max,...)
utiles pour la conception architecturale,
- durant la phase de conception architecturale: aide au partitionnement logiciel/matériel
(co-simulation non-interprétée).
6.8 AMELIORATIONS
Les améliorations possibles à court terme concernent la réduction du temps de génération
du code VHDL, le mode de couplage entre le simulateur du modèle de performance et l’outil
d’analyse de trace et la transcription automatique de VHDL vers C ou réciproquement des
algorithmes des activités élémentaires du modèle de performance d’un système.
6.8.1 La réduction du temps de génération du code VHDL
La génération de code VHDL comportemental avec l’outil développé est relativement
lente. Une analyse du code Java produit avec un outil de "profiling" tel que Visual Quantify de
Pure Atria permettrait de trouver les méthodes gourmandes en temps C.P.U. et d’optimiser le
temps d’exécution du générateur. A priori, le générateur consomme beaucoup de temps à
rechercher avant de déclarer un élément si la déclaration de ce dernier (type, signal, variable,
procédure) n’a pas déjà été générée. Au lieu de parcourir plusieurs fois des listes de la structure
de données interne, il semble plus judicieux d’offrir au niveau du Script la possibilité d’utiliser
des hashtables. Comme les outils ont été implantés en Java, cette extension du Script ne pose
aucune difficulté.
Le parcours du modèle MCSE nécessite un parcours descendant pour respecter la hiérarchie
du modèle source et un parcours ascendant qui permet d’utiliser les informations recueillies à
un niveau donné pour la mise à jour du niveau supérieur. Si le modèle MCSE source l’autorise,
il est préférable de laisser le choix au concepteur de générer un modèle VHDL hiérarchique ou
un modèle à plat. Un modèle à plat s’obtient par algorithme de parcours du modèle MCSE du
type ascendant (Bottom-Up) qui est plus rapide que celui utilisé pour générer un modèle
hiérarchique.
6.8.2 Couplage avec l’outil d’analyse de trace
Le couplage entre le couple générateur/simulateur VHDL et l’outil d’analyse de trace est
pour l’instant du type hors ligne. Les informations nécessaires pour la génération de la trace
sont contenues dans le modèle MCSE source sous la forme d’attributs ‘Probe et transformées
Le Générateur VHDL
M.C.S.E 207
sous la forme d’une table de codage par le générateur de code. Lors de la simulation, la trace
générée ne contient que des occurrences de trace dont les codes sont ceux définis dans la table
de codage. Avec cette approche, le contenu de la trace ne peut pas être modifié en direct par
l’outil d’analyse des performances. Pour avoir un couplage en ligne entre le simulateur VHDL
et l’outil d’analyse de trace, il est possible de déclarer automatiquement une table de codage
complète et de ne sortir par le simulateur que les occurrences de trace dont les codes sont
nécessaires pour calculer les indices de performances définis au niveau de l’outil d’analyse de
trace. La procédure de génération d’une occurrence de trace doit alors être asservie à l’état d’un
indicateur qui sera positionné par le simulateur en fonction des ordres provenant de l’outil
d’analyse de trace. Le couplage entre le simulateur et l’outil d’analyse de trace peut s’effectuer
grâce à l’interface Foreign Language Interface (VHDL’93) et à un mécanisme de
communication inter-outils. Le mécanisme de communication (socket par exemple) doit être
capable de relier le simulateur VHDL s’exécutant sur une machine sous unix et l’outil
d’analyse de trace qui fonctionne dans l’environnement Windows 95/NT.
6.8.3 Transcription VHDL en C et C en VHDL
Avec les générateurs obtenus, pour faire une vérification fonctionnelle, le concepteur doit
saisir manuellement le code de chaque opération élémentaire du modèle de comportement des
fonctions non raffinées de la description fonctionnelle. Lorsque la conception est avancée, la
description fonctionnelle est très détaillée et le comportement des fonctions est purement
séquentiel. La description peut alors être synthétisée. Pour qu’une modification de l’allocation
d’une fonction au niveau du partitionnement matériel/logiciel avec passage d’une implantation
matérielle en logiciel ou réciproquement, ne nécessite par une nouvelle saisie de code des
opérations, il faut transcrire automatiquement une description VHDL séquentielle en C et
réciproquement. Cette translation peut facilement être réalisée avec l’outil MetaGen pour
lequel on dispose déjà des grammaires C et VHDL. La syntaxe des constructions VHDL
séquentielles et celle de leurs équivalences en C étant proches, il est aussi possible de faire une
transcription directe lors de l’analyse syntaxique sans utiliser de structures de données
intermédiaires [PARKINSON-94].
6.9 CONCLUSIONS
Ce chapitre a présenté l'implantation du générateur de code permettant de transcrire la
description textuelle MCSE d'un système en une description VHDL comportementale. L'outil
obtenu permet de faire:
- une vérification fonctionnelle. L’utilisateur doit alors entrer les algorithmes des
opérations élémentaires (modèle interprété). Comme le langage VHDL est très
déclaratif, le générateur permet de générer 60-80% du code automatiquement.
- une évaluation des performances pour laquelle le code est entièrement généré
automatiquement. Il s’agit en effet d'un modèle non-interprété où seuls comptent les
temps des opérations et les dépendances temporelles.
Le principe de génération repose sur l'utilisation d'un analyseur syntaxique et d'un template.
L'obtention d'un analyseur syntaxique nécessite de saisir la grammaire du langage voulu dans
le formalisme du générateur d'analyseur syntaxique. Le template est un fichier contenant sous
leur forme la plus complète les constructions du langage cible qui sont utiles pour la
Chapitre 6
208 M.C.S.E
transcription. La génération consiste alors à effectuer un parcours ordonné de la structure de
données d'entrée obtenue avec l'analyseur syntaxique et à générer la structure de données de
sortie à partir des constructions contenues dans le template. L'ensemble de ces opérations de
manipulations de structures de données est décrit sous la forme d'un script. Ce script sert de
point d'entrée au méta-générateur MetaGen qui permet d'interpréter le script ou de le transcrire
en code Java. Une fois transcrit en code java, le générateur obtenu reste un outil multi plateforme
(Unix, PC, Mac...).
Le script se compose d'une partie analyse du modèle source et d'une partie génération. La
partie analyse extrait les informations pertinentes et appelle les règles de la partie génération.
Si plusieurs générateurs utilisent le même modèle source, il faut essayer d'obtenir une partie
Analyse suffisamment générique pour qu'elle soit commune à tous les générateurs. Comme le
modèle MCSE servira d'entrée à d'autres générateurs que le générateur VHDL, nous avons
donc détaillé dans ce chapitre la partie analyse du modèle MCSE. Le concepteur d'un nouveau
script pourra ainsi l'utiliser tel quel ou optimiser et compléter cette base à sa guise et concentrer
ses efforts sur les règles de la partie génération. La partie Génération est spécifique à chaque
générateur. Les règles de transcription qui seront à priori décrites en langage naturel doivent
être converties en règle de script.
La technologie de génération utilisée permet:
- de réduire le temps de développement des générateurs qui peuvent être developpés
de manière incrémentale,
- de faciliter la maintenance des générateurs: la taille du code script est plus petite et
plus lisible que celle d’un code équivalent en langage de programmation classique
(C++, JAVA...).
Un générateur de code C++ pour l’évaluation des performances est également en cours de
développement. Cette solution basée sur l’exécution d’un programme C++ est plus
avantageuse que l’utilisation du couple VHDL/simulateur. L’intérêt est que l’exécution du
modèle obtenu est beaucoup plus rapide que la simulation du modèle VHDL (rapport de 3 à 4),
et ceci permet donc de parcourir plus rapidement l’espace des solutions possibles d’un
partitionnement matériel/logiciel.

M.C.S.E 209
7
Validation de la méthode
par des études de cas
La validation de la démarche d’évaluation des performances et des règles de transcription
du modèle de performance en VHDL repose sur deux exemples. Le premier exemple nous a
été proposé par le CCETT de Rennes et concerne la conception d’un serveur pour séquences
audio-visuelles. Le second exemple est un exemple interne à l’équipe de recherche MCSE et
concerne un système de communication distribué basé sur l’interconnexion d’un ensemble de
cartes identiques avec un bus série du type anneau à jeton.
Bien que dans un premier temps le code VHDL utilisé pour la simulation ait été écrit
manuellement de manière à identifier les règles de transcription du modèle de performance en
VHDL, ces deux exemples ont ensuite servi aux tests du générateur de code présenté dans le
chapitre précédent.
Pour chaque exemple, après une présentation succincte de l’exemple et des objectifs de
l’évaluation des performances, nous décrivons le modèle de performance du système et de son
environnement. Puis nous commentons les résultats obtenus par simulation du modèle de
performance.
7.1 SERVEUR VIDEO TEMPS REEL
Cet exemple fourni par le CCETT de Rennes a été choisi pour montrer l’adéquation de la
méthodologie MCSE pour la spécification, la conception et l’évaluation des performances d’un
système complexe. Ce travail qui a été effectué en collaboration avec le CCETT de Rennes (G.
Babonneau) et l’équipe de J.M Bergé du CNET de Meylan est également présenté dans
[CALVEZ-97a].
Chapitre 7
210 M.C.S.E
7.1.1 Présentation de l’exemple
Le serveur audio-visuel se place dans un service de consultation à distance de séquences
vidéo ou sonores. Le terme séquence signifie ici une unité visuelle ou audio de durée allant de
quelques secondes à plusieurs heures. Vis-à-vis de l’usager, une séquence respecte un débit
pouvant varier entre 0 et 15 Mbits/s et est décomposée temporellement en unités plus
élémentaires appelées fragments. Un fragment correspond à une quantité fixe d’information
définie par la technique de mémorisation du serveur. L’usager peut contrôler la visualisation
ou l’enregistrement par fragment (par exemple pause entre 2 fragments mais pas durant un
fragment). En terme de fonctionnalité pour un usager, le serveur joue un rôle analogue au
magnétoscope et au magnétophone. L’usager peut fournir les commandes suivantes: lecture
d’une séquence, enregistrement d’une séquence, pause, restart, stop (ce qui veut dire fin de la
séquence courante), avance rapide, retour rapide, effacement séquence. Les réponses du
système lui permettront de connaître l’état et les réactions du serveur.
Pour les interfaces physiques, le couplage de chaque usager se fait par un réseau de faible
débit et un réseau de haut débit. Le réseau faible débit peut être: X25, NUMERIS, Ethernet,
etc. Le réseau haut débit considéré est le réseau ATM.
Les fonctions du système sont les suivantes:
- la lecture de séquence(s) qui assure la sortie fragment par fragment de la séquence
choisie au débit souhaité,
- l’enregistrement de séquence(s) qui reçoit en temps-réel une séquence et la
mémorise,
- la gestion des requêtes de chaque utilisateur qui alloue si nécessaire un canal et
transmet l’ordre pour la lecture ou pour l’enregistrement
La figure 7.1 représente la structure fonctionnelle de l’application complète.
-Figure 7.1- Structure fonctionnelle complète permettant la modélisation de performances.
CmdUsager[1:k] RepUsager[1:k]
Séquences
CmdCanalEnr[1:n]
RepCanal[1:k]
Emission Enregistrement Lecture Réception
Usagers
Exécution
Supervision
‘Concurrency=nd;
‘Use=TaccDisk;
‘Capacity=0; ‘Capacity=0;
EtatCanaux: CanauxLibresLec
+ FragmentsLibres
SupervisionUsager
+ CanauxLibresEnr
SéquenceIn[1:n] SéquenceOut[1:n]
CmdCanalLec[1:n]
Validation de la méthode par des études de cas
M.C.S.E 211
La structure fonctionnelle est basée sur le modèle Supervision/Contrôle-Commande. Pour
la partie Supervision, la fonction SupervisionUsager gère les ordres provenant des utilisateurs
(port CmdUsager en entrée et CmdCanalEnr et CmdCanalLec en sortie) et s’occupe aussi du
retour d’information vers l’usager concerné (port RepCanal en entrée et RepUsager en sortie).
Elle attribue entre autre un canal haut débit à un utilisateur en fonction de l’état (libre ou
occupé) de l’ensemble des canaux modélisé par la variable EtatCanaux. La partie
Contrôle/Commande est composée des fonctions Lecture et Enregistrement. Ces deux
fonctions sont reliées entre elles par la variable partagée Séquences qui représente l’ensemble
des disques où sont stockés les fragments des séquences vidéo ou sonores disponibles sur le
serveur.
Le comportement du système pour les fonctions de la structure fonctionnelle doit être
explicité pour disposer d’une spécification exécutable (ce qui veut dire simulable pour la
vérification). L’évaluation nécessite aussi qu'un système (et ceci est particulièrement vrai
durant la conception car il n'existe pas) soit décrit par un modèle qui, soumis à une
configuration de charge donnée, permet d'extraire des informations quantitatives. Pour éviter
de définir des stimuli, on modélise également l’environnement du système (fonctions Usagers,
Emission et Réception).
7.1.2 Objectif de l’évaluation des performances pour cet exemple
Cet exemple permet de montrer que le modèle de performance est approprié pour aider au
dimensionnement et au partitionnement matériel/logiciel d’un système. Dans cet exemple,
avant de commencer la conception architecturale, le concepteur doit en effet déterminer:
- le nombre de disques utilisés pour stocker les séquences vidéo ou sonores. Cette
information est indispensable pour concevoir l’interface avec les disques.
- la taille des buffers d’anticipation nécessaires pour éviter toutes rupture de séquences.
Cette information est utile pour déterminer le taille de la mémoire du système.
L’allocation des éléments fonctionnels sur les éléments exécutifs et le partitionnement
matériel/logiciel ne pose pas trop de problèmes. En effet, le système est basé sur le modèle
Supervision/Contrôle-Commande avec des contraintes faibles pour la partie Supervision et des
contraintes fortes pour la partie Commande. On s’intéressera donc plus particulièrement aux
performances du processeur en charge de la partie commande (ou partie dite opérative).
7.1.3 Modèle de performance du système
L’étude des performances peut commencer par une modélisation statique qui permet
d’obtenir le nombre des disques représentés dans un premier temps par la variable partagée
séquences. Ensuite pour cet exemple, il est indispensable d’effectuer une modélisation
dynamique de manière à déterminer plus précisément les paramètres de l’architecture
fonctionnelle du système que sont la taille des ports et des fifo internes aux fonctions Lecture
et Ecriture et les performances des fonctions. Cette modélisation résumée ci-après s’obtient:
- en ajoutant des paramètres ou attributs de comportement aux constituants de la solution
fonctionnelle de la figure 7.1, (‘Concurrency définit le nombre de disques, ‘Use définit
le temps d’accès pour la variable Séquences et donc celui des disques, ‘Capacity est la
taille en nombre de messages de chaque port),
Chapitre 7
212 M.C.S.E
- en exprimant le modèle comportemental de performance pour chaque fonction de la
structure fonctionnelle (voir les paragraphes suivants),
- en modélisant la charge du serveur (workload) par simulation de l’environnement pour
représenter le scénario imposé pour l’évaluation.
-A- Modélisation Statique
Pour avoir un système stable, il faut obligatoirement que le flux de sortie soit supérieur ou
égal au flux d’entrée. Le nombre de disques nécessaires se calcule donc par:
-B- Modélisation des fonctions de l’environnement
La modélisation de l’environnement comprend la spécification du comportement souhaité
pour placer le système dans le contexte imposé pour son évaluation. La figure 7.2 représente le
résultat de cette modélisation.
-Figure 7.2- Spécification du comportement de l’environnement pour les performances.
La fonction Usagers est modélisée comme 2 activités simultanées: Envoi et Reçoit. Reçoit
sert simplement à consommer les messages en provenance du serveur. Envoi génère selon un
intervalle aléatoire défini par le temps Tcu, un message destiné à un usager tiré d’une manière
NbDisques = (NbUtilisateurs × DebitMoy × TaccDiskMoy ) ⁄ (TailleFragment)
Emission[1:n]
Usagers
Réception[1:n]
Tcu‘Time = Uniform(Tmin, Tmax);
SéquenceIn[]
SéquenceOut[:]
*
*
*
Tru
‘Id=me‘Index;
‘Size=NbB bytes;
Tprod‘Time=0;
Emission :: {Tprod&!SéquenceIn[]}*
RepUsager[:]
‘Path=‘Id;
Usagers :: Envoi || Recoit;
Envoi :: {Tcu&!$CmdUsager[:]}*
Tcons‘Time=
Réception :: {?SéquenceOut[]&Tcons}*
CmdUsager[:]
&
OR
Tprod
Tcons
Emission Réception
*
Tcu
S
Tru‘Time = 0;
Recoit :: {?|RepUsager[:]&Tru}*
‘Id=Uniform(1,k);
‘Size=Uniform(1,120);
‘Débit=Uniform(0,15)
Recoit Envoi
k/SéquenceOut[]‘Débit ms;
Contrainte de
temps à
satisfaire
T <=k/SéquenceOut[]‘Débit
CanauxLibres = {};
‘Canal=AttributionCanal(CanauxLibres);
Validation de la méthode par des études de cas
M.C.S.E 213
aléatoire et possédant une taille en nombre de fragments elle aussi aléatoire qui servira à définir
la durée de la séquence. Un attribut particulier ‘Débit a été ajouté pour définir le débit de
transmission pour la séquence correspondante, ainsi qu’un attribut ‘Canal pour définir le canal
à utiliser.
Chaque fonction Emission produit en permanence des fragments. La vitesse de
consommation de ces messages sera définie par le serveur. Chaque fonction Réception se
charge de consommer les fragments à la vitesse définie par le débit de la séquence. La
vérification de l’absence de rupture de séquence se fait par chaque fonction Réception par
vérification de la contrainte de temps. Pour cette vérification, le message reçu par
SéquenceOut[] doit contenir le débit ‘Débit comme attribut.
-C- Modèle pour SupervisionUsager
Chaque message CmdUsager[] est interprété puis transmis vers la lecture ou
l’enregistrement d’un canal tiré d’une manière aléatoire (Proba sur la branche). Chaque
message RepCanal[] possède la signification de la fin de la séquence, ce qui engendre un
message RepUsager[]. Le comportement de la fonction est voulu séquentiel pour une
modélisation la plus réaliste possible, ce qui justifie l’attente alternative. La taille de la
séquence, le débit et l’usager source sont transmis vers le canal correspondant désigné par
l’attribut ‘Canal.
La figure 7.3 donne le modèle de cette fonction.
-Figure 7.3- Modèle de comportement pour chaque fonction SupervisionUsager.
-D- Modèle pour Enregistrement
Une analyse statique de l’application montre que la fréquence d’arrivée de fragments peut
être supérieure à la fréquence maximale d’écriture sur un disque. L’emploi de disques
multiples permet de résoudre ce problème. Pour les variations ponctuelles de vitesse d’écriture
sur les disques dues à la concurrence d’accès et à la variation du temps d’accès, il est nécessaire
de considérer une fifo entre les messages de SéquencesIn[] et les écritures dans Séquences.
SupervisionUsager
OpRep‘Time = 0.5 ms;
CmdUsager[]
SupervisionUsager :: {[(?CmdUsager[]&Commande) |
RepCanal[]
Commande :: (<Proba>OpEnr&?$CmdCanalEnr[:]) |
*
OpEnr OpLec
Else
‘Path=‘Id;
Proba
OR
S
RepUsager[]
OpRep
S
‘Path=‘Id;
‘Id=CmdUsager[]‘Canal;
CmdCanalEnr[:] CmCanalLec[:]
‘Id=CmdUsager[]‘Canal;
‘Size=CmdUsager[]‘Size; ‘Size=CmdUsager[]‘Size;
Commande
(?RepCanal[]&OpRep&!RepUsager[])]}*
(OpLec&!$CmdCanalLec[:])
OpLec‘Time = 1 ms;
OpEnr‘Time = 1 ms;
‘Débit=CmdUsager[]‘Débit; ‘Débit=CmdUsager[]‘Débit;
‘Source=CmdUsager[]’Id; ‘Source=CmdUsager[]’Id;
Chapitre 7
214 M.C.S.E
La figure 7.4 donne le modèle de cette fonction. Pour simuler une séquence, elle reçoit un
nombre de fragments égal à l’attribut ‘Size défini dans le message de commande en provenance
de CmdCanalEnr[] et qui provient de la demande de l’usager. Lorsque tous les fragments ont
été enregistrés, la fin de séquence est représentée par un message transmis à RepCanal[Source].
Les temps d’écriture et de lecture dans FifoEnr sont considérés nuls car ces temps sont
associés aux opérations OpDépot et OpRetrait. Un attribut structurel ‘Capacity pour FifoEnr
définit la taille de la fifo en nombre de fragments. On suppose aussi un accès simultané
possible.
Pour simuler correctement l’arrivée de fragments à la vitesse définie par le débit de
l’enregistrement, on utilise l’attribut ‘Read pour la lecture d’un fragment dans le port
SéquenceIn[]. La capacité de 0 pour ce port (port du type rendez-vous) va engendrer un
asservissement de la fonction Emission à la fonction Enregistrement.
-Figure 7.4- Modèle de comportement pour la fonction Enregistrement.
-E- - Modèle pour Lecture
La modélisation pour la fonction Lecture est assez similaire à celle adoptée pour
Enregistrement à la différence qu’il faut disposer d’un certain nombre de fragments en
anticipation avant d’assurer l’émission en temps-réel sans rupture de séquence. Une Fifo
appelée FifoLec est utilisée pour cela. Une première phase consiste à rechercher A fragments
avant d’initialiser la transmission. FifoLec est caractérisée par son attribut structurel ‘Capacity
dont la valeur est supérieure à A.
Enregistrement
Opdépot‘Time = 0.5 ms;
CmdCanalEnr[]
Enregistrement :: {?CmdCanalEnr[]&Enregistre&!$RepCanal[:]}*;
Enregistre :: ({?SéquenceIn[]&OpDépot&!FifoEnr}*CmdCanalEnr[]‘Size) ||
*
OpRetrait‘Time = 0.5 ms;
Enregistre
Opdépot
&
FifoEnr:Frag;
OpRetrait
Séquences
SéquenceIn[]
*CmdCanalEnr[]‘Size
RepCanal[:]
S
‘Id=CmdCanalEnr[]‘Source;
’Size=8;
Path=‘Id;
*CmdCanalEnr[]‘Size
({?FifoEnr&OpRetrait&!Séquences}*CmdCanalEnr[]‘Size);
‘Read=k/CmdCanalEnr[]‘Débit;
‘Capacity=5;
Validation de la méthode par des études de cas
M.C.S.E 215
Pour simuler correctement la vitesse de transfert correspondant au débit, on utilise d’une
part l’attribut ‘Write pour l’accès au port SéquenceOut[], d’autre part l’attribut ‘Débit dans le
message SéquenceOut[] et qui définit la vitesse de lecture du port SéquenceOut[] par la
fonction Réception[] chargée de simuler le récepteur.
-Figure 7.5- Modèle de comportement pour la fonction Lecture.
7.1.4 Simulation du serveur en lecture
Les disques représentés dans le modèle par la variable partagée Séquences sont modélisés
sous la forme d’une ressource commune. Cette ressource (voir figure 7.1) est caractérisée par
son degré de partage ‘Concurrency et sa capacité en nombre de bits ou de mots ‘Capacity
(grandeur statique ou dynamique). Pour le comportement, 3 temps sont à considérer pour son
utilisation: temps d’allocation (‘Write), temps d’utilisation (‘Use) et temps de libération
(‘Read). Le degré de partage concerne les accès simultanés pour ces 3 temps.
Opdépot‘Time = 0.5 ms;
Lecture :: {?CmdCanalLec[]&Lire&!$RepCanal[:]}*;
OpRetrait‘Time = 0.5 ms;
‘Id=CmdCanalLec[]‘Source;
’Size=8;
({?FifoLec&OpRetrait&!SéquenceOut[]&!FinEmis}*CmdCanalLec[]‘Size));
(({?FifoEmis?Séquences&OpDépot&!FifoLec}*CmdCanalLec[]‘Size-A) ||
Lire :: ({?Séquences&OpDépot&!FifoLec}*A) &
Lecture
CmdCanalLec[]
*
Lire
Opdépot
&
FifoLec
OpRetrait
SéquenceOut[]
Séquences
*CmdCanalLec[]‘Size - A
RepCanal[:]
S
*CmdCanalLec[]‘Size
Opdépot
FifoLec: Frag;
* A
FinEmis
‘Débit = CmdCanalLec[]‘Débit;
‘Write = 0,5 ms
‘Capacity = A+1;
Chapitre 7
216 M.C.S.E
L’attente sur la variable Séquence se traduit par une primitive ReadSharVar.
De sorte que si un disque est libre, pour la fonction l’accès au disque ne dure que la valeur
de ‘Read, mais le disque n’est libéré qu’après ‘Read+‘Use.
Le temps d’accès aux disques (attribut ‘Use de la variable partagée) a d’abord été fixé à 30
ms. Puis pour avoir une modélisation plus réaliste des disques, nous avons considéré que
TaccDisk = Tseek + Tlatency + Tread avec les lois aléatoires suivantes pour Tseek et Tlatency:
- Tseek = U(2,24) ms (U loi aléatoire uniforme),
- Tlatency = U (0,11) ms
- Tread = 12,8 ms (temps de lecture nécessaire à 5300 trs/mn pour lire 32 Ko).
Le débit pour une séquence et un utilisateur est tiré aléatoirement selon une loi uniforme
entre 0 et 15 Mbits/s. De plus, pour privilégier la fonction lecture par rapport à la fonction
enregistrement, dans le modèle de comportement de la fonction SupervisionUsager la valeur
de la probabilité Proba associée à l’alternance est très faible (0,0005).
Enfin et surtout la valeur de A (taille du buffer d’anticipation) n’est pas fixe et commune à
tous les canaux haut débit, mais elle dépend de la valeur courante du débit de la séquence
lue. Pour notre simulation, A est calculé par la loi empirique suivante:
-Figure 7.6- Valeur de A en fonction du débit.
Un autre aspect important concerne la gestion des accès simultanés sur notre variable
partagée Séquences. L’entité gérant cet élément de relation est capable d’ordonnancer les accès
multiples soit en fonction de leur priorité (‘Priority) soit en fonction de leur estampille (‘Date).
Dans le cas d’un ordonnancement utilisant les estampilles des demandes d’accès
(l’ordonnanceur ne prenant en compte que les demandes dont la date est inférieure ou égale à
la valeur courante du temps de simulation now), deux politiques sont applicables:
- une politique d’ordonnancement au plus tôt,
- une politique d’ordonnancement au plus tard: cette solution a l’avantage de privilégier
les accès aux débits élevés par rapport à ceux correspondant à des débits faibles. Dans
ce cas, l’estampille d’une demande d’accès se calcule par:
‘date = now + ConversionDebitTemps(debit) - k * TrwFrag,
’Read ‘Use
Read
Data
1
1.2
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
3
0 2 4 6 8 10 12 14
int(0.13*x+1.5)
A
Débit (Mbits/s)
Soit encore A = E(DebitSequence ⁄ DebitMoy + 1, 5)
A = E(NbUtilisateurs ⁄ Nbdisques × DebitSequence × TaccDiskMoy ⁄ TailleFragment + 1, 5 )
Courbe Obtenue pour un débit
moyen de 7.5 Mbits/s
avec E partie entière
Validation de la méthode par des études de cas
M.C.S.E 217
où now représente la valeur courante de l’instant de simulation et TrwFrag représente
le temps d’accès moyen aux disques. K est un coefficient de sécurité (k=2) pour éviter
les coïncidences de cas défavorables (ce coefficient n’a pas d’incidence sur A).
Nous avons choisi les conditions suivantes: le nombre d’utilisateurs et de canaux haut débit
du serveur est 40 et le nombre de disques est de 35. La charge imposée au système est
représentée par la figure suivante. Les usagers sont activés progressivement de manière
aléatoire.
-Figure 7.7- Charge imposée au système pour la simulation en phase de démarrage.
La courbe montre que le premier usager possède un débit de 14 Mb/s. Les figures montrent
la valeur moyenne et la valeur maximale.
La variation du nombre de fragments présents dans les fifos internes des fonctions Lecture
au cours de la simulation est la suivante.
-Figure 7.8- Nombre de Fragments dans les fifos internes du système pour 40 utilisateurs.
6e+06
7e+06
8e+06
9e+06
1e+07
1.1e+07
1.2e+07
1.3e+07
1.4e+07
1.5e+07
0 0.05 0.1 0.15 0.2 0.25
"DebitMaxFile"
"DebitMoyFile"
Temps (s)
Debit (Mbits/s)
0
10
20
30
40
50
60
70
80
90
100
0 5 10 15 20 25 30
"NbFragReadMoy"
"NbFragRead"
Temps (s)
Nombre de Fragments
Total (dans le système)
Moyen (par buffer d’anticipation)
Chapitre 7
218 M.C.S.E
Cette simulation nous a permis d’obtenir un encadrement de la valeur de A qui doit se
situer entre 2 et 3. Pour obtenir une valeur plus précise du paramètre A, il faut modéliser les
disques d’une manière plus réaliste ce qui est l’objectif du paragraphe suivant.
7.1.5 Modélisation plus réaliste des disques
De manière à avoir une évaluation plus fine du serveur, il est nécessaire de considérer un
modèle plus réel des disques. Ainsi dans ce paragraphe la variable partagée Disques est
remplacée par des fonctions, chacune représentant le comportement réaliste d’un disque.
-A- Structure fonctionnelle et modèles de comportement utilisés
La structure fonctionnelle simulée est représentée par la figure suivante. La variable
partagée Séquences est maintenant remplacée par un ensemble de ND fonctions, chacune
modélisant un disque.
La nouvelle fonction Disque[i] est décrite ci-après.
Action Disque[] sur mess DemD[]: DefDemD avec
sortie mess RepD[:]: DefRepD;);
Begin
Cycle DemD[]:
Attente(TaccDisk);
IF DemD[]=Lecture THEN
Send(Disque[DemD[].NoBloc], RepD[DemD[].Dest]);
EndIF;
EndCycle;
End Disque[];
-Figure 7.9- Structure fonctionnelle avec modélisation réaliste des disques.
Le temps d’accès aux disques est la somme de trois composantes (TaccDisk = Tseek +
Tlatency + Tread) avec des lois aléatoires pour Tseek et Tlatency: Tseek = U(2,24) ms (U loi
aléatoire uniforme), Tlatency = U (0,11) ms et Tread = 12,8 ms (temps de lecture nécessaire à
5300 trs/mn pour lire 32 Ko).
CmdUsager[1:k]
SéquenceIn[1:n]
RepUsager[1:k]
SéquenceOut[1:n]
CmdCanalEnr[1:n]
RepCanal[1:k] CmdCanalLec[1:n]
SupervisionUsager
Enregistrement Lecture Emission Réception
Usagers
CanauxLibres
Disque[1:ND]
DemD[1:ND]
RepD[1:n]
Supervision
Execution
Validation de la méthode par des études de cas
M.C.S.E 219
Avec la nouvelle représentation des disques, le comportement considéré pour la fonction
Lecture est représentée par la figure suivante.
-Figure 7.10- Modèle de comportement pour la fonction Lecture.
Lecture
Opdépot‘Time = 0.5 ms;
CmdCanalLec[]
*
OpRetrait‘Time = 0.5 ms;
Lire
Opdépot
&
FifoLec
SéquenceOut[]
RepD[]
*CmdCanalLec[]‘Size - A
RepCanal[:]
S
‘Id=CmdCanalLec[]‘Source;
’Débit=CmdCanalLec[]‘Débit;
*CmdCanalLec[]‘Size-A
Opdépot FifoLec: Frag;
* A
OpDem
* A
DemD[:]
S
‘Id=NumDisk
NumDisk=UniformInt(1,P);
NumDisk=(NumDisk+1) mod P
NumDisk=(NumDisk+1) mod P
OpRetrait
*A
OpDem‘Time = 0.5 ms;
OpRetrait
Chapitre 7
220 M.C.S.E
La fonction commence par demander les A premiers fragments puis attend la réception de
ceux-ci. Ensuite, elle envoie les fragments les uns après les autres en demandant un nouveau
fragment après chaque envoi.
Pour une séquence donnée, l’accès des fragments successifs sur l’ensemble des disques se
fait maintenant selon une technique de Round Robin et le numéro de disque du premier
fragment est tiré aléatoirement.
Pour cette simulation, le nombre d’utilisateurs et de canaux haut débit du serveur est 10
(limitation liée à la taille de la mémoire dynamique et virtuelle de la machine utilisée pour la
simulation). Le débit d’un utilisateur est tiré aléatoirement selon une loi uniforme U(0,15)
(débit exprimé en Mbits/s).
-B- Détermination d’une loi pour la valeur de A
La loi empirique de la valeur de A en fonction du débit d’une séquence utilisée lors de la
modélisation avec une variable partagée ne s’est plus avérée valable (valeur de A trop faible).
Pour déterminer une nouvelle loi, nous avons choisi une valeur de A suffisamment grande pour
ne pas avoir de rupture de séquence et nous avons observé l’évolution du nombre de fragments
dans le buffer d’anticipation de chaque canal pour des débits différents.
-Figure 7.11- Evolution du nombre de fragments dans le buffer d’anticipation d’un canal.
L’ensemble des courbes obtenues nous a permis en regardant l’amplitude de variation du
nombre de fragments dans le buffer d’obtenir un ensemble de points donnant une valeur
expérimentale de la taille du buffer pour un débit donné.
Nous avons alors essayé d’extrapoler au mieux les points par une loi qui ne provoquait pas
de rupture de séquence en simulation comme le montre la figure 7.12.
A est maintenant calculé par la loi empirique suivante:
0
1
2
3
4
5
6
7
8
0 5 10 15 20 25 30
"NbFragRead6"
Temps (s)
Nombre de Fragments
14,89 Mbits/s 0,4 Mbits/s
A = E(3 × NbUtilisateurs ⁄ Nbdisques × DebitSequence × TaccDiskMoy ⁄ TailleFragment + 1, 5 )
Validation de la méthode par des études de cas
M.C.S.E 221
-Figure 7.12- Détermination d’une loi pour le calcul de A en fonction du débit.
-C- Résultats obtenus par simulation
Le nombre de disques est calculé de façon à avoir un flux de sortie supérieur ou égal au flux
d’entrée: avec
NbUtilisateurs=10, DebitMoy=7.5 Mbits/s, TaccDiskMoy=30 ms et
TailleFragment=32767x8.
La variation du nombre de fragments présents dans les fifos internes des fonctions Lecture
au cours de la simulation est la suivante.
-Figure 7.13- Nombres de fragments moyen et total dans l’ensemble des buffers.
1
2
3
4
5
6
7
0 2 4 6 8 10 12 14
"ABuffEstim"
int(0.43*x+1.5)
A
Debit (Mbits/s)
NbDisques = (NbUtilisateurs × DebitMoy × TaccDiskMoy ) ⁄ (TailleFragment) = 9
0
5
10
15
20
25
30
35
0 5 10 15 20 25 30
"NbFragReadMoy"
"NbFragRead"
Temps (s)
Nombre de Fragments
Total (dans le système)
Moyen (par buffer d’anticipation)
Chapitre 7
222 M.C.S.E
La valeur moyenne du nombre de fragments dans les fifos internes pour les fonctions
Lecture est de l’ordre de 3,5. La valeur plus élevée se justifie par le coté plus réaliste
d’implantation des blocs ou des disques consécutifs (Round-Robin). La simulation a bien
montré l’effet de coïncidences défavorables (accès aux mêmes disques ou temps d’accès
consécutifs à des disques plus élevés que la valeur moyenne) entraînant des ruptures de
séquences.
La taille moyenne du buffer d’anticipation nécessaire à la fonction Lecture pour éviter
toute rupture de séquences est donc 4. Il s’agit d’une valeur moyenne obtenue en considérant
un débit moyen de 7,5 Mbits/s par utilisateur, et il ne faut pas oublier que pour des séquences
de haut débit la valeur de A est supérieur à 4 (5 à 7). Comme la taille des buffers d’anticipation
doit être dynamique, l’ensemble des buffers d’anticipation doit être implanté non pas sous la
forme d’un ensemble disjoint de fifos mais dans une zone mémoire commune dont la
dimension sera calculée avec une valeur moyenne de A de 4. Ce résultat est important pour la
phase de conception architecturale qui est présentée dans [CALVEZ-97a].
7.1.6 Modélisation des performances du serveur avec des processeurs
Une simulation qui consiste à faire intervenir la notion de structure d’exécution pour le
dimensionnement de la solution matérielle est bien moins évidente. Le but d’une telle
simulation est d’étudier l’influence du degré de parallélisme (nombre de processeurs) et de la
puissance de traitement de chaque processeur Exécution comme support d’implantation de
toutes les fonctions Enregistrement et Lecture. A ce stade, on peut parler de co-simulation
parce que le logiciel est simulé en même temps que l’architecture matérielle.
-A- Modèle et résultats de simulation
La structure fonctionnelle simulée est représentée par la figure 7.9.
Le processeur Supervision supporte toutes les fonctions de dialogue. Le processeur
Exécution supporte toutes les fonctions critiques Lecture et Enregistrement. Les disques sont
des fonctions avec leur propre ressource d’exécution.
Les attributs caractérisant chaque processeur sont au départ:
- pour Supervision: ‘Power=1, ‘Concurrency=1 (à faire varier), ‘Policy=PSP,
- pour Exécution: ‘Power=1, ‘Concurrency=m (à faire varier), ‘Policy=PSP.
PSP (Priority Scheduling Policy) veut dire le choix d’un ordonnancement des fonctions
selon leur priorité. ‘Power représente la puissance relative du processeur, ‘Concurrency
représente le nombre de fonctions exécutables simultanément ce qui simule en fait le nombre
de processeurs physiques.
La simulation du modèle a permis par exemple d’estimer avec 10 utilisateurs et pour un
scénario de charge donné:
- le retard de démarrage d’une séquence (temps entre la demande faite par un
utilisateur et le premier fragment émis),
- le taux d’occupation du processeur d’exécution.
Validation de la méthode par des études de cas
M.C.S.E 223
Ces résultats sont représentés par les courbes de la figure 7.14.
-Figure 7.14- Scénario de charge, retard au démarrage et taux d’occupation du processeur.
Comme le taux d’occupation du processeur d’exécution est faible (25%), nous nous
sommes intéressés à l’influence du nombre d’utilisateurs sur l’attribut ‘Power du processeur
d’exécution. Pour qu’il n’y ait pas de rupture de séquences en fonction du nombre
d’utilisateurs, la valeur minimale de l’attribut ‘Power (‘Concurrency=1) est donnée par la
courbe suivante.
Temps (s)
0
0.05
0.1
0.15
0.2
0.25
0.3
0 5 10 15 20 25 30
"CPU Utilization Rate"
0
1e+07
2e+07
3e+07
4e+07
5e+07
6e+07
7e+07
8e+07
0 5 10 15 20 25 30
"CurrentThroughput"
0.03
0.04
0.05
0.06
0.07
0.08
0.09
0.1
0.11
0.12
0.13
0.14
0 5 10 15 20 25 30
"StartDelay"
Temps (s)
Temps (s)
Taux d’occupation du
processeur Exécution
Retard au démarrage (s)
Charge imposée
au système (Mbits/s)
Chapitre 7
224 M.C.S.E
-Figure 7.15- Influence du nombre d’utilisateurs sur l’attribut ‘Power.
Avec comme caractéristiques du processeur d’exécution ‘Concurrency=1 et ‘Power=0.33,
le taux d’occupation du processeur pour une charge donnée est de l’ordre de 80%.
-Figure 7.16- Charge imposée au système et taux d’occupation du cpu.
Avec les temps choisis pour les opérations élémentaires du modèle de performance de la
fonction Lecture, on peut seulement conclure qu’un seul processeur d’exécution peut gérer 10
0.05
0.1
0.15
0.2
0.25
0.3
0.35
2 3 4 5 6 7 8 9 10
"power"
Power
Nombre d’utilisateurs
0
0.2
0.4
0.6
0.8
1
0 5 10 15 20 25 30
"CPU Utilization Rate"
1e+07
2e+07
3e+07
4e+07
5e+07
6e+07
7e+07
8e+07
9e+07
0 5 10 15 20 25 30
"CurrentThroughput"
Temps (s)
Temps (s)
Taux d’occupation du
processeur Exécution
Charge imposée
au système (Mbits/s)
Validation de la méthode par des études de cas
M.C.S.E 225
séquences simultanées ayant un débit moyen de 7,5 Mbits/s, soit un débit de 75 Mbits/s. Il est
dommage que les limitations mémoire de l’ordinateur utilisé pour la simulation et les temps de
simulation qui sont relativement longs (environ 3 heures de simulation) ne nous ont pas permis
d’étudier plus précisément l’influence du nombre d’utilisateurs sur les attributs ‘Concurrency
et ‘Power du processeur d’exécution.
7.1.7 Bilan sur l’évaluation des performances du serveur vidéo
Sur la base de cet exemple, nous pouvons affirmer que l’évaluation des performances
dynamiques d’un système par co-simulation n’est pas limitée par la complexité du système et
permet d’extraire un ensemble de résultats de performances plus riche que les approches
analytiques tels que le débit sur un bus, le taux d’occupation d’une ressource (processeurs
logiciels, disques, bus,...), le temps de latence d’un message, la détection du non respect d’une
contrainte temporelle, un temps de retard au démarrage, etc. Cependant, la co-simulation
souffre d’un temps de simulation trop long. Pour réduire les temps de simulation, il faut
augmenter le niveau d’abstraction des modèles d’où l’intérêt d’un modèle de performance
mascroscopique et non interprété: les entrées et les données internes influencent le
comportement du système uniquement par l’intermédiaire d’attributs. Par exemple, les
attributs Size (taille) et Id (destinataire) d’un message remplace le contenu du message.
L’analyse des performances qui a été effectuée lors de l’étape de conception fonctionnelle
ou conception préliminaire aide au dimensionnement des éléments internes du système. Nous
avons pu montrer l’efficacité du modèle en considérant particulièrement les 2 niveaux de
modélisation considérés pour les disques: une seule ressource avec un degré de concurrence,
autant de disques avec chacun un modèle aléatoire représentatif de son comportement. La
modélisation des performances faite pour les 2 niveaux d’abstraction du serveur (fonctionnel
et exécutif) a permis de déduire et confirmer des paramètres importants que nous ne pouvions
pas déterminer par la modélisation statique. Les résultats apparaissent similaires avec les 2
modélisations. Nous avons la confirmation que la valeur de A moyen est de 4 (donc 4 places
par séquence), ce qui permet de calculer la taille de la mémoire interne nécessaire. Au niveau
exécutif, il est possible d’observer l’influence de la politique d’ordonnancement (attribut
‘Policy) et de la puissance du processeur (attribut ‘Power). La politique d’ordonnancement
n’apparaît pas significative. Peut-être ceci est lié à la limitation à 10 utilisateurs.
Dans [CALVEZ-97a], cet exemple a également servi à montrer l’importance de l’approche
système et d’un partitionnement en deux temps (système et matériel/logiciel) pour déterminer
les parties du système relevant de l’activité de co-design. Ces parties concernent ici
l’interfaçage de la mémoire centrale implantant les buffers d’anticipation de taille dynamique
avec les disques et les cartes contrôleur ATM.
7.2 SYSTEME DE COMMUNICATION
Le second exemple présenté ici a servi d’exemple d’illustration de la démarche de
co-design associée à la méthodologie MCSE. Il a été détaillé dans différentes publications
[CALVEZ-94] [CALVEZ-96c]. Il a également servi à la présentation du modèle de
performance et du principe d’évaluation des performances dans [CALVEZ-96b].
Chapitre 7
226 M.C.S.E
7.2.1 Présentation de l’exemple
Il s’agit d’un système de communication basé sur un ensemble de cartes identiques
inter-connectées par un bus série du type anneau à jeton appelé Transbus et détaillé dans
[CALVEZ-96c]. Sur chaque carte, les producteurs doivent envoyer de courts messages (256
octets maximum) à des consommateurs situés sur la même carte ou sur une autre carte. Les
producteurs et consommateurs sont implantés par des tâches logicielles. Les spécifications du
système et du bus sont représentées par la figure 7.17. Le bus au débit maximum de 20 Mbits/s
se compose de 4 lignes:
- une ligne (Data) de transport des données dont le protocole de communication au
niveau bit est similaire à celui utilisé par les liens séries d’un transputer (T800) excepté
pour l’acquittement,
- une ligne (Ack) utilisée pour l’acquittement de chaque octet transmis,
- deux lignes (TokenIn et TokenOut) pour gérer l’accès au bus selon le principe des bus
du type anneau à jeton.
Chaque message transmis contient l’adresse du destinataire, la longueur de l’information
transmise et l’information. A tout moment, seule la carte qui possède le jeton peut envoyer un
message et/ou passer le jeton à sa voisine.
-Figure 7.17- Spécification du système de communication.
7.2.2 Objectif de l’évaluation des performances pour cet exemple
L’objectif du concepteur du système est de concevoir et implanter correctement une carte
en tenant compte des contraintes de performances. Ce système peut être implanté selon une
architecture générique basée sur un microprocesseur, un FPGA et une mémoire commune. Il
est facile d’extraire dans cet exemple la partie minimale à implanter en matériel pour satisfaire
le débit du bus et le protocole de communication au niveau bit imposé par Transbus
[CALVEZ-96c]. Dans la suite, nous supposerons l’existence de cette partie matérielle qui
implante l’interface bas niveau du bus. Elle comporte une fonction de conversion
parallèle/série pour la transmission de chaque octet et la fonction inverse pour la réception bit
à bit d’un octet.
T11 T1j
Ad LG DATA
Ad LG DATA
Tp1 Tpl
Ad LG DATA
Ti1 Tik
Ad LG DATA
Carte 1 Carte i Carte p
TRANSBUS
Txxx: tâche
AddrC Longueur Data
8 bits 8 bits Longueur Octets
20 Mbits/s 4 lignes Anneau à jeton
format d’un message
TokenIn
TokenOut
ACK
DATA
TRANSBUS
Carte 1 Carte 2
Validation de la méthode par des études de cas
M.C.S.E 227
Nous nous intéressons donc au système en considérant uniquement une transmission au
niveau octet et non bit. Après avoir défini la structure fonctionnelle de la solution et le
comportement de chaque fonction, nous étudions l’influence de plusieurs solutions de
partitionnement matériel/logiciel sur les performances du système. Les critères de
performances retenus ici sont à la fois internes (taux d’occupation du processeur) et externes
(débit sur le bus, temps de latence des messages). Ces résultats sont obtenus par une
co-simulation du matériel et du logiciel à un niveau macroscopique et non-interprété mais
suffisamment détaillé pour observer rapidement des résultats intéressants.
7.2.3 Le modèle fonctionnel
Pour concevoir le système de communication, il est nécessaire de prendre en compte la
décomposition du système en un ensemble de cartes et le bus d’interconnexion (répartition
géographique de l’application). Ce travail correspond aux deux premières étapes de la
méthodologie MCSE: l’étape de spécification et l’étape de conception fonctionnelle. La
structure fonctionnelle obtenue est représentée sur la figure 7.18. Le bus transbus y est
modélisé sous la forme d’un vecteur d’événements Token[1:k] représentant la circulation du
jeton et un vecteur de ports de communication TB[1:k] pour le transfert de messages entre
cartes.
-Figure 7.18- Structure fonctionnelle détaillée d’une carte du système de communication.
Chaque message produit est envoyé par un producteur Prod[i] à la fonction Routing via le
port Treq[i]. Le champ d’adresse du message est utilisé par la fonction Routing pour déterminer
si le destinataire du message est local (situé sur la même carte) ou distant.
Pour une communication à distance, la fonction EmissionMess envoie chaque message
reçu de Lreq à la carte concernée via le port TB. Comme seulement une et une seule carte peut
accéder au bus à un moment donné, EmissionMess commence par faire une requête du jeton
(événement ReqEmis), attend le jeton (événement OkToken) et envoie le message octet par
octet dans TB[]. Lorsque l’émission du message est terminée, EmissionMess relache le jeton
ReqEmis
TokenOut
OkToken
Treq[1:n] Tcons[1:n]
Lind
Prod Cons
Routing Dmux
Lreq
Prod[1:n] Cons[1:n]
Lcons
Token[i+1 mod K]
TransBusOut TransBusIn
EndEmis
TB[1:K]
Carte
TB[1:K] TB[i]
Token[1:K]
Carte[i]
Token[i]
b) interconnexion des cartes
a) solution fonctionnelle de chaque carte
Management
Token EmissionMess ReceptionMess
Matériel ou Logiciel
Logiciel
1
3
2
Carte[1:K]
‘Capacity=1 ‘Capacity=1
‘Capacity=5 ‘Capacity=5
‘Capacity=0
Matériel ou Logiciel
Chapitre 7
228 M.C.S.E
(événement EndEmis) qui est envoyé par la fonction TokenManagement à la carte voisine
(événement Token[i+1MOD k])
La fonction ReceptionMess reçoit chaque message addressé à la carte et l’envoie à la
fonction Dmux via le port Lind. Dmux envoie le message au consommateur concerné.
Sur la figure 7.18-b, le rond noir sert à spécifier que chaque carte est capable d’envoyer un
message à tous les éléments du vecteur TB et de générer un événement pour chaque élément
du vecteur Token.
7.2.4 Le modèle de comportement
Le modèle de comportement de chaque fonction est donné par la figure 7.19. Pour spécifier
complètement le comportement, des attributs sont ajoutés au modèle graphique. Pour
comprendre les notations utilisées, il est utile de préciser que Treq[] signifie que l’indice du
port est le même que celui du producteur et que Treq[:] signifie que l’on considère le vecteur
complet.
-Figure 7.19- Modèle de comportement non interprété de chaque fonction.
Prod
*
Tprod
‘Size=4+Uniform(250) bytes;
Tprod‘Time=Uniform(1, 100) ms;
Prod :: {Tprod&Treq[]}*
*
Trcons
Trcons‘Time=1 ms;
Cons :: {?Tcons[]&Ttcons}*
Prod Cons
Trouting
Lcons
Treq[:]
‘Size=Treq[]‘Size;
Routing
OR
*
Tdmux
‘Id=Uniform(1:n);
S
Lcons
Tcons[:]
Dmux
Treq[]
Lreq
OR
*
Proba=0.5
TRouting‘Time=0.1 ms;
Routing :: {?|Treq[:]&Trouting&
!(<0.5)Lcons|<*>LReq)}*
Lind
OR
Tdmux‘Time=0.1 ms;
Dmux :: {?(Lcons|Lind)&Tdmux&
!$Tcons[:]}*
Tcons[]
*
SToken
TokenManagement
Token[] ReqEmis
EndEmis
OkToken
Token[:]
SToken‘Time=1 μs;
Lreq
Path= ‘Id;
EmissionMess
S
TB[1:K]
Temis‘Time=A*1 μs;
EmissionMess :: {?Lreq&!ReqEmis&?OkToken&
!$TB[:]&Temis&!EndEmis}*
Temis
‘Write= A*Lreq‘Size;
‘Id=Uniform(1,K);
ReqEmis
OkToken
EndEmis
TB[]
ReceptionMess
Lind
Trecept‘Time=A*1 μs;
ReceptionMess :: {?TB[]&Trecept&!Lind}*
Trecept
‘Write= 0 ms;
TokenManagement :: {[?Token[]|?ReqEmis&
?Token[]&!OkToken&?EndEmis]&
SToken&!$Token[:]}*
Path= (Me+1) mod K;
S
Path=‘Id;
*
* *
Validation de la méthode par des études de cas
M.C.S.E 229
Les producteurs et consommateurs sont des process cycliques très simples. La taille des
messages produits est tirée aléatoirement entre 4 et 255. L’intervalle de temps entre l’émission
successive de deux messages est défini par le temps d’exécution de l’opération élémentaire
Tprod. C’est une façon très simple de spécifier la charge imposée au système pour la
simulation.
La fonction Routing reçoit les messages de tous les ports Treq[1:n] et simule le routage
d’une partie de ces messages vers le port Lcons (messages locaux). l’attribut ‘Proba est utilisé
pour spécifier la sortie sélectionnée. Chaque message généré comporte l’attribut ‘Size du
message d’entrée. Dmux reçoit des messages des ports Lcons et Lind et les envoie vers le
consommateur désigné par l’attribut ‘Id tiré aléatoirement entre 1 et n.
La fonction TokenManagement a la charge d’allouer le bus à une seule carte. Une attente
conditionnelle est utilisée pour attendre l’occurrence du jeton (Token) provenant de la carte
voisine ou bien la requête du jeton par la fonction EmissionMess (ReqEmis). Si il n’y a pas de
demande d’émission, le jeton est transmis directement à la carte voisine.
La fonction EmissionMess reçoit un message de Lreq et demande le jeton. La transmission
de chaque message sur le bus transbus est modélisée par l’envoi du message sur un des
éléments du port TB dont l’index est défini par l’attribut ‘Id (valeur aléatoire entre 1 et K). Le
temps de transmission est spécifié par l’attribut ‘Write et dépend de la longueur du message et
d’un paramètre A qui représente le temps de transmission de chaque octet. La fonction
ReceptionMess est un process cyclique qui attend un message du port TB et l’envoie vers le
port Lind.
7.2.5 Co-simulation et résultats
L’objectif de cette co-simulation est de montrer que le modèle de performance permet
d’évaluer les performances globales de différentes implantations de la solution fonctionnelle
d’un système. Pour notre exemple, nous avons considéré 3 implantations différentes. Sur la
figure 7.18-a, la description fonctionnelle est décomposée en 3 zones: la zone 1 comporte les
fonctions qui sont obligatoirement implantées en logiciel, la zone 2 inclut les fonctions de
transmission et réception sur le bus Transbus, et la zone 3 est constituée uniquement de la
fonction de gestion du jeton.
La co-simulation a pour but d’étudier la modification des performances si les zones 2 et 3
sont implantées en matériel ou en logiciel.
A ce stade, il est également important de bien définir la charge imposée au système et les
critères de performances retenus pour décider laquelle des implantations est la meilleure.
En ce qui concerne la charge imposée au système, les producteurs envoient en permanence
(Tprod’Time=0) des messages de taille aléatoire sur des cartes distantes (Proba=0) d’adresse
aléatoire. Un consommateur est également supposé dépenser au moins 1 ms pour exploiter
chaque message reçu. L’asservissement des producteurs aux consommateurs dépend de la
capacité de chaque port. Nous avons choisi une capacité de 1 pour les ports Treq et Tcons et de
5 pour les ports Lreq et Lind. Enfin, le comportement correct du bus modélisé avec le port TB
est obtenu avec un mécanisme de rendez-vous (‘Capacity=0) entre l’émetteur EmissionMess
et le récepteur ReceptionMess.
Les critères de performances retenus sont le taux d’occupation du processeur exécutant le
logiciel de chaque carte, le débit sur le bus et le temps de latence des messages. A cause du
caractère aléatoire du modèle, ces trois résultats sont évalués par une moyenne des résultats de
Chapitre 7
230 M.C.S.E
toutes les cartes et lorsque le système a atteint un état stationnaire (la durée de l’état transitoire
observée par simulation est d’environ 0,1 s). Nous avons également fait varier le nombre de
cartes (paramètre générique k) et le nombre de producteurs et consommateurs par carte
(paramètre générique n).
-A- Maximum en matériel (zone 2 et 3 en matériel)
Pour obtenir des résultats appropriés, il est nécessaire de connaître le temps de transfert
d’un octet sur le bus quand les fonctions EmissionMess et ReceptionMess sont implantées en
matériel. Cette valeur provient de l’étude présentée dans [CALVEZ-94]. Pour obtenir cette
valeur, on peut aussi considérer le protocole de communication de transbus au niveau bit:
11 bits x 50 ns = 0.7 s (8 bits de données et 2 bits de start et 1 bit de stop émis à 20 Mbits/s).
Nous avons donc choisi comme valeur du paramètre A=0.7 s. Le temps de passage du jeton
SToken‘Time de la fonction TokenManagement est fixé à 1 s.
Toutes les fonctions logicielles de la carte sont implantées sur le même processeur. On
rajoute pour cela une fonction nommée Processeur et qui englobe les fonctions logicielles de
la carte. Cette fonction simule une ressource ayant un degré de concurrence de 1, ce qui signifie
qu’une seule fonction peut être active à un moment donné. Des attributs caractérisent cette
fonction: son degré de concurrence (attribut ‘Concurrency) et sa puissance (attribut ‘Power).
L’attribut ‘Power est très utile pour modifier la vitesse d’exécution de toutes les tâches
logicielles et d’étudier son influence sur les performances globales du système. Les attributs
‘Policy et ‘Priority permettent également de définir la politique d’ordonnancement des tâches.
Ici, la priorité la plus élevée est pour Dmux, puis Routing, Cons et enfin Prod.
Les résultats de la co-simulation sont données par la figure 7.20.
-Figure 7.20- Résultats pour le maximum de matériel.
Le temps de latence des messages croit avec le nombre n de producteurs et consommateurs
car ils se partagent tous le même processeur. Le débit sur le bus dépend uniquement du
paramètre k qui représente le nombre de cartes. La constance du débit par rapport au paramètre
n est due au fait que le temps de transmission d’un message qui est en moyenne de 90 s
(129x0.7) est négligeable par rapport à son temps de consommation (1 ms). Par conséquent; le
port Lind est rapidement saturé et après avoir obtenu le jeton, la fonction EmissionMess doit
attendre jusqu’à ce que ReceptionMess soit prête à recevoir un message. Le taux d’occupation
du processeur est relativement faible pour K=3 car comme nous le verrons plus loin le bus est
mal utilisé.
μ
μ
μ
Temps de latence des messages Débit sur le bus Taux d’occupation du processeur
20
30
40
50
60
70
80
90
100
110
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
1e+06
1.5e+06
2e+06
2.5e+06
3e+06
3.5e+06
4e+06
4.5e+06
5e+06
5.5e+06
6e+06
6.5e+06
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
0.4
0.45
0.5
0.55
0.6
0.65
0.7
5 10 15 20 25
"k=3"
"k=6"
"k=9"
ms
n n n
bit/s
μ
Validation de la méthode par des études de cas
M.C.S.E 231
-B- Transmission en logiciel (zone 1 et 2 en logiciel)
Pour une implantation logicielle de EmissionMess et ReceptionMess la valeur du paramètre
de vitesse de transmission sur le bus est fixée à A=7 s. Les deux nouvelles fonctions
logicielles sont rajoutées à la fonction Processeur avec la priorité la plus élevée pour
ReceptionMess puis pour EmissionMess.
Les résultats obtenus sont donnés par la figure 7.21.
-Figure 7.21- Résultats pour la transmission implantée en logiciel.
Le temps de latence des messages croit en fonction du nombre n de
producteurs/consommateurs et du nombre k de cartes. Le débit sur le bus est indépendant des
paramètres n et k. Cette valeur constante est due au temps de transmission de chaque message:
129*8/(129x7 s) = 1.15 Mbits/s. Le bus est donc le goulot d’étranglement du système. Le taux
d’occupation du processeur est élevé pour k=3 et relativement faible pour k=6 et 9 car le bus
limite le nombre de messages transmis.
-C- Tout en logiciel
La fonction TokenManagement est rajoutée à la fonction Processeur avec la priorité la plus
élevée. Le temps d’exécution choisi pour l’opération élémentaire SToken est de 20 s ce qui
correspond au temps nécessaire au processeur pour recevoir et traiter une interruption.
Les résultats sont donnés par la figure 7.22.
-Figure 7.22- Résultats pour une implantation logicielle de toutes les fonctions du système.
Le débit sur le bus est encore constant et un peu plus faible que précédemment car 20 s
ont été rajoutées entre deux émissions successives de messages. Le temps de latence des
messages et le taux d’occupation du processeur restent similaires.
μ
Temps de latence des messages Débit sur le bus taux d’occupation du processeur
0
50
100
150
200
250
300
350
400
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
1e+06
1.05e+06
1.1e+06
1.15e+06
1.2e+06
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
0.2
0.25
0.3
0.35
0.4
0.45
0.5
0.55
0.6
0.65
0.7
5 10 15 20 25
"k=3"
"k=6"
"k=9"
ms
n n n
bit/s
μ
μ
Temps de latence des messages Débit sur le bus taux d’occupation du processeur
0
50
100
150
200
250
300
350
400
450
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
1e+06
1.05e+06
1.1e+06
1.15e+06
1.2e+06
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
0.2
0.25
0.3
0.35
0.4
0.45
0.5
0.55
0.6
0.65
0.7
5 10 15 20 25 30
"k=3"
"k=6"
"k=9"
ms
n n n
bit/s
μ
Chapitre 7
232 M.C.S.E
7.2.6 Bilan sur l’évaluation des performances du système de communication
Dans le cas A (zone 2 et 3 en matériel), le débit maximum du bus égal à 11.4 Mbits/s
(8/0.7 s) n’est pas atteint. Ceci est dû au fait que le protocole de communication au niveau
message n’est pas correct. En effet, la fonction EmissionMess est capable d’obtenir le bus pour
envoyer un message à une carte qui n’a plus de place libre dans le port Lind. Pour utiliser le
bus à son débit maximum, le protocole de communication doit être modifié pour envoyer un
message si et seulement si il existe une place libre pour recevoir le message. Cette modification
du protocole est présenté dans [CALVEZ-96c].
Pour un système composé 2 ou 3 cartes, le temps de latence des messages est sensiblement
le même pour les trois implantations. Dans ce cas, une implantation matérielle au coût
économique plus élevé ne se justifie pas.
Dans cet exemple, tous les résultats sont très dépendants du temps d’exécution de chaque
consommateur. La capacité de chaque port et la politique d’ordonnancement des tâches jouent
également un rôle important.
Avec cet exemple, nous avons montré que notre modèle autorise la co-simulation
macroscopique et non-interprétée des fonctions logicielles et des composants matériels. Il
permet ainsi au concepteur de trouver par une démarche itérative le partitionnement et
l’allocation optimale vis à vis des contraintes de performances dynamiques qui lui sont
imposées. L’utilisation de paramètres génériques (paramètres n et K par exemple) associés aux
attributs des éléments du modèle de performance permet aussi de parcourir un espace assez
vaste des solutions possibles d’un partitionnement sans nécessiter de mise à jour du modèle de
performance et de nouvelle génération du code VHDL équivalent.
7.3 CONCLUSION
Ces deux exemples ont permis de montrer que le modèle de performance est un outil
approprié pour aider au dimensionnement et au partitionnement des systèmes matériels et
logiciels. En particulier, il faut constater l’aptitude du modèle à représenter des systèmes ayant
une structure générique (vecteurs de ports, de fonctions, d’activités). Le concept d’attributs
associés aux objets permet aisément de définir un comportement. Des lois déterministes et
aléatoires servent alors à produire des valeurs pour ces attributs pour placer le modèle dans une
variété de situations réalistes. De plus, le concept de messages avec des attributs associés
permet de propager dynamiquement un comportement dans la structure.
Ces deux exemples qui regroupent la plupart des constructions du modèle de performance
nous ont également permis de valider les règles de transcription du modèle de performance en
VHDL et l’implantation de ces règles dans un générateur de code automatique.
L’exemple du système de communication a également permis de tester la transcription du
modèle de performance en C++/Kernel Windows NT. Il a permis de constater que l’exécution
du programme C++ obtenu est environ 4 fois plus rapide que la simulation VHDL équivalente.
Evidemment, le programme C++ seul ne permet pas de faire une analyse détaillée du
comportement du système (chronogrammes du simulateur VHDL). Mais il peut être couplé
directement à l’outil d’analyse de trace qui permet alors de faire du suivi du contenu de
variable, la visualisation d’un graphe de déroulement temporel (time line) et la définition des
μ
Validation de la méthode par des études de cas
M.C.S.E 233
nombreux indices de performances. Le simulateur VHDL a l’avantage d’être disponible sous
diverses plate-formes (Unix, Pc). Cependant, le meilleur compromis entre portabilité et temps
de simulation est probablement de choisir comme langage cible JAVA au lieu de VHDL et
C++.
Ces exemples ont également permis de mettre en évidence l’importance de l’extraction et
de l’interprétation des résultats. Il semble judicieux de laisser le choix à l’utilisateur entre une
génération automatique de trace et l’utilisation d’une librairie de composants de monitoring
mise à la disposition du concepteur.
Pour une évaluation des performances, la procédure itérative à suivre par les concepteurs
se décompose donc en 3 phases:
- modélisation incrémentale du système ou de l'application,
- évaluation des performances souhaitées,
- visualisation des résultats et interprétation.
La troisième phase conduit généralement à un retour sur la première phase pour modifier,
améliorer, poursuivre la décomposition du modèle, ou à un retour sur la deuxième phase pour
modifier la sélection des résultats demandés ou des paramètres de l'évaluation.
Chapitre 7
234 M.C.S.E

M.C.S.E 235
8
Conclusions et
Perspectives
Ce chapitre conclut la thèse en donnant un bilan du travail effectué et les perspectives
envisageables au terme de cette recherche. Nous rappelons tout d’abord les principales
caractéristiques de la méthodologie de co-design développée sur la base de la méthodologie
MCSE et de son modèle de performance. Ce modèle de performance est utilisé pour
l’évaluation des performances dynamiques avant et après le partitionnement matériel/logiciel.
Cette évaluation des performances faite par une co-simulation repose sur la transcription du
modèle de performance en un modèle VHDL simulable. Nous résumons donc également les
caractéristiques essentielles de la technique de génération de code utilisée pour transcrire le
modèle de performance en VHDL comportemental. Les perspectives envisageables au terme
de cette thèse sont diverses. Nous commentons l’enrichissement du modèle de performance,
l’estimation des performances statiques d’un système, l’estimation du temps d’exécution des
opérations élémentaires et l’exploitation d’un niveau de granularité plus fine pour le
partitionnement matériel/logiciel.
8.1 BILAN DE LA THESE
Dans le court terme, le problème du co-design concerne la définition et l’utilisation d’une
méthodologie appropriée, cohérente, complète et efficace et d’outils associés pour aider les
concepteurs à transformer le besoin du client en un produit opérationnel. A ce titre, l’objectif
premier de cette thèse a été de montrer l’apport de la méthodologie MCSE et de son modèle de
performance à la problématique du co-design et en particulier aux problèmes du
partitionnement matériel/logiciel et de la co-simulation. La méthode de partitionnement
retenue s’appuie sur une démarche itérative guidée par le concepteur et par une analyse des
Chapitre 8
236 M.C.S.E
performances dynamiques du système résultant d’un partitionnement. Cette analyse des
performances est réalisée par une technique de co-simulation qui consiste à traduire le modèle
de performance du système en un modèle VHDL simulable. Après avoir défini les règles de
transcription, nous avons développé un principe générique de génération de code et un
générateur de code VHDL. Les concepts du modèle de performance, les règles de transcription
et le générateur de code VHDL ont été validés à l’aide de deux exemples: un serveur vidéo
temps réel fourni par le CCETT de Rennes et un système de communication distribué.
-A- La méthodologie de co-design préconisée
Pour répondre à l’objectif initial, nous avons défini une nouvelle méthodologie de codesign
basée sur la méthodologie MCSE. Cette méthodologie de co-design concerne
principalement la conception des systèmes de contrôle/commande, des systèmes de
communications et partiellement des systèmes de traitement. Ces systèmes dits dédiés sont
généralement conçus pour répondre à un besoin spécifique et entrent dans la catégorie des
systèmes électroniques embarqués et temps-réels (Real Time Embedded Systems). La
méthodologie de co-design développée est caractérisée par une approche système, une
modélisation selon 3 vues (fonctionnelle, comportementale et architecturale), une architecture
cible hétérogène et non imposée, une méthode de partitionnement matériel/logiciel interactive
et itérative basée sur une évaluation des performances dynamiques par co-simulation et une
technique de co-simulation macroscopique et non-interprétée.
La technique de co-simulation repose sur la simulation d’un modèle de performance qui
représente à la fois la partie matérielle et la partie logicielle du système. Cette solution n’est
pas limitée par la complexité du système et permet d’extraire un ensemble de résultats de
performances plus riche que les approches analytiques.
Pour aboutir au produit, une fois le partitionnement matériel/logiciel terminé, les
descriptions fonctionnelles sont à transformer en code machine pour une implantation en
logiciel et en un ensemble de portes logiques et de bistables pour une implantation en matériel.
C’est le rôle de la phase de co-synthèse qui concerne la synthèse des parties matérielles et
logicielles et la synthèse des interfaces matériel/logiciel. Actuellement, l’équipe MCSE
travaille activement sur la génération de code C exécutable, de code VHDL synthétisable et sur
la synthèse des interfaces logiciel/matériel.
Notre approche permet d’exploiter à nouveau le modèle de performance après synthèse. En
effet, l’affinement des temps des opérations avec leur rétro-annotation dans le modèle de
performance permet d’évaluer le système sans utiliser obligatoirement des techniques de
simulation hétérogène (IPC d’unix, fond de paniers de simulateurs, interface via le bus du
microprocesseur, etc.). Ce principe de co-simulation qui utilise un niveau d’abstraction des
modèles plus élevé que celui utilisé habituellement a l’avantage de réduire sensiblement les
temps de simulation tout en permettant une évaluation assez fine des performances dynamiques
du système. De plus, il ne se limite pas nécessairement à l’évaluation des performances. En
effet, en remplaçant le temps des opérations élémentaires par une description algorithmique,
on obtient alors un modèle interprété qui permet de faire une vérification fonctionnelle du
système.
-B- Le modèle de performance de MCSE
Le travail effectué lors de cette thèse a permis d’enrichir et valider les concepts du modèle
de performance utilisé pour l’estimation des propriétés d’un partitionnement matériel/logiciel.
Conclusions et Perspectives
M.C.S.E 237
Ce modèle est macroscopique, non-interprété, évolutif, générique et paramétrable. Il est
basée sur l’emploi du modèle fonctionnel et du modèle exécutif de la méthodologie MCSE et
d’un modèle de composition d’activités dynamiques qui décrit le comportement des fonctions.
Les deux modèles sont enrichis avec des attributs pour spécifier les caractéristiques de chaque
élément. L’un des attributs clef est le degré de concurrence d’un élément actif car il permet de
simuler un processeur logiciel (processeur au degré de concurrence limité) et donc de faire de
la co-simulation.
L’intégration du modèle de performance à la méthodologie de conception MCSE sur
laquelle repose notre méthodologie de co-design offre une démarche descendante de
développement intégrant au mieux la maîtrise des performances simultanément à la maîtrise
des fonctionnalités. Comme le montre la figure 8.1, en utilisant le modèle de performance, le
concepteur dérive par transformations et enrichissements successifs à partir des spécifications,
une solution de conception puis une solution d'implantation et simultanément décrit et évalue
les propriétés de performances à chaque stade. A partir de l’étape de conception fonctionnelle,
l’unicité du modèle facilite aussi la conception sans erreur (pas de déformation ou perte
d’information liées à une transcription de modèle) et améliore la traçabilité.
-Figure 8.1- Démarche de conception avec maîtrise des performances.
-C- Les règles de transcription en VHDL
Le choix du langage VHDL se justifie par sa standardisation, sa portabilité, la disponibilité
des nombreux outils sur le marché et ses propriétés intrinsèques (modèle hiérarchique,
paramétrable, parallélisme inhérent, instanciation multiple, etc.).
Cependant, comme le langage VHDL ne dispose pas de mécanisme de suspension de
process, nous avons du décrire explicitement un composant ordonnanceur et une procédure
spécifique de gestion des temps d’attente. Le manque de généricité pour la déclaration des
types et les constructions telles que l’attente conditionnelle, l’achèvement forcé d’activité et
certains cas de l’instanciation multiple ont également posé des difficultés de transcription. Pour
ces cas, la complexité de la solution d’implantation en VHDL se paie malheureusement au
niveau de la génération de code et de la lisibilité et de l’efficacité du code VHDL produit.
Malgré le niveau d’abstraction du modèle, la simulation des programmes VHDL obtenus à
partir des modèles de performance du serveur vidéo temps-réel et du système de
communication a permis de constater la nécessité de ressources importantes (puissance de
calcul et mémoire) et une durée de simulation un peu trop longue pour trouver rapidement la
Validation
Système
Besoin
Vérification
Vérification
Vérification
Vérification
Vérification
Vérification
Performances
Spécifications de performances
Conception fonctionnelle Modélisation de performances
Conception Architecturale Evaluation de performances
Réalisation Observation de performances
Spécifications fonctionnelles processus de maîtrise
des performances
processus de
conception fonctionnelle
Chapitre 8
238 M.C.S.E
solution optimale recherchée. Ces constatations justifient pleinement l’intérêt d’une méthode
de simulation en C++ que l’équipe développe.
-D- Génération du modèle VHDL
Le générateur de code VHDL a été réalisé sur un principe générique de développement de
générateurs de code ou d’outils de transformation de textes qui permet de transcrire facilement
le modèle MCSE (ou tout autre langage source) vers d’autres langages cibles. Un générateur
est alors le résultat de la définition des grammaires des langages source et cible afin d’obtenir
les analyseurs syntaxiques associés, la définition d’un ou plusieurs fichiers template et
l’écriture d’un script. Ce script sert de point d’entrée au générateur de générateurs de code ou
méta-générateur nommé MetaGen qui permet d’interpréter le script ou de le transcrire en code
JAVA. L’écriture du script du générateur de VHDL comportemental a permis de constater que
tout script est décomposable en une partie analyse du modèle source commune à tous les
générateurs de la plate-forme MCSE et une partie génération de code spécifique.
Notre solution permet d’obtenir des outils multi plate-formes, basés sur une architecture
générique commune, configurables et plus faciles à développer et à enrichir.
Le travail effectué sur la génération de code a aussi amené l’équipe MCSE à revoir sa
stratégie de développement des outils comme support pour la méthodologie MCSE. En effet,
l’expérience de génération de code effectuée lors des travaux de cette thèse a permis
d’appréhender les concepts de générateurs d’analyseurs syntaxiques et de méta-structure sur
lesquels repose entièrement la nouvelle "philosophie" de développement des outils MCSE.
8.2 PERSPECTIVES
Les perspectives envisageables en prolongement direct de cette thèse concernent 3 objectifs
importants: l’enrichissement de l’estimation des propriétés des systèmes par une estimation du
temps d’exécution des opérations élémentaires et des performances statiques d’un système,
l’enrichissement des concepts du modèle de performance pour l’analyse de la sûreté de
fonctionnement et de la tolérance aux fautes des systèmes, le changement du niveau de
granularité du partitionnement matériel/logiciel.
-A- Enrichissement de l’estimation des propriétés des systèmes
Notre technique d’estimation des propriétés d’un système par co-simulation s’applique
efficacement aux performances dynamiques du système. Il est utile de compléter cette
évaluation par une estimation du temps d’exécution des opérations (activités élémentaires) et
une analyse des performances dites statiques des propriétés des constituants et du système
résultant.
Avec le modèle de performance de MCSE, les estimations de performances dynamiques
s’obtiennent à partir des temps d’exécution supposés pour les opérations. Ces temps peuvent
se déduire plus précisément à partir d’une description VHDL ou C de l’algorithme de l’activité
élémentaire. Il s’agit avant tout d’utiliser les travaux réalisés ou actuels sur cet aspect (Program
Analysis): technique de profiling, utilisation d’un modèle ISA [KNUDSEN-95] [BALBONI-
95] [ROSE-96] ou transformation de la description en un graphe flot de contrôle/donnée
(CDFG) et analyse du graphe obtenu [NARAYAN-92b] [MALIK-95] [GUPTA-95].
Une estimation des performances que l’on peut considérer plutôt statiques des systèmes
nous apparaît utile d’une part pour aider le concepteur lors du partitionnement système et
d’autre part pour réduire l’espace des solutions possibles à parcourir lors du partitionnement
Conclusions et Perspectives
M.C.S.E 239
matériel/logiciel. L’objectif est alors d’obtenir une zone plus réduite des solutions appropriées
pour tendre vers une solution globalement optimale et d’appliquer ensuite sur cette zone notre
technique d’estimation des performances dynamiques afin d’obtenir la solution optimale vis à
vis des contraintes imposées. Pour cela, nous recommandons autant que possible l’emploi des
techniques et outils existants et des méthodes d’évaluation analytique. Les performances
statiques de chaque processeur matériel (surface de silicium occupée, puissance consommée,
nombre de broches) dérivent des techniques de synthèse comportementale [NARAYAN-92b]
[VAHID-92] ou d’estimations à priori et celles des processeurs logiciels (taille du code, taille
de la mémoire nécessaire) des techniques de compilation.
Le concept d’attributs utilisé dans le modèle de performance est très intéressant pour
calculer une estimation globale du système à partir des estimations de chaque constituant,
obtenir une estimation grossière très tôt dans le cycle de développement (loi empirique
pondérée par un ensemble d’attributs), laisser la liberté aux concepteurs d’utiliser des formules
d’estimation qui lui sont propres ou encore faire une estimation des coûts. En effet, à partir des
paramètres obtenus par une estimation des performances statiques du système et représentés
sous forme d’attributs (‘Area, ‘Pin, ‘CodeSize, ‘MemoryUsed, etc.), une approximation du
coût des composants et du temps de conception du système est calculable [MADISETTI-95].
-B- Enrichissement du modèle de performance pour la sûreté de fonctionnement
Parmi les contraintes que doit satisfaire un système électronique embarqué, la sûreté de
fonctionnement est souvent une des exigences non-fonctionnelles non évidentes formulées
dans le cahier des charges du produit à concevoir. Aussi, il apparaît intéressant et opportun
d’enrichir le modèle de performance avec des concepts dédiés à l’analyse de la sûreté de
fonctionnement et de la tolérance aux fautes d’un système. Pour la tolérance aux fautes, un
concepteur peut saisir un modèle de performance qui représente un système avec détection et
correction d’erreur. Compte tenu de notre modèle, pour l’instant, il doit explicitement définir
le principe de détection et correction d’erreur retenu. Pour l’aspect sûreté de fonctionnement,
il faut être capable de modéliser le dysfonctionnement éventuel d’un processeur ou des
éléments de communication inter-processeurs (mémoire commune, interruption et noeud de
communication). Tout comme pour la tolérance aux fautes, le modèle doit faciliter la création,
la détection et la correction d’un dysfonctionnement d’un constituant de l’architecture
matérielle. Pour cela, des attributs représentant par exemple le taux de dysfonctionnement et le
degré de dédoublement d’un élément peuvent être rajoutés.
-C- Changement du niveau de granularité pour le partitionnement matériel/logiciel
Le degré de granularité du partitionnement matériel/logiciel de notre méthodologie est du
niveau tâche car l’unité d’allocation est la fonction. Le comportement de chaque fonction est
caractérisé par une composition d’activités dynamiques. Or, il y a actuellement un
développement incontestable en recherche sur les architectures reconfigurables
dynamiquement et les méthodologies associées pour leur exploitation (reconfigurable
computing). Il nous apparaît possible et opportun de choisir comme unité d’allocation l’activité
dynamique. Ainsi, les activités d’une fonction considérée jusqu’à présent indivisible,
pourraient être allouées sur plusieurs processeurs ou réalisées par un même processeur matériel
à des instants différents. Les générateurs de code utilisés durant la phase de synthèse devront
exploiter le fait qu’une activité à une durée de vie limitée dans le temps pour permettre la
reconfiguration dynamique et temps-réel des processeurs matériels au cours du fonctionnement
Chapitre 8
240 M.C.S.E
du système. Le partitionnement devient alors principalement un problème d’ordonnancement
de tâches dynamiques dans un système distribué.